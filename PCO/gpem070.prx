#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM070.CH"
#INCLUDE "TBICODE.CH"
#INCLUDE "TBICONN.CH"

Static lGpa070mn 
Static lGp070Fim 

/*


Ŀ
Funao	  GPEM070	 Autor  Emerson Rosa de Souza           | Data  21.06.00 
Ĵ
Descriao  Calculo da Provisao de Ferias			                            
Ĵ
Sintaxe	  GPEM070(void)								  		        	    
Ĵ
Parametros												                        
Ĵ
 Uso  	  Generico 							         					    
Ĵ
 		ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.		                
Ĵ
Programador  Data	 BOPS             Motivo da Alteracao					    
Ĵ
Ricardo D.  22/12/06------          Ajuste no calculo do FGTS da baixa do 13o 
                    ------          salario pois estava abatendo a 1a parcela 
                    ------          independentemente da pergunta "desc.1a.p."
                    ------          preenchida com "N".                       
Ricardo D.  26/12/06116597          Ajuste na baixa da provisao de ferias com 
                    ------          MV_TPBXFER igual a "2" pois estava descon-
                    ------          tando antecipacao de ferias para ferias a 
                    ------          vencer.                                   
Ricardo D.  03/01/07116597          Ajuste na baixa da provisao de ferias com 
                    ------          MV_TPBXFER igual a "2" para deixar saldo  
                    ------          de provisao de ferias vencidas sempre que 
                    ------          houver a quitacao do periodo aquisitivo do
                    ------          funcionario.                              
Ricardo D.  22/01/07085125           Implementacao de melhoria de performance 
                                     nos calculos e relatorios de provisoes.  
Silvia      24/05/07116535          Localizacao Provisao - Argentina           
Natie       19/06/07085125          Ajuste no teste do MV_CSALINC-nao estava  
                                    gerando corretamente qdo param.era vazio  
Jonatas     22/06/07112653          Ajuste na transferencia do saldo anterior 
                                    para o saldo de entrada nos casos de trans
                                    ferencia e rescisao no mesmo mes.         
Jonatas     25/06/07126003          Alteracao em fProvfer e fProv13o para     
                                    calculo de DSR e Horas Atividade de prof. 
Silvia      06/07/07122779          Localizacao Provisao - Paraguai            
Ademar Jr.  09/10/07120041          Tratado o parametro MV_PROVRES na Baixa do 
                                    13o.Salario por Rescisao                   
Jonatas     11/10/07121712          Ajuste em fProv13o p/ buscar faltas do mes
                                    da rescisao e trata-las nas chamadas de   
                                    fRetAfas() e fAvos13().                   
Ademar Jr.  15/10/07131958          Ajuste da funcao fMonta_TPR pra nao provi- 
                                    sionar ferias p/ meses anteriores a trans- 
                                    ferencia (Empresa Destino)                 
Jonatas     29/11/07136959          Ajuste em fQryDetSRT p/ zerar arrays das  
                                    provisoes nao calculadas a cada calculo.   
Jonatas     06/12/07136959          Ajuste em fQryDetSRT p/ testar existencia 
                                    dos arrays (ferias e 13o) antes limpa-los.
Renata E.   09/01/08131958          Ajuste na funcao Monta_TPR e fSeleTrans    
                                    na transferencia entre empresas:	         
                                    1 - Empresa Destino: Nao provisionar       
                                    ferias de meses anteriores a transferencia 
                                    2- Empresa Origem: Provisionar os meses    
                                    anteriores a transferencia, e gerar a      
                                    baixa por transf. no mes da transfer.      
     	   09/01/08138865          Ajuste em fMonta_TPR, para provisionar    
                                    ferias, baixa por trans, e baixa rescisao 
                                    nas transferencias por c.custo seguida    
                                    por demissao no mesmo mes.	            
			   09/01/08138865          Ajuste em fProv13o, para provisar baixa   
                                    por rescisao, no mes 12, qdo parametro 	
                                    MV_PROVRES estiver ativo, funcionario for 
                                    demitido no mes 12, e nao tiver pagto da  
                                    2.Parcela.								
Jonatas     07/02/08140475          Ajuste em fQryDetSRT p/ correto tratamento
                                    do RECNO em ambiente AS/400.              
Marcelo     08/02/08137771          Alteracao da Funcao LOC_DISSE para receber
                                    novo parametro p/ o calculo de dependentes
Marcelo     22/02/08137771          Alteracao da Funcao LOC_DISSE para receber
                                    novo parametro p/ ate 2.5 Sal. Minimos.   
Marcelo     26/02/08136329          Integracao com o modulo SIGAPCO.          
Renata E.   27/03/08140628          Ajuste em fQryDetSRT p/ nao calcular saldo
                                    anterior na emissao da provisao do 13.sal 
                                    quando o mes for janeiro.                 
Renata E.   11/04/08142729          Ajuste no fMonta_TPR, quando temos mais de
                                    uma transferencia no mesmo mes;           
			   	                    Documento padrao com sequencias de testes 
   		                           no servidor tecnlogia, Desenv-RH, pasta   
   		                           Evidencia de Testes.                      
Renata E.   11/04/08143697          Ajuste no fQryDetSRT, fBusDetSRT, na      
                                    paginacao dos valores do mes, baixa 13.sal
                                    e baixa rescisao, nos casos de funciona-  
                                    rios demitidos apos o pagto da 2.parcela  
                                    do 13.sal, qdo parametro MV_PROVES = S	
Renata E.   25/04/08142729          Ajuste no fQryDetSRT, fBusDetSRT, no      
                                    fMonta_TPR, de forma a atender os casos   
                                    de transferencias com e sem identificador 
                                    de baixa de transferencia e com utilizacao
                                    do parametro MV_TRFAMES. Ajuste realizado 
                                    para emissao dos relatorios e calculo     
                                    Ajuste na paginacao do saldo anterior,    
                                    caso de ferias.                           
                                    Os casos testados, estao relatados na     
                                    evidencia de teste anexado ao bops e      
			   	                    no documento salvo no servidor tecnologia 
   		                           Desenv-RH, pasta Evidencia de Testes.     
Renata E.   06/05/08145317          Ajuste em fSeleTransf na emissao dos      
                                    relatorios nos casos de transferencia de  
                                    empresas\filial e a filial destino nao    
                                    esta informada no intervalo de impressao. 
Renata      27/11/0880832008        Ajuste no calculo da media, GPEXMED, para 
                                    qdo parametro MV_PROVRES for .T., 	    
                                    lProvResc, e funcionario estiver demitido,
                                    ldemitido, enviar como referencia para    
                                    calculo a data de demissao e nao a data   
                                    informada nos parametros. 			    
                                    (mesmo teste efetuado em fAvos13)         
Renata      27/11/0800000006817/2008Ajuste no fmonta_tpr para nao duplicar 	
                                    funcionarios transferidos apos demissao   
                                    por motivo diferente de transferencia		
Jonatas     03/12/08151881          Implementacao do GRID para o calculo da   
                                    provisao.                                 
Jonatas     13/01/0900000011084/2008Alterada baixa de 13o. p/ validar apenas  
                                    o ano e nao ano/mes, pois nao baixava qdo.
                                    a 2a. parcela era paga antes de Dezembro. 
Jonatas     03/03/0900000003322/2009Incluido tratamento p/ geracao da bx. por 
                                    rescisao qdo. possui transferencia no mes 
                                    da rescisao.                              
Jonatas     10/03/0900000002972/2009Incluido tratamento p/ criacao do aTransf 
                                    a partir de tabela temporaria no processo 
                                    executado via GRID.                       
Jonatas     16/04/0900000008649/2009Ajuste p/ geracao da bx. de fer. parcial  
                                    (MV_TPBXFER=2) na existencia de duas ou   
                                    mais ferias no mes de referencia, sendo a 
                                    primeira iniciando no mes anterior.       
Marcelo     09/06/0900000011421/2009Criacao do Ponto de Entrada GP070ANT para 
                                    permitir a alteracao database de ferias e 
                                    a quantidade de dias de ferias antecipadas
Alex        03/08/09                Ajuste no Grupo de Campos filial          
                                    tratamento para no considerar 2 posies 
                                    fixas.                                    
Jonatas     18/08/0900000017773/2009Ajuste p/ geracao do saldo de provisao no 
                                    no c.custo de destino nos casos de transf.
                                    e rescisao na mesma competencia.          
Jonatas     25/08/0900000019953/2009Ajuste em fMonta_TPR() p/ verificar se    
                                    houve mudanca entre as situacoes ATUAL e  
                                    DESTINO ao efetuar skip no registro do    
                                    funcionario.                              
Tatiane V.M.25/08/0900000020388/2009Compatibilizacao dos fontes  para aumento 
                                     do campo filial e gesto corporativa.    
Renata E    02/09/0900000020302/2009Implementado tratamento para afastamento  
                                    por Adocao.							    
Allyson M   11/09/0900000022205/2009Criacao PE GP070GRV para gravar campos    
                                    criados em personalizacao				    
Jonatas     30/10/0900000024549/2009Ajuste em fMonta_TPR() p/ verificar se    
                                    houve mudanca entre as situacoes ANTERIOR 
                                    e ATUAL ao identificar transf. de entrada.
Renata      25/11/0900000025483/2009Ajuste em fBusDetSRT e fQryDetSRT para qdo
                                    variavel ltrfsld for .T. (mv_provres = N, 
                                    e demissao no mesmo mes) e nao utiliza id 
                                    de transf. fazer o mesmo tratamento das   
                                    ferias vencidas nas proporcionais, ou seja
                                    jogar saldo do mes no anterior, e zera-lo 
Renata      25/11/0900000029498/2009Ajuste em fBusDetSRT e fQryDetSRT para nao
                                    transferir saldo anterior p/saldo de trans
                                    de entrada qdo nao existir alteracao entre
                                    situacao origem, atual e destino (nao tra-
                                    tar esta situacao como transferencia)	    
Tiago Malta 07/12/0900000028570/2009Alterado o uso da variavel cEmpant para   
                                    FwCodEmp().                               
Renata Elena07/12/0900000027144/2009Tratamento de Item Contabil e Classe de   
                                    Valores no Padrao.                        
Jonatas     22/01/1000000000185/2010Ajuste para eliminar filtro do SRA antes  
                                    do calculo da provisao e restaura-lo apos 
                                    o calculo. O filtro serve apenas para o   
                                    o browse e para a emissao do relatorio.   
Renata      09/02/1000000001853/2010Incluido mes\ano na funcao fInssEmp, para 
                                    tratamento do FAP					        
Renata      09/03/1000000004461/2010Os casos ajustados eram com a utilizacao  
                                    do parametro MV_TRFAMES E MV_PROVRES:     
                                    - Ajuste no calculo da provisao do 13.Sal 
                                     no mes 12, e funcionario teve transferen-
                                     cia c.custo e demissao no mesmo mes, no  
                                     no centro de custo destino gerar o saldo 
                                     de entrada e na origem gerar a baixa por 
                                     rescisao;                                
                                    - Ajuste no calculo da provisao 13.sal,   
                                    qdo utiliza baixa da 1.parcela e func.    
                                    possui transfraferencia, no centro de     
                                    custo origem, paginar seu valor na linha  
                                    de Transf. de saida;                      
                                    - Ajuste na provisao quando tem transf.   
                                    e reativacao de matricula (funcionario    
                                    retorna para matricula de origem);        
                                    - Ajuste no fMonta_TPR, p/nao considerar  
                                    as transferencias de empresa posteriores  
                                    a data de referencia (lTransfEmp).;       
                                    - Ajuste na provisao qdo tem transferencia
                                    de empresa e no proximo mes trans. c.custo
                                    ou filial 	                            
                                    - Ajuste na provisao qdo tem transferen-  
                                    cias de centro de custos em meses seguidos
                                    retornando para o centro de custo origem. 
                                    - Na provisao do mes 12, qdo tem rescisao 
                                    apos pagto da 2.parc., paginar bx por 13. 
                                    sal, ao inves de bx por rescisao. A bx    
                                    por rescisao so paginara se tiver dif. de 
                                    13.sal pago na rescisao.			        
                                    - Nas funes fQryDetSRT() e fBusDetSRT(),
                                    na parte onde transfere o saldo anterior  
                                    para o saldo do mes, zerando o saldo ante-
                                    rior  (+- linha 3576 e +- linha 3137) ,   
                                    incluido tambm a condio de ter os id de
                                    transf. alem dos de rescisao (situacao:   
                                    possui os id de transf, TRFAMES em branco 
                                    PROVRES = N)		                        
Jonatas     26/03/1000000007132/2010Ajuste para apuracao dos avos de 13o.     
                                    considerando o parametro MV_SABDOM.       
Renata      07/04/1000000007691/2010No controle de acesso do usuario,   	    
                                    cAcessaArq, ajuste em STRTRAN p/ utilizar 
                                    SRA->RA_CC.                        	    
|Tiago Malta 01/07/1000000013914/2010Criao de variavel para armazenar a      
|                                    aliquota patronal de construo civil e     
|                                    alterao nas variaveis do Calculo Disse   
|                                    para Fonasa.                               
|Tiago Malta 03/08/1000000017629/2010Alterao da apurao do Fonasa para o      
|                                    Calculo de Proviso.                       
|Alex Fagunde10/01/1100000000171/2011Adaptacao Novas Interfaces 11.5. Controle   
|                                    MsAdvSize, para redimensionamento telas.   
|Mauricio MR 21/02/11000000041122011 Ajuste da adaptacao de Nova Interface 11.5  
Renata      19/04/1100000009009/2011Alterado funcao fwCodEmp para FWGrpCompany
                                    Ajuste na gravacao da filial De e Para    
                                    no aTransf (funcao fSeleTransf)		    
Renata      27/04/11                Ajuste na funcao fProv13o(), nos casos de 
                                    utilizar congelamento de afastamento nao  
                                    gerar saldo atual no mes 12-2010. Gerar   
                                    saldo anterior e baixa 13.sal.		    
Glaucia C.  03/06/1100000012982/2011Readequacao das telas para diversas        
Messina                             resolucoes                                 
Glaucia C.  22/08/1100000021058/2011Retirada do TnewProcess e retorno da tela  
Messina             		   TDNQWKanterior, para manter funcionalidade.      
Renata      31/08/1100000022219/2011Inclusao ponto de entrada "GP070FIM" na   
                                    funcao Gpm070Processa() no final do       
                                    processamento da provisao	           	     
Emerson     25/10/11M11.6_RH/REQ001 Alteracoes necessrias para implemntar o  
Campos                              novo relatorio de valores mensais Ferias e
                                    13o Salario e geracao dos valores mes	    
Mauricio MR 13/02/1200000001441/2012Ajuste para gerar provisao do 14 salario  
                    TEJISI          para a baixa do 13o  pelo pagamento (tem  
                                    Ids de baixa do 13o salario).				
Allyson M.  22/02/1200000002428/2012Ajuste em fQryDetSRT() p/ somente guardar 
                    TEL621          os dias de ferias proporcionais quando o  
                                    lancto. do SRT se referir ao tipo Ferias. 
Mauricio MR 26/03/1200000006409/2012Ajuste para efetivar ou nao o rateio da   
                    TEQNG4          provisao por mes, caso exista identifica- 
                    v1.             dor de rateio associado a alguma verba a- 
                    v2.Retornou     lem da existencia da tabela RHQ.          
Mauricio MR 04/04/1200000006582/2012Ajuste para gerar congelar a provisao de  
                    TERIIH          ferias quando o parametro "MV_TCONGAF" for
                                    '2' (pelo afastamento) e funcionario ter  
                                    afastamento superior a 180 dias.			
Mauricio MR 26/04/1200000009556/2012Ajuste para complementar a impressao dos  
                    TEVAWY          dias de ferias vencidos					
Allyson M   29/05/1200000013940/2012Ajuste em fEncargEmp() p/ nao gerar os 20%
                    TFBVNC          na provisao caso a empresa efetue recolhi-
                                    mento da contribuicao s/ faturamento.     
Kelly Soares22/06/1200000010656/2012Alteracoes na forma de calculo dos valores
                    TEUOTJ          do mes - Remocao da funcao fGeraProvMes;  
                                    Gpm070Processa: Nova chamada do fQryDetSRT
                                    para compor valores do mes; Nova chamada  
                                    da funcao fGeraMes para gravar valores nos
                                    novos IDs.fQryDetSRT e fBusDetSRT: Inclusa
                                    variavel de controle lSoMes para compor os
                                    valores mensais conf.passagem de parametro
Silvia Tag  23/07/12 TFLUJA         Retirada do tratamento para Rateio na     
                                    Provisao                                  
Christiane V23/08/12 TFQAE8         Incluso do Rateio na Proviso            
Mauricio MR 05/10/12 TFXJNE         Ajuste para nao ocorrer error.log no GRID 
Luis Ricardo09/10/1200000025460/2012Incluido tratamento na abertura da query	
Cinalli	   		TFXBVA 		 QSRA para impedir error.log caso o alias	
			   						 ja esteja aberto.							
R.Berti 	   16/10/12TFYDB1   		 Habilita GRID para rotinas selecionadas no
                        	 		 novo parametro MV_GPEGRID.				
Christiane V09/11/12 TFQAE8         Gravao da data base de frias no RHT    
Allyson M   26/11/12TFTYRM 		 Ajuste em fEncargEmp() p/ gerar provisao  
                    				 da contribuicao patronal de empresa mista 
                                    com base na aliquota reduzida.     		
Allyson M   30/11/12TFTYRM 		 Ajustes diversos p/ provisao do 13o. sal. 
                    				 de empresas que recolhem contribuicao pela
                                    receita bruta.     	   					
Mauricio MR 05/12/12TFREKR 		 Ajustes para identificar a situacao de a- 
                    				 fastamento do funcionario no congelamento 
                    				 da provisao quando MV_TCONGAF='2'.        
Allyson M   17/01/13TGMIRN 		 Ajuste no calculo da baixa de INSS de 13o.
                    				 salario e na logica da validacao do % da  
                                    provisao do 13o. salario.					
Ŀ
Luis Ricardo22/02/201300000002095/2013Ajuste na Transf. de Saldo Entrada quando a
Cinalli	   		  Chamado: TGCN10 provisao do Funcionario possuir Ferias a   
			   		  				   Vencer, Transferencia e Rescisao dentro do 
			   		  				   mesmo mes de calculo da provisao.		   
Allyson M   25/02/201300000002931/2013Ajuste p/ considerar o adicional de 13o.   
            		  Chamado: TGOS21 no calculo da provisao do 13o. salario.    
Allyson M   26/03/2013TGTRVV		   Ajuste p/ verificar o campo RA_INSSAUT p/  
            		                  o calculo do INSS.						   
Allyson M   09/05/2013THBVZQ		   Ajuste no calculo da provisao de 13o. com  
            		                  desoneracao, p/ nao efetuar o calculo de   
            		                  INSS proporcional quando a vigencia da     
            		                  desoneracao inicia no mes de janeiro.      
Allyson M   15/05/2013THFXSH 		   Ajuste no calculo da provisao com desonera-
            	                      cao, p/ utilizar a receita bruta com as de-
            	                      ducoes.								       
Caio C. F.  20/05/2013THF111 		  Ajuste no clculo do INSS de 13 salrio   -
            	                      sobre os adicionais, quando existe        -
            	                      Desonerao da folha de pagamento no ms   
Allyson M   21/05/2013THDUOJ 		   Ajuste p/ tratar o congelamento de provisao
            	                      p/ afastamentos que nao sejam por doenca ou
            	                      acidente.			       				   
Allyson M   03/06/2013THECVV 		   Ajuste p/ tratar a provisao do INSS de     
            	                      ferias proporcionais quando ha congelamento
            	                      da provisao e ha desoneracao da folha.     
Allyson M   05/06/2013THJGK2 		   Ajuste p/ provisao de adicionais/media de  
                      				   13o. salario quando desoneracao inicia	   
                      				   durante o ano.							   
Gustavo M   05/06/2013THHSE8 		   Ajuste para considerar o valor do encargo  
                      				   (% empresa)caso a tabela S033 esteja vazia 
                      				   (Inss 13o.). Empresa "M".				   
Allyson M   12/06/2013THGBE3 		   Ajuste p/ tratar busca dos dados de origem 
                      				   quando matricula anterior veio de empresa  
                      				   diferente.							       
Gustavo M   31/07/2013THPJBB 		   Ajuste na inicializacao das variaveis caso 
                                        utilizado o grid.                                      
Jose Cunha  24/08/2013THEVVB 		   Ajuste para quando for realizada a proviso
                      				   de decimo terceiro,no aplicar o calculo   
                      				   do INSS, quando ocorrer desonerao total. 
                      				      						                   
Gustavo M   27/08/2013THRJXL 		   Ajuste para congelar afastamento X		   
Allyson M   10/09/2013THRKDZ     	   Ajuste p/ integracao com o SIGAFAT, devido 
                                 	   criacao de novos campos na tabela TRB	   
|Gustavo M.  |19/09/2013|TGWAX7 		   |Ajuste no MV_ITMCLVL para nao obrigar	   
|            |          |                |preenchimento de ambos valores (Cont="3")  
Allyson M   30/09/2013THCGVD     	   Ajuste p/ situacao especifica de troca de  
                                 	   periodo de ferias.						   
Mariana M   07/11/2013THYVKZ      	   Ajuste para que o sistema verifique, no    
                                 	   momento da importao de saldos anteriores 
                                 	   da proviso, se h informaes na SRV,     
                                 	   atravs da SRD  						   
M. Silveira 13/11/2013THAQUC 		   Ajuste em fPercEmp() p/ aplicar a aliquota 
                      				   reduzida somente se receita nao desonerada 
                                      for menor ou igual a 95% do total geral.   
Allyson M   22/11/2013THYJAA     	   Ajuste p/ situacao especifica de troca de  
                                 	   periodo de ferias devido perda do periodo  
                                 	   devido afastamento superior a 180 dias que 
                                 	   nao zerava os dias de ferias proporcionais.
Allyson M   05/12/2013THZSGS     	   Ajuste p/ tratar baixa de transferencia por
                                 	   item contabil e classe de valor.  		   
Gustavo M   16/01/2014TIFMR5     	   Ajuste na verificacao de transferencias.   
Gustavo M   27/01/2014TIGPWW     	   Ajuste na declaracao da variavel lItmClVL. 
Allyson M   30/01/2014TIGVRV     	   Ajuste em fChkRHQBase() na verificacao do  
                                 	   cadastro dos Id's de rateio.  		   	   
Allyson M   27/03/2014TIKBXV     	   Ajuste p/ situacao especifica de troca de  
                                 	   periodo de ferias devido perda do periodo  
                                 	   devido afastamento superior a 180 dias que 
                                 	   nao zerava os dias de ferias proporcionais 
                                 	   e havia dias de ferias vencidas.		   
Allyson M   07/04/2014TIHNY6     	   Ajuste p/ tratar nova opcao opcao de       
                                 	   preenchimento do campo X14_RECFAT.		   
Claudinei S.22/05/2014TPKDHR     	   Ajuste na query da fQryDetSRT() removendo  
                                 	   o excesso de aspas nos campos RHT_ITEM e   
                                 	   RHT_CLVL.                                  
Allyson M   16/06/2014TPUJTI     	   Ajuste na impressao do relatorio de rateio 
                                 	   de provisao.		                  	   
Allyson M   18/06/2014TPUO29     	   Ajustes diversos referente congelamento. O 
                                 	   conceito do congelamento e' restrito p/ o  
                                 	   periodo aquisitivo e nao deve ocorrer p/ o 
                                 	   dias proporcionais.                        
Allyson M   18/06/2014TPUJTI     	   Ajuste na validacao de uso de item/classe  
                                 	   para rateio de provisao.               	   
Allyson M   30/06/2014TPVDSI	       Ajuste p/ ordenacao por CC, Item e Classe  
Allyson M   01/07/2014TPVAT0     	   Ajuste na validacao da configuracao dos    
                                 	   parametros MV_PFCALAC e MV_PFCALAD.    	   
Allyson M   25/07/2014TQAOHI    	   Ajustes p/ gravar o calculo com movimento  
                                 	   de congelamento quando ha situacao do      
                                 	   congelamento do periodo aquisitivo. 	   
Gustavo M   01/08/2014TQEXY4	       Ajuste para impressao de saldo anterior e  
			   		  				   atual no relatorio por movimento.		   
Gustavo M   08/08/2014TQGYH5	       Ajuste para nao desprezar centro de custo  
			   		  				   na impressao do relatorio com rateio.      
Allyson M   27/08/2014TI2013   	   Ajustes no calculo de provisao de ferias de
                                 	   funcionario afastado por tipo X.		   
Allyson M   01/09/2014TQFW60   	   Ajuste p/ calculo de provisao de ferias de 
                                 	   funcionario transferido e afastado tipo 1. 
Allyson M   09/09/2014TQGNVV   	   Ajuste na msg exibida quando calculo e'    
                                 	   para mes que ja foi fechado. 			   
Allyson M   11/09/2014TQMHN8   	   Ajuste p/ calculo em competencia anterior a
                                 	   transferencia p/ considerar o afastamento e
                                 	   situacao folha da competencia selecionada. 
Allyson M   12/09/2014TQMXQU   	   Ajuste na verificacao dos dados da transf. 
                                 	   anterior com os dados da atual.			   
M. Silveira 22/10/2014TQSAA6          Disponibilizacao dos IDS para o calculo de 
			    		                  de provisao e Baixa de Ferias do Paraguai. 
Allyson M   24/10/2014TQJXPQ   	   Ajuste na validacao de transferencia de    
                                 	   funcionario demitido.			   		   
Allyson M   27/11/2014TQWS66   	   Ajuste p/ sempre calcular provisao quando  
                                 	   funcionario afastado pelos motivos que nao 
                                 	   sao tratados ao inves de buscar os dados do
                                 	   mes anterior.							   
M. Silveira 15/12/2014TRBWZ5          Ajuste p/ nao arredondar as horas de faltas
			    		                  p/ nao reduzir o total dos dias de faltas. 
Allyson M   17/12/2014TRFWRT   	   Ajuste no calculo da provisao do 13o. p/   
                                 	   sempre veriricar os avos de afastamento.   
Allyson M   18/12/2014TRGGS2   	   Ajuste no calculo das ferias proporcionais 
                                 	   em situacao que houve perda do periodo e   
                                 	   funcionario retornou do afastamento.   	   
Allyson M   18/12/2014TRFLQ2   	   Ajuste na montagem do temporario TPR p/    
                                 	   validar corretamente o item e classe da    
                                 	   competencia de calculo.   	  			   
Allyson M   08/01/2015TRJAIW   	   Ajuste na montagem do temporario TPR p/    
                                 	   validar a utilizacao de item/classe.       
Renan Borges28/01/2015TRJSZ9  	       Ajuste p/ carregar filiais da empresa cor- 
                                 	   rente sem desposicionar de empresa e assim 
                                 	   o tamanho do cFilAnt continua igual ao da  
                                 	   empresa logada, pois quando posicionava em 
                                 	   uma empresa cujo tamanho da filial fosse di-
                                 	   ferente da empresa corrente, o cFilAnt tinha
                                 	   seu tamanho alterado.                       
Allyson M   03/02/2015TRKP52   	   Ajuste no calculo de INSS da provisao de 13
                                 	   quando ha diferenca de 13o na Folha.       
Allyson M   24/02/2015TRQ023   	   Ajuste no calculo de INSS da provisao de 13
                                 	   quando ha diferenca de 13o na Folha e deso-
                                 	   neracao teve inicio durante o ano.		     
Marcia M.   08/04/2015TSBSZV          Leitura de Mnemonicos para MP 664 a fim de 
                                      melhorar a performance                      
Allyson M   17/04/2015TSCB31     	   Ajustes diversos referente congelamento. O 
                                 	   conceito do congelamento e' restrito p/ o  
                                 	   periodo aquisitivo e nao deve ocorrer p/ o 
                                 	   dias proporcionais.                        
Renan Borges05/05/2015TSFJTA          Ajuste calcular proviso de 13 salrio do 
                                      ms 12, que j foi fechado, corretamente.   
Allyson M   05/05/2015TSGSO8     	   -Ajuste p/ zerar os dias de ferias vencidas
                                 	   no cabecalho quando nao tem dias vencidas. 
                                 	   -Ajuste para considerar os afastamentos W e
                                 	   1 p/ 13o. quando MV_ABATAFA = S.           
Claudinei S.06/05/2015TRGETT   	   Ajustada a provisao do 13o salario para    
                                 	   quando a empresa deixou de ser desonerada. 
M. Silveira 14/05/2015TSHLFH 		   Ajuste em fPercEmp() p/ corrigir os campos 
                      				   da tabela S033 usados na apuracao da aliq. 
Allyson M   21/05/2015TSIHXT   	   Ajuste no congelamento de dias de ferias de
                                 	   tipos de afastamentos nao tratados para    
                                 	   verificar se ha dias do calculo anterior.  
Allyson M   21/05/2015TSEPN5   	   Ajuste no congelamento quando MV_TCONGAF=2 
                                 	   em situacao em que o afastamento ocorre    
                                 	   entre dois periodos.  					   
                      TSJEUT   	   Ajuste no calculo da baixa da provisao de  
                                 	   13o. quando mes 12 ja foi fechado e ha dif.
                                 	   de 13o. no movimento.  					   
M. Silveira 25/05/2015TRXYI6 		   Ajuste na fGrvArrPrv() para arredondar o   
                      				   valor de baixa na rescisao, para nao gerar 
                      				   divergencia entre os valores provisionados.
Allyson M   26/05/2015TSLTN9   	   Ajuste no congelamento de dias de ferias de
                                 	   tipos de afastamentos nao tratados para    
                                 	   pegar os dias do calculo anterior.  	   
Claudinei S.04/06/2015TRGETT   	   Ajustada a provisao do 13o salario e ferias
                                 	   quando a empresa deixou de ser desonerada. 
ٱ

*/


Function GPEM070()
Local aSays      	:= {}
Local aButtons   	:= {}
Local aParametros	:= Array(16)
Local nOpca      	:= 0
Local nSvRcSRA		:= SRA->( Recno() )
Local cTextoProv 	:= ""
Local cSRAFilter	:= SRA->( dbFilter() )
Local lRetPE		:= .F.
Local cDescricao
Local cCadastro
Local cGPEGrid		:= ""

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}


Private lAbortPrint := .F.
Private aLogFile 	:= {}
Private aLogTitle 	:= {}
Private aIdProvis   := {}
Private lDissidio	:= .F.
Private lFechouMes
Private lItemClVl   := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13"
Private nFec131   	:= 0                                         
Private nVerFatFin 	:= 0

/*

							PROCESSAMENTO EM GRID
--> Quando declarar variaveis PRIVATES nas Funcoes ate o Nivel Gpm070Processa e 
necessitar utiliza-los no roteiro de calculo, devera enviar no array aPARAMB  e 
redeclarar na Preparacao do Ambiente com a funcao _SetOwnerPrvt. 
--> Para as variaveis PRIVATES declaradas para o funcionario, enviar atraves  do ar-
ray aCall e redeclarar na GPM070GRD. 
---> Vide Exemplos de ambas as situacoes
*/

// Tratar GRID Somente para TOP Connect //
Private lGrid		:= SuperGetMv("MV_GRID",, .F.)// Se o parametro esta configurado para utilizacao do GRID

DEFAULT lGpa070mn	:= ExistBlock( "GPA070MN" ) 
DEFAULT lGp070Fim 	:= ExistBlock("GP070FIM")

#IFNDEF TOP
	lGrid	:= .F.
#ENDIF

If lGrid
	// Habilita GRID para rotinas selecionadas em MV_GPEGRID (1=Provisao 2=Calculo Folha/13o. em branco=Todas)
	cGPEGrid := SuperGetMv("MV_GPEGRID",, " ")
	lGrid	 := If( Empty(cGPEGrid) .Or. "1"$cGPEGrid, .T., .F. )
EndIf

//Ŀ
// Ponto de entrada para substituir   						   
//
If ( lGpa070mn )
	Execblock("GPA070MN",.F.,.F.)
	Return(Nil)
Endif
           
//--Seta e Carrega os Mnemonicos.
SetMnemonicos(xFilial("RCA"),NIL,.T.,"dDtaXINSS") 
SetMnemonicos(xFilial("RCA"),NIL,.T.,"nDaXINSS") 
SetMnemonicos(xFilial("RCA"),NIL,.T.,"lAXINSS") 

//Ŀ
// Define o titulo do LOG de Ocorrencias                      
//
aLogTitle := { STR0011 } //"PROVISAO DE FERIAS/13o SALARIO"

//Ŀ
// Converte os valores do arquivo SRF para o SRT			   |
//
dbSelectArea( "SRT" )
dbGoTop()
If SRT->( Eof() )
	dbSelectArea( "SRF" )
	dbGoTop()
	If !Eof()
		GPEProvisao(STR0001,,,,5) // "Importacao do saldo anterior"
		//Ŀ
		// Apresenta Tela com Log de erros								 
		//
		fMakeLog( aLogFile, aLogTitle,, .T. )
		If lAbortPrint
			Return
		EndIf
	EndIf
EndIf

cCadastro := OemToAnsi(STR0002) // "Calculo das Provisoes de Ferias e 13 Salario"

Pergunte("GPM070",.F.)

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize(,.T.,280)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )


DEFINE FONT oFont NAME "Arial" SIZE 7,-11 BOLD
DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] PIXEL
	@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3], aObjSize[1,4] LABEL OemToAnsi("") OF oDlg PIXEL
	oGroup:oFont:= oFont
	@ aObjSize[1,1]+15	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0003) Size  500,008 OF oDlg PIXEL FONT oFont
	@aObjSize[1,1]+25	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0004) Size  500,008 OF oDlg PIXEL FONT oFont
	@aObjSize[1,1]+35	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0005) Size  500,008 OF oDlg PIXEL FONT oFont
	@aObjSize[1,1]+45	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0006) Size  500,008 OF oDlg PIXEL FONT oFont

	bParam := {|| Pergunte("GPM070",.T. ) }
	AAdd(aButtons, {"Parametros", bParam 				, "Parametros"	, "Parametros" }  )	//"Parametros"

	bSet15	:= {|o| nOpca := 1,If(GPM070OK(),oDlg:End(),nOpca:=0)}
	bSet24	:= {|o| oDlg:End() }
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons )  CENTERED

//Ŀ
// Carregando variaveis mv_par?? para Variaveis do Sistema.	 
//
aParametros[01]	:=	lFerias     := (mv_par01==1.Or.mv_par01==3)		//  Tipo de Provisao 1 - Ferias 2 - 13  3 - Ambas
aParametros[02]	:=	l13oSal     := Iif(cPaisLoc <> "CHI",(mv_par01==2.Or.mv_par01==3),.F.)		//  Tipo de Provisao 1 - Ferias 2 - 13  3 - Ambas
aParametros[03]	:=	dDataRef   	:= mv_par02							    //  Data de Referencia para Calculo
aParametros[04]	:=	nOrdem  	:= mv_par03								//  Ordem de Calculo 1 - Matricula  2 - Centro de Custo
aParametros[05]	:=	cFilDe	   	:= mv_par04								//	Filial De
aParametros[06]	:=	cFilAte    	:= mv_par05								//	Filial Ate
aParametros[07]	:=	cCcDe	   	:= mv_par06								//	Centro de Custo De
aParametros[08]	:=	cCcAte	   	:= mv_par07								//	Centro de Custo Ate
aParametros[09]	:=	cMatDe	   	:= mv_par08								//	Matricula De
aParametros[10]	:=	cMatAte     := mv_par09								//	Matricula Ate
aParametros[11]	:=	nCorrecao   := (mv_par10 / 100)					    //	Indice de Correcao
aParametros[12]	:=	lDesc1parc  := If(mv_par11 == 1,.T.,.F.)          //  Desc. 1a Parc. 13
aParametros[13]	:=	lIncluiDem  := If(mv_par12 == 1 .Or. lFerias,.T.,.F.) //  Incluir Demit. 13
aParametros[14]	:=	n14Salario  := (mv_par13 / 100)                    //  Indice de 14 Sal.
aParametros[15]	:=	cCateg	    := mv_par14								//	Categorias
aParametros[16]	:=	nVerFatFin  := mv_par15 			    			//  Vericar Faturamento-Financeiro (1-Nao; 2-Faturamento; 3-Financeiro; 4-Ambos)

//Ŀ
//| Define se o texto da provisao sera de ferias, 13 ou ambos	 |
//
cMesAnoProv := StrZero(Month(dDataRef),2)+StrZero(Year(dDataRef),4)
cTextoProv  := If(lFerias .And. l13oSal, STR0011, If(lFerias, STR0009, STR0010)) + " -  " + Transform(cMesAnoProv,"@R 99/9999") //"PROVISO DE FERIAS "##"PROVISO DE 13o SALARIO"##"PROVISO DE FERIAS/13o SALARIO"

If nOpca == 1
	//Ŀ
	// Verifica se esta calculando provisao com mes fechado.      
	//
	If ( lFechouMes := ( GetMv( "MV_FOLMES",,"") > MesAno(dDataRef) ) )
		 cMens := OemToAnsi(STR0007) + Transform(cMesAnoProv,"@R 99/9999") + OemToAnsi(STR0102)+ "." + chr(13)  //"A competencia "##" ja foi fechada."
	 	 cMens += OemToAnsi(STR0008) + chr(13)      							     		//"Deseja continuar?"
		 If !MsgYesNo(cMens,OemToAnsi(STR0012))   								    	//"ATENCAO"
		    Return
		 Endif
	EndIf

	//Ŀ
	// Elimina filtro do SRA antes do calculo                     
	//
	dbSelectArea( "SRA" )
	Set Filter To
	
	//Ŀ
	// Carrega variaveis privates comuns a GPEA070,GPER070 e GPEM070|
	//
	GPEProvisao(cTextoProv,,,,4,aParametros)
EndIf

//Ŀ
// Restaura filtro do SRA apos o calculo                      
//
dbSelectArea( "SRA" )
Set Filter To &( cSRAFilter )
dbGoTo( nSvRcSRA )

Return

/*


Ŀ
Funao	  GP070Proc Autor  R.H.					 Data  26.06.00 
Ĵ
Descriao  Provisao de Ferias										  
Ĵ
Sintaxe	  GPM070Processa()										      
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function GPM070Processa(aPar)

//Ŀ
// Variaveis Locais - PROVISAO DE FERIAS 						 
//
Local cCongAci		:= GetMv( "MV_PFCALAC" ) // Indica se congela por Afast. Acidente 
Local cCongDoe		:= GetMv( "MV_PFCALAD" ) // Indica se congela por Afast. Doenca

//Ŀ
// Variaveis Locais - PROVISAO DE 13 SALARIO					 
//
Local cAbatAci	    := GetMv( "MV_PDCALAC" )            // Indica se abate avos por Afast. Acidente
Local cAbatAdo	    := SuperGetMv("MV_PDCADOC",, "N")  // Indica se abate avos por Afast. Adocao
Local cAbatDoe      := GetMv( "MV_PDCALAD" )           // Indica se abate avos por Afast. Doenca
Local cArqBxa13,cFilBxa13,cMatBxa13,cDatBxa13,cPdBxa13,cValBxa13

//Ŀ
// Variaveis Locais - PROVISAO DE FERIAS E 13 SALARIO	  |
//
Local aAreaSRA     := SRA->(GetArea())
Local nTipoMovMes  := 0
Local nPercFgC     := 0
Local aCabProv     := {}
Local cTPRDbf,cTPRNtx
Local cArqDbf,cArqNtx
Local cNomeCpo,cArqBxaPr,cFilBxaPr,cMatBxaPr,cDatBxaPr,cPdBxaPr,cSeqBxaPr,cValBxaPr,cHrsBxaPr
Local lTemCab		:= .F.
Local dDtCalIni		:= Dtoc( MsDate() )

//Ŀ
// Variaveis Locais - GRID               						 
//
Local aCall			:= {}
Local nLoteGrid 	:= SuperGetMv("MV_REGGRID",,20)
Local nCountReg		:= 0
Local nRegGrid  	:= 0
Local nTrf			:= 0
Local nEleTrf		:= 0
Local cDtHrProc
Local cMsgLog           
Local dRefMed		:= dDataRef // Data Referencia para calculo da media 
Local aTabBPC       := {} // Tabela BPC
Local nValBpc       := 0  // Valor BPC
Local lDepen        := .F.

//Ŀ
// Variaveis Private - PROVISAO DE FERIAS 						 
//
Private aFerVenc     := Array(_Linhas,_Colunas)
Private aFerProp     := Array(_Linhas,_Colunas)
Private aRecVenc     := Array(_Linhas,_Colunas)
Private aRecProp     := Array(_Linhas,_Colunas)
Private aTabFer      := {} 	// Tabela para calculo dos dias de ferias
Private nV_DFalFer   := 0
Private nP_DFalFer   := 0
Private nTFaltaV   	 := 0
Private nTFaltaP	 := 0
Private nDFerAnt     := 0
Private nPerc1T      := 0
Private cCodFer	  	 := cCodAdFer   := cCodUmTer  := cCodFerMs := ""
Private cCodAdicMs   := cCodUmTerMs := cCodAbono  := cCodAboMs := ""
Private cCodSalV     := cCodSalVMs := ""
Private dDtBasFer    := CTOD("")
Private cTAfaFer     := GetMv( "MV_TAFAFER" )				//-- Trata Perda de Periodo Para Afastados
Private cTpBxFer     := GetMv( "MV_TPBXFER",, "1" )			//-- Baixa Ferias Total ou Mes e Mes Seguinte
Private cTpCongAf    := GetMv( "MV_TCONGAF",, "1" )			//-- Trata congelamento por periodo Aquisitivo ou Por afastamento
Private cTrfAMES     := ( GetMv( "MV_TRFAMES",, Space(6) ) ) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
Private lTrfAMES     := ( !Empty(cTrfAMES) .And. MesAno( dDataRef ) >= cTrfAMES )

//Ŀ
// Variaveis Private - PROVISAO DE 13 SALARIO					 
//
Private a13Salar     := Array(_Linhas,_Colunas)
Private a14Salar     := Array(_Linhas,_Colunas)
Private aRec13Sl     := Array(_Linhas,_Colunas)
Private aRec14Sl     := Array(_Linhas,_Colunas)
Private cAbatAfas    := GetMv( "MV_ABATAFA" )			// Indica se abate avos por Afast. no 13 Salario
Private cPgSalMat    := GetMv( "MV_PGSALMA" )			// Abater Afastamento Auxilio Maternidade no 13
Private lDif13Neg    := ( GetMv( "MV_DF13NEG",,"S")=="S" ) // Gerar diferenca de 13o. negativa S/N
Private cCod13o	  	 := cCodAd13o := ""
Private cInss13o	 := ""
Private lBx13Pgt     := .F.								    //-- Baixa 13o Salario pelo pagamento
Private lDesAtiv     := .F.
Private lOneAtiv	 := .F.
Private nAvosAnt     := 0
Private nPercAnt     := 0

//Ŀ
// Variaveis Private - PROVISAO DE FERIAS E 13 SALARIO  |
//
Private nSalario	 := nSalMes  := nSalDia     := nSalHora  := 0
Private nPercEmp	 := nPercTer := nPercAcTrab := nPercFgts := 0
Private nPerEmp13	 := 0
Private nPercPis	 := 0
Private aInfo	     := {}
Private aVerba       := {}
Private aTransf      := {}
Private aGPSPer      := {}
Private lDemitido    := .F.
Private lINSSAut   	 := .F.
Private lTransfSai   := .F.
Private lSalInc    	 := .F.
Private lTrataTrf    := .F.
Private c__Roteiro   := "   "
Private cOneFol		 := SuperGetMv( "MV_FDESFOL",,"" )	//-- Ano/Mes do final da desoneracao
Private cAnoMes		 := AnoMes( dDataRef )
Private cPerFeAc     := GetMv( "MV_FERPAC",,"N" )  				//-- Usada na Funcao FCalcFimAq-(GpexMed).
Private lProvResc    := ( GetMv( "MV_PROVRES",,"N" ) == "S" ) 	//-- Indica se devera provisionar no mes da rescisao
Private cAfastProv   := "O*P*Q*R*V*W*X*8*B" 				    	//-- Afastamentos tratados pela provisao	//?-
Private aInssEmp[23][2]
Private cCalcSalInc  := SuperGetMv("MV_CSALINC",,Space(6))		//-- Ano/Mes para inicio da busca dos salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
Private lCalcSalInc  := If( Empty(cCalcSalInc) ,.T. , cCalcSalInc > MesAno( dDataRef )   ) 
Private Val_SalMin   := 0.00
Private lTrfSld		 := .F.
Private dDataDem1	 := Ctod("//")
Private lSabDom		:= If(GetMv("MV_SABDOM")=="S", .T., .F.) //Se pagara o sab e domingo qdo demissao na sexta

//Ŀ
// Variaveis Para Funcao fSalInc    						     
//
Private aCodFol  	:= {}
Private aRoteiro 	:= {} 
Private nAdtServ 	:= nPeric	:= nInsal := 0.00	  // Valores dos Adicionais
Private cCodAdt  	:= cCodIns  := Space(3) 		  // Codigos que Foram Gerados
Private nSalMin  	:= 0

//Ŀ
// Variaveis utilizadas na funcao fMonta_TPR()                
//
Private cNomeDe  := Replic("A", 30)
Private cNomeAte := Replic("Z", 30)

If cPaisLoc == "URU"
	Private lProvUru	:= .T.
	Private cSemana		:= "01"
	Private nCSocial	:= 0
	Private nAliqBse	:= 0
	Private nBseFixo	:= 0
	Private cApolice	:= " "
  	Private lPagFerSe	:= GetNewPar('MV_PGFERSE',.T.) // O pagamento das Ferias deve ser separado da Folha de Pag.
	Private nBPSFunc	:= 0
	Private nBPSConsC   := 0
	Private nFRLFunc	:= 0
	Private nFonasFunc	:= 0
	Private nFonasDep	:= 0
	Private nFonasSM	:= 0
	Private nFonasSDep  := 0   
	Private nSomaPerc	:= 0
	Private nTpDesc		:= nFonasFunc   
ElseIf cPaisLoc == "ARG"	
	Private aObraSoc	:= {}
	Private aJubila		:= {}
	Private aLey		:= {}
Endif

//Ŀ
// Quando vier de outro local diferente do Calculo de Provisao  
// nao devera utilizar o GRID.			                         
//
If Type("lGrid") == "U"
	Private lGrid	:= .F.
EndIf

Private nTimeIni	:= nTimeFim		:=	Seconds()	// Tempo de calculo para o GRID

Private cRecFatEmp	:= ""
If cPaisLoc <> "BRA"
	nFec131 := GetNewPar("MV_MESP131",06)
Endif
//Ŀ
// Variaveis utilizadas para baixa de ferias e de rescisao nas|
// provisoes de ferias e de 13o Salario (SRC ou SRD).         |
//
cArqBxaPr := "SRC"
cNomeCpo  := "SRC->RC_"
cDatBxaPr := &( "{ || MesAno(dDataRef) }" )
If lFechouMes
	cNomeCpo  := "SRD->RD_"
	cArqBxaPr := "SRD"
	cDatBxaPr := &( "{ || " + cNomeCpo + "DATARQ }" )
EndIf
cFilBxaPr := &( "{ || " + cNomeCpo + "FILIAL }" )
cMatBxaPr := &( "{ || " + cNomeCpo + "MAT }"    )
cPdBxaPr  := &( "{ || " + cNomeCpo + "PD }"     )
cSeqBxaPr := &( "{ || " + cNomeCpo + "SEQ }"    )
cValBxaPr := &( "{ || " + cNomeCpo + "VALOR }"  )
cHrsBxaPr := &( "{ || " + cNomeCpo + "HORAS }"  )

//Ŀ
// Variaveis utilizadas para baixa de 13o Salario (SRI ou SRD)|
//
If l13oSal
	cArqBxa13 := "SRI"
	cNomeCpo  := "SRI->RI_"
	cDatBxa13 := &( "{ || Strzero(Year(SRI->RI_DATA),4) }" )
	If lFechouMes
		cNomeCpo  := "SRD->RD_"
		cArqBxa13 := "SRD"
		cDatBxa13 := &( "{ || " + cNomeCpo + "DATARQ }" )
	EndIf
	cFilBxa13 := &( "{ || " + cNomeCpo + "FILIAL }" )
	cMatBxa13 := &( "{ || " + cNomeCpo + "MAT }"    )
	cPdBxa13  := &( "{ || " + cNomeCpo + "PD }"     )
	cValBxa13 := &( "{ || " + cNomeCpo + "VALOR }"  )
EndIf

//Ŀ
// Busca o percentual da contribuicao do FGTS (apos 01/10/2001
//
nPercFgC := 0
If MesAno(dDataRef) >= "200110" .And. MesAno(dDataRef) <= "200612"
	nPercFgC := GetMv("MV_PERCFGC",, 0) / 100  //Contribuicao do FGTS
EndIf

If !lGrid
	//Ŀ
	//| Cria Arquivo de Medias Temporario						   |
	//
	Cria_TRP(@cArqDbf,@cArqNtx)
EndIf

//Ŀ
// Monta o arquivo temporario "TPR" a partir do SRA e SRE     |
//
fMonta_TPR(@cTPRDbf,@cTPRNtx,nOrdem,dDataRef,@lSalInc,@lTrataTrf,@aTransf,lIncluiDem)
dbSelectArea("TPR")

//Ŀ
//Arquivo para Controle de LOG - Transacao						 
//
#IFDEF TOP
	If lGrid
		Private cNameFile   := "M070"+FWGrpCompany("SRC")				// Tabela temporaria de log
		Private cFileTrf	:= Subst(CriaTrab(NIL,.f.),1,7) + "T"	// Tabela temporaria de transferencias
		Private cDbfLog 	:= "M070LOG"							// Alias de log
		Private cTrfDbf		:= "M070TBL"							// Alias de transferencia
		Private cChaveLog	:= DTOC(MsDate()) + "-" + Time()
		Private nTamTrf		:= Len( aTransf )						// No. de elementos total de aTransf

		If !fBldLogGRD(@cDbfLog)
			 Aviso( STR0015, STR0027, { STR0016 } ) // "Atencao" ## "Nao foi possivel abrir o arquivo de registro de ocorrencias." ## "Ok"
			 Return( .F. )
		EndIf

		IF Select( cDbfLog ) > 0
			DbSelectArea( cDbfLog )
			If !Eof()
				cDtHrProc := AllTrim(Substr( (cDbfLog)->CHAVE, 1)) + " " + OemToAnsi(STR0028) // "Horas"
				cMsgLog := OemToAnsi(STR0029) + " " + cDtHrProc + " " + OemToAnsi(STR0030) + CRLF // "O processamento realizado em:" ## "no foi concludo com Sucesso."
				cMsgLog += OemToAnsi(STR0031) + CRLF + CRLF // "Os ltimos funcionrios processados foram: "
	
				cMsgLog += Substr(OemToAnsi(STR0032)	+ Space(5),1,16) // "Requisicao"
				cMsgLog += Substr(OemToAnsi(STR0033)	+ Space(5),1,12) // "Filial"
				cMsgLog += Substr(OemToAnsi(STR0034)	+ Space(5),1,15) // "Matricula"
				cMsgLog += OemToAnsi(STR0035)	+ CRLF // "Nome"
				cMsgLog += Replicate( "-", 75 ) + CRLF 
				While (cDbfLog)->(!Eof())
					If (cDbfLog)->CONTROL = '1'
						cMsgLog += (cDbfLog)->REQUIS + Space(8)
						If !Empty((cDbfLog)->MAT)
							cMsgLog += (cDbfLog)->FILIAL + Space(10)
							cMsgLog += (cDbfLog)->MAT + Space(9)
							cMsgLog += Substr((cDbfLog)->NOME,1,36) + CRLF
						Else
							cMsgLog += OemToAnsi(STR0036) + CRLF //"Nenhum Funcionrio Processado nessa Requisio"
						EndIf
					EndIf
					(cDbfLog)->( Dbskip() )
				EndDo
				cMsgLog += CRLF + CRLF + OemToAnsi(STR0037) //"Deseja Continuar com o Calculo?"
				If MsgYesNo(cMsgLog, OemToAnsi(STR0015) )			
					cQuery := " DELETE FROM "
					cQuery += " "+ cNameFile
					TcSqlExec( cQuery )
				Else
				 	Return
				EndIf
			EndIf
		EndIf
		
		//Ŀ
		// Criacao da tabela tempoararia para armazenamento do array  
		// aTransf. Isso faz-se necessario devido a grande quantidade 
		// de informacoes que esse array pode conter e que assim nao  
		// ha como passa-lo via aParAmb na preparacao do GRID, pois   
		// pode estourar o limite maximo de tamanho de 1MB da string  
		// enviada via RPC para preparacao do ambiente.               
		//		
		If !CriaTransf()
			 Aviso( STR0015, STR0063, { STR0016 } ) // "Atencao" ## "No foi possvel abrir a tabela temporria de transferncias." ## "Ok"
			 Return( .F. )
		EndIf

		IF Select( cTrfDbf ) > 0
			DbSelectArea( cTrfDbf )
			
			For nTrf := 1 To nTamTrf
				For nEleTrf := 1 To 3
					Reclock( ( cTrfDbf ), .T. )
					
					( cTrfDbf )->TRFPOS		:= nTrf	// Posicao no aTransf original
					( cTrfDbf )->TRFELE		:= nEleTrf	// Posicao no aTransf original
					( cTrfDbf )->TRFEMPP	:= aTransf[ nTrf, nEleTrf, 1 ]
					( cTrfDbf )->TRFFILIALP	:= aTransf[ nTrf, nEleTrf, 2 ]
					( cTrfDbf )->TRFCCP		:= aTransf[ nTrf, nEleTrf, 3 ]
					( cTrfDbf )->TRFMATP	:= aTransf[ nTrf, nEleTrf, 4 ]
					( cTrfDbf )->TRFDATE	:= aTransf[ nTrf, nEleTrf, 5 ]
					( cTrfDbf )->TRFNLIDO	:= aTransf[ nTrf, nEleTrf, 6 ]
					
					( cTrfDbf )->( MsUnlock() )
				Next nEleTrf
			Next nTrf
		EndIf
	EndIf
#ENDIF

//Ŀ
// Garante Ordem 1 Para Busca dos Lancamentos no Movimento	   
//
dbSelectArea( "SRC" )
dbSetOrder(1)

//Ŀ
// Garante Ordem 1 Para Busca dos Funcionarios				   
//
dbSelectArea( "SRA" )
dbSetOrder(1)

//Ŀ
// Posiciona no inicio do arquivo						  	   
//
dbSelectArea( "TPR" )
dbGoTop()

If !lGrid
	//Ŀ
	// Carrega regua de processamento							   
	//
	ProcRegua(RecCount())
EndIf

cFilialAnt := Replicate("!", FWGETTAMFILIAL)
cCcAnt	   := "!!!!!!!!!"

While TPR->(!Eof())

	If lAbortPrint
		Exit
	Endif
	
	If lGrid
		If nCountReg == 0 .Or. nCountReg >= nLoteGrid
			Aadd(aCall, {} )
			MsProcTxt( OemToAnsi(STR0044) + " " + Strzero(Len(aCall),6) ) // "Numero de Requisies Geradas: "
			nRegGrid++
			nCountReg := 0
		EndIf
		nCountReg++
		Aadd(aCall[nRegGrid], {nRegGrid, TPR->PR_FILIAL, TPR->PR_MAT, TPR->PR_CC, TPR->PR_TIPMOVI } )
	Else

		//Ŀ
		// Apresenta o Funcionario que esta sendo calculado			 
		//
		IncProc(TPR->PR_FILIAL+" - "+TPR->PR_MAT+" - "+TPR->PR_NOME)

		//Ŀ
		// Inicializa a gravacao dos lancamentos do SIGAPCO        
		//
		PcoIniLan("000091")        
		
		//Ŀ
		// Garante o Posicionamento do Funcionario no SRA				 
		//
		dbSelectArea( "SRA" )
		dbSeek( TPR->PR_FILIAL + TPR->PR_MAT )
		dbSelectArea( "TPR" )
		
		//Ŀ
		// Quebra filial para buscar as tabelas						 
		//
		If TPR->PR_FILIAL # cFilialAnt
			If !Fp_CodFol(@aCodFol,TPR->PR_FILIAL)		 .Or.;
			   !fInfo(@aInfo,TPR->PR_FILIAL)			 .Or.;
	           !fInssEmp(TPR->PR_FILIAL,@aInssEmp,.F.,MesAno(dDataRef))
				Exit
			Endif


			//Ŀ
			// Validacao da aplicacao do update referente criacao de perguntas			
			//
			If aInssEmp[27, 1] $ "S*M" .And. !fVerPerg()
				Aviso( STR0076, STR0077, {STR0016} ) //"Alerta"##"Execute a opo do compatibilizador referente a Criao do Perguntas para Clculo da Desonerao da Folha - Proviso. Para maiores informaes, verifique respectivo Boletim Tcnico."##"Ok"			
				Exit
			EndIf

			//Ŀ
			// Resgata os percentuais de terceiros armazenados no parametro 15			
			//	
			fGPSVal(TPR->PR_FILIAL,"999999",@aGPSPer,"1")
	
			//Ŀ
			// Limpa array de identificadores utilizados na cadastrados	 
			//
			aIdProvis := {}
	
			//Ŀ
			// Carrega Codigos de Ferias/13o Salario Para Baixa da Provisao 
			//
			fBusCodBx()
	
			//Ŀ
			// Carrega os identificadores da Provisao						 
			//
			fIdentProv(@aVerba,aCodFol)
	
			//Ŀ
			// Verifica a existencia dos identificadores da provisao		 
			//
			fChkIdent(aVerba,_FerVenc,{_Atual,_BxFer,_BxTrf},.T.)
			fChkIdent(aVerba,_13Salar,{_Atual,_BxTrf},.T.)

			//Ŀ
			// Verifica a existencia dos identificadores da provisao Mes	 
			//
			If lGeraPMes
				fChkIdent(aVerba,_FerVMes,{_Atual},.T.)
				fChkIdent(aVerba,_13SVMes,{_Atual},.T.)
			Endif
			
			//Ŀ
			// Verifica a existencia dos identificadores de baixa de 13o.	 
			//
			lBx13Pgt := fChkIdent(aVerba,_13Salar,{_Bx13o},.T.)
	
			//Ŀ
			// Verifica a existencia dos identificadores de correcao        
			//
			If nCorrecao > 0
				fChkIdent(aVerba,_FerVenc,{_Corre},.T.)
				fChkIdent(aVerba,_13Salar,{_Corre},.T.)
			EndIf
	
			//Ŀ
			// Verifica a existencia dos identificadores da provisao 14 Sal 
			//
			If n14Salario > 0
				fChkIdent(aVerba,_14Salar,{_Atual},.T.)
			EndIf
	
			//Ŀ
			// Busca percentual do identificador de 1/3 de ferias           
			//
			dbSelectArea( "TPR" )
			cFilialAnt := TPR->PR_FILIAL
			nPerc1T := PosSrv(aCodFol[77,1],TPR->PR_FILIAL,"RV_PERC")
	
			//Ŀ
			// Busca o percentual do identificador do PIS 								
			//	
			nPercPis := PosSrv( aCodFol[229,1],TPR->PR_FILIAL,"RV_PERC") / 100
	
			//Ŀ
			// Se gerou Ocorrencias aborta para apresentacao do LOG		 
			//
			If fAdicLog(aIdProvis,TPR->PR_FILIAL)
				Exit
			EndIf
	
		   If cPaisLoc == "URU"
		   	If !Loc_Bse(@nCSocial, @nBseFixo,,MesAno(dDataRef))   	
					Exit
				Endif	     
				//Ŀ
				// Carregando Variaveis com as Aliquotas do Imposto BPS	     
				//
				If !LOC_BPS(,@nBPSFunc,@nBPSConsC,,MesAno(dDataRef))  
					Return
				EndIf
			   	//Ŀ
				// Carregando Variaveis com as Aliquotas do Imposto FRL	     
				//
				If !LOC_FRL(,@nFRLFunc,MesAno(dDataRef))
					Return
				EndIf
				//Ŀ
				// CARREGA SALARIO MINIMO                                     
				//
				Sal_Min(@Val_SalMin,MesAno(dDataBase))			
				//Ŀ
				// Carregando Variaveis com as Aliquotas do Imposto DISSE	     
				//
				If !LOC_FONASA(,,@nFonasFunc,MesAno(dDataRef),,@nFonasDep,@nFonasSM,@nFonasSDep)
					Return
				EndIf
				
				//
				// Carrega o valor do BPC |
				//
			   	fCarrTab( @aTabBPC   , "S003", Nil)
				// Valor do Bpc
				IF Len(aTabBPC) > 0
					nValBpc   := fTabela("S003", 1 , 4 )
				Endif
				
				//Ŀ
				// Define a aliquota DISSE conforme o Salario e dependentes     
				// 			                     
				dbSelectArea( "SRA" )
				If SRA->RA_SALARIO > (nValBpc * 2.5)
					dbSelectArea( "SRB" )
					dbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
					//Verificar se existe dependentes
					While !Eof() .And. SRB->RB_FILIAL + SRB->RB_MAT == SRA->RA_FILIAL + SRA->RA_MAT
						If (SRB->RB_GRAUPAR == "F")
							If DateDiffYear(SRB->RB_DTNASC,dDataBase) < 18 .Or. DateDiffYear(SRB->RB_DTNASC,dDataBase) > 18 .And. (SRB->RB_TIPIR == "1")
	 							nTpDesc := nFonasDep //Se apenas um atender a condicao o valor sera aplicado
	 							lDepen  := .T.
	 							Exit
					 		Endif
						Endif
					dbSkip()
					Enddo	
				Else
					nTpDesc	:= nFonasSM  //Sem dependentes e menor de 2.5 Salarios Minimos
				Endif			
				
				//Ŀ
				// Tratamento Aliquota Fonasa com dependentes ou sem dependentes 
				//
				IF lDepen
					nTpDesc += nFonasDep
				ELSE
					nTpDesc += nFonasSDep 
				ENDIF
				
				nSomaPerc := (nBpsFunc+nFrlFunc+nTpDesc) / 100	
		  Endif
		  If cPaisLoc == "ARG"
				If !LOC_ProvArg(@aObraSoc,@aJubila,@aLey)
			   		Return
				Endif			
		  Endif
		Endif
		If cPaisLoc == "URU"
			DbSelectArea("CTT")
			If dbSeek(SRA->RA_FILIAL+SRA->RA_CC)
				cApolice := CTT->CTT_POLIZA
			Endif	
			If !Empty(cApolice)	
				If !Loc_Bse2(cApolice,@nAliqBse)
					Exit
				Endif
			Endif
		Endif
		//Ŀ
		//| Carrega tabela para apuracao dos dias de ferias - aTabFer    |
		//| 1-Meses Periodo    2-Nro Periodos   3-Dias do Mes    4-Fator |
		//
		fTab_Fer(@aTabFer)
	
		//Ŀ
		// Carrega variaveis para calculo dos encargos           		 
		//
		fEncargEmp(@nPercEmp, @nPercTer, @nPercAcTrab, @nPercFgts, nPercFgC, @cRecFatEmp, @nPerEmp13)
	
		nDFerAnt  := 0								  // Dias de ferias antecipadas
		dDtBasFer := TPR->PR_ADMISSA			      // Data Base Ferias Funcionario
		dbSelectArea( "SRF" )
		If !dbSeek( TPR->PR_FILIAL + TPR->PR_MAT )	  // Se nao achou Registro
			RecLock("SRF",.T.)                       // Gera automatico
			SRF->RF_FILIAL := TPR->PR_FILIAL
			SRF->RF_MAT    := TPR->PR_MAT
			SRF->RF_DATABAS:= TPR->PR_ADMISSA
			MsUnlock()
		Else
			dDtBasFer := If(SRF->RF_DATABAS # CtoD(""),SRF->RF_DATABAS,dDtBasFer)
			nDFerAnt  := SRF->RF_DFERANT
		Endif
		dbSelectArea( "TPR" )
	
		//Ŀ
		// Verifica o tipo de movimentacao do funcionario 				 
		//
		nTipoMovMes := TPR->PR_TIPMOVI
		lTransfSai  := ( nTipoMovMes == _Trfe_Sai )
		lDemitido   := ( nTipoMovMes == _Demitido )
		
		#IFDEF TOP
			//Ŀ
			// 1 ELEMENTO DO ARRAY - A N T E R I O R 			 			 
			//
			fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.F.,lFerias,l13oSal) 
		#ELSE
			//Ŀ
			// 1 ELEMENTO DO ARRAY - A N T E R I O R 			 			 
			//
			If lFerias
				fBusDetSRT(@aFerVenc,@aRecVenc,aVerba,aTransf,dDataRef,_FerVenc,lTrataTrf,.F.)
				fBusDetSRT(@aFerProp,@aRecProp,aVerba,aTransf,dDataRef,_FerProp,lTrataTrf,.F.)
			EndIf	
			If l13oSal
				fBusDetSRT(@a13Salar,@aRec13Sl,aVerba,aTransf,dDataRef,_13Salar,lTrataTrf,.F.)
				fBusDetSRT(@a14Salar,@aRec14Sl,aVerba,aTransf,dDataRef,_14Salar,lTrataTrf,.F.)
			EndIf
		#ENDIF
		//Ŀ
		// 2 ELEMENTO DO ARRAY - C O R R E C A O 						 
		//
		If nCorrecao > 0
			If lFerias
				fGrvArrPrv(aFerVenc, _Corre, _Anter, nCorrecao, { _Dias } )
				fGrvArrPrv(aFerProp, _Corre, _Anter, nCorrecao, { _Dias } )
			EndIf
			If l13oSal
				fGrvArrPrv(a13Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par } )
				If n14Salario > 0
					fGrvArrPrv(a14Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par } )
				EndIf
			Endif
		Endif
	
		//Ŀ
		// Zera variaveis para uma nova busca de salario e ferias		 
		//
	    nV_DFalFer := nP_DFalFer := nTFaltaV := nTFaltaP := 0
	    nSalario   := nSalMes    := nSalDia  := nSalHora := 0
	    nAdtServ   := nPeric     := nInsal   := 0.00
	
		//Ŀ
		// Se mes estiver fechado, calcular com valores do SRT	         
		//
		If lFechouMes .And. fBusCabSRT(dDataRef,@aCabProv)
			dDtBasFer  := aCabProv[_DBsProv]
			nDFerAnt   := aCabProv[_DFerAnt]
		    nSalario   := aCabProv[_SalProv]
		    nSalMes    := aCabProv[_SalProv]
		    nSalDia    := aCabProv[_SalProv] / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
		    nSalHora   := aCabProv[_SalProv] / TPR->PR_HRSMES
		    lTemCab	:= .T.
		EndIf
	
		//Ŀ
		// 6 ELEMENTO DO ARRAY - B A I X A  D E  F E R I A S / 1 3 o   
		//
		If ( !lDemitido .Or. lProvResc ) .And. !lTransfSai	//?-
			If lFerias
				fBxaFerProv(@dDtBasFer,@nDFerAnt,cArqBxaPr,cFilBxaPr,cMatBxaPr,cDatBxaPr,cPdBxaPr,cSeqBxaPr,cValBxaPr,cHrsBxaPr,lTemCab)
			EndIf
			If l13oSal .And. lBx13Pgt .And. (Month(dDataRef) == 12 .Or. If(cPaisLoc $ "ARG|URU|PAR",Month(dDataRef) == nFec131 ,.F.))
				fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13,cDatBxa13,cPdBxa13,cValBxa13)
			EndIf
		EndIf
	
		//Ŀ
		// 4 ELEMENTO DO ARRAY - A T U A L 							 
		//
		If lTransfSai
			If nSalMes == 0
				//Ŀ
				// Calcula Salario Mes , Dia , Hora do Funcionario              |
				//
				fSalario(@nSalario,@nSalHora,@nSalDia,@nSalMes,"A")
			EndIf	
		Else
			//Ŀ
			// Calcula Salario Incorporado Mes , Dia , Hora do Funcionario  
			//
			If !lCalcSalInc
				#IFDEF TOP
					cAliasPROC	:= "QPROC"
					fQrySRD( TPR->PR_FILIAL , TPR->PR_MAT , MesAno(dDataRef) )
					//-- Busca o salario mes, adic.tpo.servico, insalubridade e periculosidade
					While !(cAliasPROC)->(eof())
						If lFechouMes
							If !lTemCab .And. (cAliasPROC)->RD_PD == aCodFol[318,1]
								nSalMes += (cAliasPROC)->RD_VALOR
							ElseIf (cAliasPROC)->RD_PD == aCodFol[671,1]
								nAdtServ += (cAliasPROC)->RD_VALOR
							ElseIf (cAliasPROC)->RD_PD == aCodFol[672,1]
								nInsal += (cAliasPROC)->RD_VALOR
							ElseIf (cAliasPROC)->RD_PD == aCodFol[673,1]
								nPeric += (cAliasPROC)->RD_VALOR
							Endif
						Else
							If !lTemCab .And. (cAliasPROC)->RC_PD == aCodFol[318,1]
								nSalMes += (cAliasPROC)->RC_VALOR
							ElseIf (cAliasPROC)->RC_PD == aCodFol[671,1]
								nAdtServ += (cAliasPROC)->RC_VALOR
							ElseIf (cAliasPROC)->RC_PD == aCodFol[672,1]
								nInsal += (cAliasPROC)->RC_VALOR
							ElseIf (cAliasPROC)->RC_PD == aCodFol[673,1]
								nPeric += (cAliasPROC)->RC_VALOR
							Endif
						Endif
						(cAliasPROC)->(dbskip())
					Enddo
					(cAliasPROC)->(dbCloseArea())
				#ELSE
					//-- Valor do Salario Mensal
					If lFechouMes
						If !lTemCab .And. SRD->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[318,1] ))
							While !SRD->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+MesAno(dDataRef)+aCodFol[318,1] == ;
														SRD->RD_FILIAL+SRD->RD_MAT+SRD->RD_DATARQ+SRD->RD_PD
								nSalMes += SRD->RD_VALOR
								SRD->(dbskip())
							Enddo
						Endif
						//-- Valor do Adicional de Tempo de Servico
						If !Empty(aCodFol[671,1])
							If SRD->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[671,1] ))
								While !SRD->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+MesAno(dDataRef)+aCodFol[671,1] == ;
															SRD->RD_FILIAL+SRD->RD_MAT+SRD->RD_DATARQ+SRD->RD_PD
									nAdtServ += SRD->RD_VALOR
									SRD->(dbskip())
								Enddo
							Endif
						Endif
						//-- Valor do Adicional de Insalubridade
						If !Empty(aCodFol[672,1])
							If SRD->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[672,1] ))
								While !SRD->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+MesAno(dDataRef)+aCodFol[672,1] == ;
															SRD->RD_FILIAL+SRD->RD_MAT+SRD->RD_DATARQ+SRD->RD_PD
									nInsal += SRD->RD_VALOR
									SRD->(dbskip())
								Enddo
							Endif
						Endif
						//-- Valor do Adicional de Periculosidade
						If !Empty(aCodFol[673,1])
							If SRD->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[673,1] ))
								While !SRD->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+MesAno(dDataRef)+aCodFol[673,1] == ;
															SRD->RD_FILIAL+SRD->RD_MAT+SRD->RD_DATARQ+SRD->RD_PD
									nPeric += SRD->RD_VALOR
									SRD->(dbskip())
								Enddo
							Endif
						Endif
					Else
						If !lTemCab .And. SRC->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[318,1] ))
							While !SRC->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+aCodFol[318,1] == ;
														SRC->RC_FILIAL+SRC->RC_MAT+SRC->RC_PD
								nSalMes += SRC->RC_VALOR
								SRC->(dbskip())
							Enddo
						Endif
						//-- Valor do Adicional de Tempo de Servico
						If !Empty(aCodFol[671,1])
							If SRC->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[671,1] ))
								While !SRC->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+aCodFol[671,1] == ;
															SRC->RC_FILIAL+SRC->RC_MAT+SRC->RC_PD
									nAdtServ += SRC->RC_VALOR
									SRC->(dbskip())
								Enddo
							Endif
						Endif
						//-- Valor do Adicional de Insalubridade
						If !Empty(aCodFol[672,1])
							If SRC->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[672,1] ))
								While !SRC->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+aCodFol[672,1] == ;
															SRC->RC_FILIAL+SRC->RC_MAT+SRC->RC_PD
									nInsal += SRC->RC_VALOR
									SRC->(dbskip())
								Enddo
							Endif
						Endif
						//-- Valor do Adicional de Periculosidade
						If !Empty(aCodFol[673,1])
							If SRC->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[673,1] ))
								While !SRC->(eof()) .And.	TPR->PR_FILIAL+TPR->PR_MAT+aCodFol[673,1] == ;
															SRC->RC_FILIAL+SRC->RC_MAT+SRC->RC_PD
									nPeric += SRC->RC_VALOR
									SRC->(dbskip())
								Enddo
							Endif
						Endif
					Endif
				#ENDIF
				If !lTemCab
					nSalario:= nSalMes
					nSalDia	:= nSalMes / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
					nSalHora:= nSalMes / TPR->PR_HRSMES
				Endif
				//-- Carrega os codigos dos adicionais de tempo de servico que serao utilizados
				//-- nos calculos de provisoes de ferias e 13o salario.
				fCarAdics()
			Endif
	
			If nSalMes == 0 .Or. !lTemCab
				If lCalcSalInc .Or. nSalMes == 0
					fSalInc(@nSalario,@nSalMes,@nSalHora,@nSalDia,.T.)
				Endif
				//Ŀ
				//| Utiliza o Sal.Incorp. do Cadastro							 |
				//
				If lSalInc .And. TPR->PR_SALINCO > 0
					nSalMes  := TPR->PR_SALINCO
					nSalDia  := TPR->PR_SALINCO / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
					nSalHora := TPR->PR_SALINCO / TPR->PR_HRSMES
				Endif
			Else
				//Ŀ
				// Chama funcao para carregar adicionais - AdtServ/Peric/Insal  
				//
				If lCalcSalInc
					fSalInc(,,,,.T.)
				Endif
	    	EndIf
	    	
			If lProvResc .And. lDemitido
				/*
				Ŀ
				 Verifica Demissao e Sexta Feira ou Sabado e Cons. Parametro
				 Para Pagar Sabado e Domingo.                               
				*/
				dDataDem1	:= TPR->PR_DEMISSA
				dDataDem1	:= fDtSabDom()
			EndIf

			//Ŀ
			// Carregando Arquivo TRP com Monta Media						 
			//
			If ( !lDemitido .Or. lProvResc )
				dbSelectArea("TRP")
				Zap    
				dRefMed	:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
				GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,(!lFechouMes),,,,.F.)
			Endif
	
			dbSelectArea( "TPR" )
	
			//Ŀ
			// Calcula ferias vencidas e proporcionais						 
			//
			If lFerias
				fProvFer(cCongAci,cCongDoe,@nTipoMovMes,@dDtBasFer)
			EndIf
			
			//Ŀ
			// Calcula o 13 Salario 										 
			//
			If l13oSal .And. ( !lDemitido .Or. lProvResc )
				fProv13o(cAbatAci,cAbatDoe,@nTipoMovMes,cAbatAdo)
			EndIf
	
		EndIf
		
		//Ŀ
		// 5 ELEMENTO DO ARRAY - B A I X A  T R A N S F E R E N C I A	 |
		// 7 ELEMENTO DO ARRAY - B A I X A  R E S C I S A O			 |
		//
		If lTransfSai .Or. lDemitido
			If lFerias
				If lTransfSai
					fGrvArrPrv(@aFerVenc, _BxTrf, _Anter, 1, {} )
					fGrvArrPrv(@aFerProp, _BxTrf, _Anter, 1, {} )
				Else
					fGrvArrPrv(@aFerVenc, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
					fGrvArrPrv(@aFerProp, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
				EndIf
			EndIf
			If l13oSal
				If lTransfSai
					fGrvArrPrv(@a13Salar, _BxTrf, _Anter, 1, {} )
					fGrvArrPrv(@a14Salar, _BxTrf, _Anter, 1, {} )
				Else
					fGrvArrPrv(@a13Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
					fGrvArrPrv(@a14Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
				EndIf
			EndIf
		EndIf
	
		//Ŀ
		// Atualiza o arquivo de cabecalho - SRF                     	 |
		//
		If ( !lDemitido .Or. lProvResc ) .And. !lTransfSai
			dbSelectArea( "SRF" )
			RecLock("SRF",.F.)
			If lFerias
				nDiasFv := aFerVenc[_Atual,_Dias] + nV_DFalFer
				nDiasFv += If(aFerVenc[_Atual,_Dias] > 0, nDFerAnt, 0)
				nDiasFv -= SRF->RF_DVENPEN
				If nDiasFv = 0 .And. nDFerAnt > 0
					nDiasFv := nDFerAnt * (-1)
				Endif
				aFerVenc[_Atual,_Dias] := If (nDiasFv < 0 .Or. lTrfSld, 0 , nDiasFv) + SRF->RF_DVENPEN
				//Ŀ
				// Soma os dias de faltas aos dias de proporcionais.        	 |
				//
				aFerProp[_Atual,_Dias] += nP_DFalFer
				SRF->RF_DFERVAT := If(nDiasFv < 0,0,nDiasFv)   // Dias de Ferias Vencidas
				SRF->RF_DFALVAT := If(nDiasFv # 0,Int(nTFaltaV),0)  // Dias de Faltas Vencidas
				SRF->RF_DFERAAT := aFerProp[_Atual,_Dias]		 // Dias de Ferias Proporcionais
				SRF->RF_DFALAAT := nTFaltaP				     // Dias de Faltas Proporcionais
			EndIf
			If l13oSal
				SRF->RF_PAR13AT := a13Salar[_Atual,_1Par]      // 1 Parcela do 13 Salario
			EndIf
			MsUnlock()
	    EndIf
	    	    
		//Ŀ
		// Para o novo calculo de rateio, chama novamente a funcao que  |
		// apura os valores mensais para posterior geracao na tab. SRT  |		
		//	   	    
	   	If lGeraPMes 
	    
			#IFDEF TOP
				fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.T.,lFerias,l13oSal,.T.) 
			#ELSE
				If lFerias
					fBusDetSRT(@aFerVenc,@aRecVenc,aVerba,aTransf,dDataRef,_FerVenc,lTrataTrf,.T.,.T.)
					fBusDetSRT(@aFerProp,@aRecProp,aVerba,aTransf,dDataRef,_FerProp,lTrataTrf,.T.,.T.)
				EndIf	
				If l13oSal
					fBusDetSRT(@a13Salar,@aRec13Sl,aVerba,aTransf,dDataRef,_13Salar,lTrataTrf,.T.,.T.)
					fBusDetSRT(@a14Salar,@aRec14Sl,aVerba,aTransf,dDataRef,_14Salar,lTrataTrf,.T.,.T.)
				EndIf
			#ENDIF
	    	
	    Endif 
	    
		//Ŀ
		// Grava as ferias vencidas e proporcinais no arquivo detalhe.  |
		//
		If lFerias
			fGeraSRT(@aFerVenc,aRecVenc,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerVenc)
			fGeraSRT(@aFerProp,aRecProp,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerProp)
		EndIf
	                                              
		//Ŀ
		// Grava o 13 e 14 Salario no arquivo detalhe.		         |
		//
		If l13oSal
			fGeraSRT(@a13Salar,aRec13Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_13Salar)
			fGeraSRT(@a14Salar,aRec14Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_14Salar)
		EndIf
		
	   	If lGeraPMes 
			fGeraMes()
		Endif  
	
		//Ŀ
		// Se for recalculo, deletar o registro de "OK", indicando que  |
		//| devera ser gerado um novo SRZ no momento da contabilizacao.  |
		//
		fDelRegSRZ(3,"1",dDataRef)

		dbSelectArea( "TPR" )
		
		//Ŀ
		// Finaliza a gravacao dos lancamentos do SIGAPCO          
		//
		PcoFinLan("000091")
	EndIf
	
	dbSkip()
Enddo

If ( lGp070Fim )
	EXECBLOCK("GP070FIM",.F.,.F.)
Endif         

If lGrid
	//Ŀ
	// Execucao do Calculo da Provisao atraves do GRID		       	 
	//
	CalcGrid(aCall,aPar,{cTPRDbf,cTPRNtx},aAreaSRA)
Else

	TRP->(dbCloseArea())
	fErase(cArqNtx + OrdBagExt())
	fErase(cArqDbf + ".DBF")
	
	TPR->(dbCloseArea())
	fErase(cTPRNtx + OrdBagExt())
	fErase(cTPRDbf + ".DBF")
	
	nTimeFim	:= Seconds()	// Tempo de calculo para o GRID	
	
	//Ŀ
	// Apresenta Tela com Log de erros								 
	//
	aAdd( aLogFile, { "" } )
	aLogFile[Len(aLogFile),1] += STR0057 + " " + SecsToTime( nTimeIni ) + " " + STR0046 + " " + dDtCalIni 			+ CRLF // "Inicio do Processo de Calculo:" ## "de"
	aLogFile[Len(aLogFile),1] += STR0045 + " " + SecsToTime( nTimeFim ) + " " + STR0046 + " " + Dtoc( MsDate() )	+ CRLF // "Final do Processo de Calculo:" ## "de"
	aLogFile[Len(aLogFile),1] += STR0047 + " " + SecsToTime(nTimeFim - nTimeIni) + CRLF // "Duracao do Processo de Calculo:"
	fMakeLog( aLogFile, aLogTitle, "GPM070", .T. )
	
	//Ŀ
	// Retorna area original do cadastro de funcionarios		     
	//
	RestArea(aAreaSRA)
EndIf

Return Nil

/*


Ŀ
Funao	 fProvFer   Autor  Emerson Rosa de Souza	 Data  26.06.00 
Ĵ
Descriao  Calcula provisao de ferias vencidas						  
Ĵ
Sintaxe	  fProvFer(cCongAci,cCongDoe,nTipoMovMes,dDtBasFer) 	      
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fProvFer(cCongAci,cCongDoe,nTipoMovMes,dDtBasFer)
Local nAdtDia     := nInsDia   := nPerDia   := nNroFaltas := nPeriVenc := 0
Local nTDiasAfa   := nV_TotFer := 0
Local lCongelaFer := .F.
Local lDiasAfAcum := ( cTpCongAf == "2" )
Local lMudaPer 	  := .F.
Local aMediaHrs   := {}           
Local aDados      := {}         
Local dRetFimOP   := Ctod("") 
Local dDataFer	  := Ctod("")  
Local dSvDtBas	  := dDtBasFer 
Local nMediaOut   := 0
Local cCodDias	  := 0
Local nRemVar	  := 0
Local nDiasNDesc  := 0
Local nDias       := 0
Local nTotVar     := 0
Local k			  := 0
Local nX 		  := 0
Local nDsrHrsAtiv := 0

//Ŀ
// Variaveis utilizadas nos pontos de entrada				     
//
Private nV_DSaldo := nV_Valor  := nV_Adic := nV_UmTer := nV_Inss := nV_Fgts := nV_Pis := 0
Private nP_DSaldo := nP_Valor  := nP_Adic := nP_UmTer := nP_Inss := nP_Fgts := nP_Pis := 0
Private nDiasProp := nDiasVenc := 0
Private nV_CSocial := nV_Bse := nP_CSocial := nP_Bse	:= 0
Private nV_ObraSoc := nV_Ley := nV_Jubil := nP_ObraSoc := nP_Ley  := nP_Jubil := 0

//Ŀ
// Calculo dos Dias de Ferias 								     
//

//Ŀ
// Ponto de Entrada p/ alterar Database Ferias e dias Ferias Antecipadas|
//
If ExistBlock("GP070ANT")
	aDados	:=	ExecBLock('GP070ANT',.F.,.F.,{dDtBasFer,dDataRef,nDFerAnt})
	If ValType(aDados) == "A" .And. !Empty(aDados)
		If ValType(aDados[1]) == "N" .And. ValType(aDados[2]) == "D"
			nDFerAnt  := aDados[1]
			dDtBasFer := aDados[2]
		EndIf		
	EndIf
Endif   

If TPR->PR_SITFOLH == "A" .And. lDiasAfAcum .And. TPR->PR_AFASFGT $ cTAfaFer .And. TPR->PR_AFASFGT == 'X' 
	dbSelectArea('SR8')
	If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT)
		While !EOF() .And. SR8->R8_FILIAL + SR8->R8_MAT == TPR->PR_FILIAL + TPR->PR_MAT 
			dDataFer := SR8->R8_DATAINI + 30 
			dbSkip()
	    EndDo
    EndIf
Else
	dDataFer:= dDataRef
Endif

Calc_Fer(@dDtBasFer,If(lProvResc .And. lDemitido,TPR->PR_DEMISSA,dDataFer),@nDiasVenc,@nDiasProp,@nTDiasAfa,,,,cTAfaFer,.T.,lDiasAfAcum,;
@lMudaPer,/*nTotAfa8*/,/*cCodTipAfa*/,/*lTpAviso*/,@dRetFimOP)
nDiasVenc += SRF->RF_DVENPEN // Soma os dias de ferias pendentes

//Ŀ
// Verifica se houve afastamento e se deve congelar			 
//
If nTipoMovMes != 6 .And. TPR->PR_SITFOLH == "A" .And. !TPR->PR_AFASFGT $ cAfastProv 
	//Ŀ
	// Congela e mantem os dias de vencidas do mes anterior		 
	//
	lCongelaFer := .T.
	nDiasVenc := aFerVenc[_Anter,_Dias]
//Ŀ
// Se funcionario afastado na data de referencia por motivo "O/P", trata a perda do periodo.			  |
//
Elseif ( ( cCongAci == "C" .And. TPR->PR_SITFOLH == "A" .And. TPR->PR_AFASFGT = "O" ) .Or. ;
	  	( cCongDoe == "C" .And. TPR->PR_SITFOLH == "A" .And. TPR->PR_AFASFGT = "P" ) ) .And. ;
		( ( nTDiasAfa > 0 ) .and. ( Empty(dRetFimOP) .or. (dRetFimOP >=dDataRef) ) ) 
	//Ŀ
	// Somente congelar se houver mais de 180 dias afastado         |
	//
	If nTDiasAfa >= 180
		//Ŀ
		// Se parametro configurado para nao provisionar apos 6 meses de|
		// afastado, zerar dias de proporcionais e forcar congelamento  |
		//
		nDiasProp	:= 0
		nTipoMovMes	:= _Cong_Fer
		If cTpCongAf == "1"	
			//Ŀ
			// Se for calculo no mes do periodo aquisitivo e nao gerou 2.5  |
			// dias de proporcionais para o proximo periodo, congela saldo  |
			// anterior (15 dias) p/ que seja efetuada baxa no proximo mes  |
			//
			If Month(dDtBasFer) == Month(dDataRef) .And. nDiasProp == 0
				lCongelaFer := .T.
			EndIf
		EndIf
	EndIf

Elseif (cCongAci == "N" .And. TPR->PR_SITFOLH == "A" .And. TPR->PR_AFASFGT = "O" ) .Or.;
	   (cCongDoe == "N" .And. TPR->PR_SITFOLH == "A" .And. TPR->PR_AFASFGT = "P" )
	//Ŀ
	// Congela e mantem os dias de vencidas do mes anterior		 
	//
	lCongelaFer := .T.
	nDiasVenc   := aFerVenc[_Anter,_Dias]
//Se houve mudanca do periodo devido perda devido afastamento, recomeca contagem dos dias proporcionais
ElseIf lMudaPer
	Calc_Fer(dRetFimOP + 1, If(lProvResc .And. lDemitido, TPR->PR_DEMISSA, dDataFer), Nil, @nDiasProp, Nil, Nil, Nil, Nil, cTAfaFer, .T.)
Endif

//Ŀ
// Verifica tipo de movimentacao do funcionario				 
//
nTipoMovMes := If(lCongelaFer .And. !lDemitido, _Cong_Fer, nTipoMovMes) // Alterar Movimento p/2 (congela), qdo "lCongelaFer" for .T. e nao for demitido.

//Ŀ
// Verifica Se Deve Pagar os Adicionais						 
//
If cCodAdt # Space(3) .And. PosSrv(cCodAdt,TPR->PR_FILIAL,'RV_INCORP') # 'S'
	nAdtDia := (nAdtServ / 30)
Endif
If cCodIns # Space(3) .And. PosSrv(cCodIns,TPR->PR_FILIAL,'RV_INCORP') # 'S'
	nInsDia := (nInsal / 30)
Endif
If TPR->PR_PERICUL > 0.00 .And. PosSrv(aCodfol[36,1],TPR->PR_FILIAL,'RV_INCORP') # 'S'
	nPerDia := (nPeric / 30)
Endif

//Ŀ
// Calculo das Ferias Vencidas             					 
//
If ( !lDemitido .Or. lProvResc )
	If  nDiasVenc == 0
		aFerVenc[_Atual,_Dias] := 0	
	Else
		dbSelectArea( "TRP" )
			
		//Ŀ
		// Verifica numero de faltas em cada periodo de ferias vencidas 
		//
		For k := 1 To 6
			cTipMed	   := Str( If(k ==1, 1,k+3),1 )
			nNroFaltas := 0
			If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cTipMed + "998" + "9698" )
				nNroFaltas := TRP->RP_HORAS
				TabFaltas(@nNroFaltas)
				nV_DFalFer += nNroFaltas
				nTFaltaV   += TRP->RP_HORAS
			EndIf
		Next k
		nV_DSaldo  := nDiasVenc - nDFerAnt - nV_DFalFer
		nV_Valor   := NoRound( nSalDia * nV_DSaldo)
		nV_Adic    := (nInsDia+nPerdia+nAdtDia) * nV_DSaldo
	
	   If !(cPaisLoc $ "URU|ARG")
			//Ŀ
			// Calcula adicionais para cada periodo de ferias vencidas      
			//
			nPeriVenc  := Max(Int(nDiasVenc/aTabFer[3]), 1)
			For k := 1 To 6
				cTipMed	:= Str( If(k ==1, 1,k+3), 1)
				nDsrHrsAtiv := fDsrHrsAtiv(cTipMed,aCodFol) //Calculo do DSR / Horas Atividade de professores
				If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cTipMed + "999" + "99MD" )
					If nV_DSaldo > 0
						nV_Adic += ( ((TRP->RP_VALATU + nDsrHrsAtiv)/(aTabFer[3]*nPeriVenc)) * nV_DSaldo)
					Endif
					//Ŀ
					// Calcula Peric./Insalub Verba de Medias Que Tem Incidencia	 
					//
					nMedPer := nMedIns := 0.00
					FMedPerIns(@nMedPer,@nMedIns,cTipMed,nSalHora,nSalMin,aCodFol)
					nV_Adic += If(nV_DSaldo > 0 ,((nMedPer+nMedIns)/(aTabFer[3]*nPeriVenc))*nV_DSaldo ,0)
				Endif
			Next k
		ElseIf cPaisLoc == "URU"	
			cCodDias 	:=	If(SRA->RA_TIPOPGT <> "M",aCodFol[360][1],aCodFol[031][1])
			//Calcula os dias trabalhados no mes(Jornadas)
			nDias	:=	DiasTrabAno(MesAno(dDtBasFer),Str(Year(dDtBasFer),4)+"12",cCodDias,.T.)
		   	//Verifica se houve faltas no descontables(Sin Citacion) para entrar no calculo
			DiasNoDesc(dDtBasFer,Ctod(StrZero(F_ULTDIA(dDtBasFer),2)+"/"+Strzero(Month(dDtBasFer),2)+"/"+right(str(Year(dDtBasFer)),2)),@nDiasNDesc)
			//Somatoria dos Dias Trabalhados com os Dias Sin Citacion 
			nDias := nDias+nDiasNDesc
			MedHrsFer(@aMediaHrs,@nMediaOut,1)   
			For nX := 1 to Len(aMediaHrs)
				nRemVar := Round(((aMediaHrs[nX][1] / nDias)*nV_DSaldo) * nSALHORA, MsDecimais(1))  
				nTotVar += (nRemVar * aMediaHrs[nX][2])/100
			Next
			nV_Adic    := nTotVar
			aMediaHrs  := {} 
			nTotVar    := 0      
		Endif	
	
		//Ŀ
		// Ponto de Entrada para Alterar valores dos Adicional Vencidas |
		//
		If ExistBlock("GP070VEN")
			EXECBLOCK("GP070VEN",.F.,.F.)
		Endif
		If !(cPaisLoc $ "URU|ARG")
			nV_UmTer   := NoRound((nV_Valor+nV_Adic) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100) )
		ElseIf cPaisLoc == "URU"
			nV_UmTer   := Round(nV_Valor - (nV_Valor * nSomaPerc),MsDecimais(1))
		Endif
		//Ŀ
		// Ponto de Entrada para Alterar Valores de 1/3 Fer.Vencidas    |
		//
		If ExistBlock("GP070V13")
			EXECBLOCK("GP070V13",.F.,.F.)
		Endif
	   If !(cPaisLoc $ "URU|ARG")
			nV_TotFer  := nV_Valor + nV_Adic + nV_UmTer
			nV_Inss    := NoRound(nV_TotFer * (nPercEmp+nPercTer+nPercAcTrab))
			nV_Fgts    := NoRound(nV_TotFer * nPercFgts)
			nV_Pis	   := NoRound(nV_TotFer * nPercPis)
		ElseIf cPaisLoc == "URU"
			nV_CSocial:= ((nV_Valor+nV_Adic)  * nCSocial) / 100
			nV_Bse	 := ((nV_Valor+nV_Adic) * nAliqBse)/100
			nV_Bse    += (nV_Bse * nBSeFixo) / 100
	   ElseIf cPaisLoc == "ARG"
			nV_TotFer  := nV_Valor + nV_Adic 
			nV_ObraSoc := fCalcEncLoc(nV_TotFer, aObraSoc)
			nV_Jubil := fCalcEncLoc(nV_TotFer, aJubila)
			nV_Ley := fCalcEncLoc(nV_TotFer, aLey)
		Endif
		//Ŀ
		// Ponto de Entrada para Alterar valores de Inss e Fgts Vencidas|
		//
		If ExistBlock("GP070VIF")
			EXECBLOCK("GP070VIF",.F.,.F.)
		Endif
				
		//Ŀ
		// Grava os valores calculados no array de ferias vencidas      |
		//
		aFerVenc[_Atual,_Dias] := nV_DSaldo
		aFerVenc[_Atual,_Prov] := nV_Valor
		aFerVenc[_Atual,_Adic] := nV_Adic
		aFerVenc[_Atual,_1Ter] := nV_UmTer
		If cPaisLoc == "BRA"
			aFerVenc[_Atual,_INSS] := nV_Inss
			aFerVenc[_Atual,_FGTS] := nV_Fgts
			aFerVenc[_Atual,_PIS]  := nV_Pis
		ElseIf cPaisLoc == "URU"
			aFerVenc[_Atual,_INSS] := nV_CSocial
			aFerVenc[_Atual,_FGTS] := nV_Bse
			aFerVenc[_Atual,_PIS]  := 0
			aFerVenc[_Atual,_SalV] := Round(nV_Adic - (nV_Adic * nSomaPerc),MsDecimais(1))
		ElseIf cPaisLoc == "ARG"
			aFerVenc[_Atual,_INSS] := nV_ObraSoc
			aFerVenc[_Atual,_FGTS] := nV_Jubil
			aFerVenc[_Atual,_PIS]  := nV_Ley
		Endif		
	Endif		
EndIf
			
//Ŀ
// Calculo de Ferias Proporcionais 					       	 
//
If ( !lDemitido .Or. lProvResc ) .And. !lCongelaFer
	dbSelectArea( "TRP" )
	If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + "2" + "998" + "9698" )
		nP_DFalFer := TRP->RP_HORAS
		nTFaltaP   := TRP->RP_HORAS
		TabFaltas(@nP_DFalFer) 						     //-- Aplica Tabela de Faltas
		nP_DFalFer := ((nP_DFalFer / aTabFer[3]) * nDiasProp ) //--Calculo de Faltas Proporcional
	Endif
	nP_DSaldo  := nDiasProp - nP_DFalFer - If (nDiasVenc > 0 , 0,nDFerAnt)
	nP_Valor   := Round(nSalDia * nP_DSaldo,2)
	nP_Adic    := Round( (nInsDia+nPerdia+nAdtDia) * nP_DSaldo,2)
	If cPaisLoc <> "URU"
		dbSelectArea( "TRP" )
		If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + "2" + "999" + "99MD" )
			If nDiasProp > 0
				nP_Adic += Round( (TRP->RP_VALATU/nDiasProp) * nP_DSaldo,2)
			Endif

			nDsrHrsAtiv := fDsrHrsAtiv("2",aCodFol) //Calculo do DSR / Horas Atividade de professores

			//Ŀ
			// Calcula Peric./Insalub Verba de Medias Que Tem Incidencia	 
			//
			nMedPer := nMedIns := 0.00
			FMedPerIns(@nMedPer,@nMedIns,'2',nSalHora,nSalMin,aCodFol)
			If nDiasProp > 0
				nP_Adic += (nMedPer+nMedIns+nDsrHrsAtiv) / nDiasProp * nP_DSaldo
			EndIf
		Endif
	Else                                      
		cCodDias 	:=	If(SRA->RA_TIPOPGT <> "M",aCodFol[360][1],aCodFol[031][1])
		//Calcula os dias trabalhados no mes(Jornadas)
		nDias	:=	DiasTrabAno(Str(Year(dDataRef),4)+"01",MesAno(dDataRef),cCodDias,.T.)
	   	//Verifica se houve faltas no descontables(Sin Citacion) para entrar no calculo
		DiasNoDesc(Ctod("01/01/"+str(Year(dDataRef),4)),Ctod(StrZero(F_ULTDIA(dDataRef),2)+"/"+Strzero(Month(dDataRef),2)+"/"+right(str(Year(dDataRef)),2)),@nDiasNDesc)
		//Somatoria dos Dias Trabalhados com os Dias Sin Citacion 
		nDias := nDias+nDiasNDesc
		MedHrsFer(@aMediaHrs,@nMediaOut,2)   
		For nX := 1 to Len(aMediaHrs)
		   	nRemVar := Round(((aMediaHrs[nX][1] / nDias)*nP_DSaldo) * nSALHORA, MsDecimais(1))  
			nTotVar += (nRemVar * aMediaHrs[nX][2])/100
	  	Next
		nP_Adic    := nTotVar
		aMediaHrs  := {} 
		nTotVar    := 0      
	Endif	

	//Ŀ
	// Ponto de Entrada para ALterar valores dos Adicionais Proporc.
	//
	If ExistBlock("GP070PRO")
		EXECBLOCK("GP070PRO",.F.,.F.)
	Endif
   If cPaisLoc <> "URU
		nP_UmTer   := Round((nP_Valor+nP_Adic) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100),2 )
	Else
		nP_UmTer   :=  Round(nP_Valor - (nP_Valor * nSomaPerc),MsDecimais(1))
	Endif
	//Ŀ
	// Ponto de Entrada para Alterar Valores de 1/3 Proporcionais   
	//
	If ExistBlock("GP070P13")
		EXECBLOCK("GP070P13",.F.,.F.)
	Endif
	If !(cPaisLoc $ "URU|ARG")
		nP_TotFer  := nP_Valor + nP_Adic + nP_UmTer
		nP_Inss    := NoRound(nP_TotFer * (nPercEmp+nPercTer+nPercAcTrab))
		nP_Fgts    := NoRound(nP_TotFer * nPercFgts)
		nP_Pis	   := NoRound(nP_TotFer * nPercPis)
	ElseIf cPaisLoc == "URU"
		nP_TotFer  := nP_Valor + nP_Adic 
		nP_CSocial := (nP_TotFer * nCSocial) / 100
		nP_Bse	   := (nP_TotFer * nAliqBse)/100
		nP_Bse     += (nP_Bse * nBSeFixo) / 100
	ElseIf cPaisLoc == "ARG"
		nP_TotFer  := nP_Valor + nP_Adic 
		nP_ObraSoc := fCalcEncLoc(nP_TotFer, aObraSoc)
		nP_Jubil := fCalcEncLoc(nP_TotFer, aJubila)
		nP_Ley := fCalcEncLoc(nP_TotFer, aLey)
	Endif
	//Ŀ
	// Ponto de Entrada para Alterar valores de Inss e Fgts Proporc.|
	//
	If ExistBlock("GP070PIF")
		EXECBLOCK("GP070PIF",.F.,.F.)
	Endif
			
	//Ŀ
	// Grava os valores calculados no array de ferias proporcionais |
	//
	aFerProp[_Atual,_Dias] := nP_DSaldo
	aFerProp[_Atual,_Prov] := nP_Valor
	aFerProp[_Atual,_Adic] := nP_Adic
	aFerProp[_Atual,_1Ter] := nP_UmTer
	If cPaisLoc == "BRA"
		aFerProp[_Atual,_INSS] := nP_Inss
		aFerProp[_Atual,_FGTS] := nP_Fgts
		aFerProp[_Atual,_PIS]  := nP_Pis
	ElseIf cPaisLoc == "URU"	
		aFerProp[_Atual,_INSS] := nP_CSocial
		aFerProp[_Atual,_FGTS] := nP_Bse
		aFerProp[_Atual,_PIS]  := 0
		aFerProp[_Atual,_SalV] := Round(nP_Adic - (nP_Adic * nSomaPerc),MsDecimais(1))
	ElseIf cPaisLoc == "ARG"
		aFerProp[_Atual,_INSS] := nP_ObraSoc
		aFerProp[_Atual,_FGTS] := nP_Jubil
		aFerProp[_Atual,_PIS]  := nP_Ley
	Endif	
		
	//Ŀ
	// Congela Provisao Para Funcionario Afastados 				 |
	//
Elseif !lDemitido .And. lCongelaFer
	dDtBasFer := dSvDtBas//Database de ferias do periodo anterior
	aFerProp[_Atual,_Dias] := aFerProp[_Anter,_Dias]
	aFerProp[_Atual,_Prov] := aFerProp[_Anter,_Prov]
	aFerProp[_Atual,_Adic] := aFerProp[_Anter,_Adic]
	aFerProp[_Atual,_1Ter] := aFerProp[_Anter,_1Ter]
	If cPaisLoc == "BRA"
		aFerProp[_Atual,_INSS] := NoRound( ( aFerProp[_Anter,_Prov] + aFerProp[_Anter,_Adic] + aFerProp[_Anter,_1Ter] ) * ( nPercEmp + nPercTer + nPercAcTrab ) )
	Else
		aFerProp[_Atual,_INSS] := aFerProp[_Anter,_INSS]
	EndIf
	aFerProp[_Atual,_FGTS] := aFerProp[_Anter,_FGTS]
	aFerProp[_Atual,_PIS]  := aFerProp[_Anter,_PIS]
	If cPaisLoc == "URU"
		aFerProp[_Atual,_SalV] := aFerProp[_Anter,_SalV]
	Endif	
Endif

Return

/*


Ŀ
Funao	 fBxaFerPro Autor  Emerson Rosa de Souza	 Data  26.06.00 
Ĵ
Descriao  Busca a Baixa de Ferias									  
Ĵ
Sintaxe	  fBxaFerProv(dDtBasFer,nDFerAnt,cArqBxaPr,cFilBxaPr,...)	  
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fBxaFerProv(dDtBasFer,nDFerAnt,cArqBxaPr,cFilBxaPr,cMatBxaPr,cDatBxaPr,cPdBxaPr,cSeqBxaPr,cValBxaPr,cHrsBxaPr,lTemCab)

Local nValABoInss := nValABoFGTS := nValAboPis := 0

Local ddTpg0      := CTOD("")

Local lAchou		:= .F.
Local lFerMes		:= .F.
Local lPrimeira		:= .T.
Local lTrocouPer	:= .F.
Local lExeQry		:= .F.
Local lBxaFer		:= .F.

Local cChaveBusca	:= ""
Local cDataBusca	:= MesAno(dDataRef)
Local cOldArq		:= cArqBxaPr

Local aArea			:= GetArea()

//Ŀ
// Variaveis utilizadas nos pontos de entrada				     
//
Private nBx_Valor  := nBx_Adic := nBx_UmTer := nBx_Inss := nBx_Fgts := nBx_Pis := 0
Private nBx_SalVa := 0
//Ŀ
// Variaveis para provisionar ferias quebradas(Mes/Mes seguinte)
//
Private nBx_ValMs := nBx_AdiMs := nBx_UmTMs := nBx_InsMs := nBx_InsAbMs := nBx_FgtMs := nBx_FgtAbMs := nBx_PisMs := nBx_PisAbMs := 0
Private nBx_SalVMs := 0
//Ŀ
// Define a chave de busca do arquivo (SRC ou SRD)    			 
//
If cArqBxaPr == "SRC"
	cChaveBusca := TPR->PR_FILIAL + TPR->PR_MAT
Else
	cChaveBusca := TPR->PR_FILIAL + TPR->PR_MAT + cDataBusca
EndIf	

//Ŀ
// Verifica Se esta de ferias no mes da Provisao				 
//
dbSelectArea( "SRH" )
If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT )
	While ! Eof() .And. TPR->PR_FILIAL+TPR->PR_MAT == SRH->RH_FILIAL+SRH->RH_MAT
		If MesAno(SRH->RH_DATAINI) == cDataBusca
			If !lFechouMes
				If !lTrocouPer .And. SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS + nDFerAnt >= aTabFer[3] 
					dDtBasFer := SRH->RH_DBASEAT + 1
					nDFerAnt  := 0
				Else
					nDFerAnt  += SRH->RH_DABONPE + SRH->RH_DFERIAS
				EndIf
			EndIf
			If lPrimeira
				lAchou := .T.
				lPrimeira := .F.
				lTrocouPer:= SRH->RH_DATABAS <> dDtBasFer
			Endif
			lFerMes := ( If( !lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T. ) )
			//Ŀ
			// Se tipo de baixa mes e mes seguinte, atualiza variavel lAchou
			// para forcar a busca das ferias no segundo mes.               
			//
		ElseIf (cTpBxFer == "2" .And. ( MesAno(SRH->RH_DATAFIM) == cDataBusca .Or. MesAno(SRH->RH_DATAFIM+SRH->RH_DABONPE) == cDataBusca ))
			If lPrimeira
				lAchou := .T.
				lPrimeira := .F.
			Endif
			lFerMes := ( If( !lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T. ) )
		Elseif MesAno(SRH->RH_DATAFIM) == cDataBusca
			dDtPg0 := SRH->RH_DTRECIB
		Endif
		dbSkip()
	Enddo
Endif

//Ŀ
//  Query para buscar informacoes do SRC ou SRD     			 
//
fQryFerBx(@cArqBxaPr,cDataBusca,@lExeQry)

//Ŀ
// Baixa pelo Valor Pago no Mes ATual   						 
//
dbSelectArea( cArqBxaPr )

If lExeQry
	lBxaFer	:= !(cArqBxaPr)->(Eof())
	fChgAlias(,cArqBxaPr,cOldArq,@cDatBxaPr,@cFilBxaPr,@cMatBxaPr,@cPdBxaPr,@cValBxaPr,@cSeqBxaPr,@cHrsBxaPr)
Else
	lBxaFer := dbSeek( cChaveBusca )
EndIf

If lAchou .And. lBxaFer
	While !(cArqBxaPr)->(Eof()) .And. ( Eval(cFilBxaPr) + Eval(cMatBxaPr) == TPR->PR_FILIAL + TPR->PR_MAT ) .And.;
						( Eval(cDatBxaPr) == cDataBusca )
						
		If Empty(dDtPg0) .Or. ( ! Empty(dDtPg0) .And. Eval(cSeqBxaPr) # " ")
		
		    If cTpBxFer == "2" .And. Eval(cPdBxaPr) == aCodFol[073,1]
				nDFerAnt -= If(!lTrocouPer .And. !lTemCab,Eval(cHrsBxaPr),0)
		    EndIf
			If Eval(cPdBxaPr) $ cCodFer .Or. Eval(cPdBxaPr) $ cCodFerMs
				nBx_Valor += Eval(cValBxaPr)     //-- Baixa de Valor Ferias
				If Eval(cPdBxaPr) $ cCodFerMs
					nBx_ValMs += Eval(cValBxaPr) //-- Ferias do Proximo Mes
				EndIf
			Endif
			If Eval(cPdBxaPr) $ cCodAdFer .Or. Eval(cPdBxaPr) $ cCodAdicMs
				nBx_Adic += Eval(cValBxaPr)       //-- Baixa de Adicionais
				If Eval(cPdBxaPr) $ cCodAdicMs
					nBx_AdiMs += Eval(cValBxaPr)  //-- Adicionais do Proximo Mes
				EndIf
			Endif

			If Eval(cPdBxaPr) $ cCodUmTer .Or. Eval(cPdBxaPr) $ cCodUmTerMs
				nBx_UmTer += Eval(cValBxaPr)       //-- Baixa de Um Terco (1/3)
				If Eval(cPdBxaPr) $ cCodUmTerMs
					nBx_UmTMs += Eval(cValBxaPr)   //-- Um Terco do Proximo Mes
				EndIf
			Endif

			If Eval(cPdBxaPr) $ cCodFer .Or. Eval(cPdBxaPr) $ cCodAdFer .Or. If(cPaisLoc <> "URU",Eval(cPdBxaPr) $ cCodUmTer,.F.) .Or.;
   	           Eval(cPdBxaPr) $ cCodFerMs .Or. Eval(cPdBxaPr) $ cCodAdicMs .Or. Eval(cPdBxaPr) $ cCodUmTerMs
				nBx_Inss += Eval(cValBxaPr)      // I.N.S.S.
				nBx_Fgts += Eval(cValBxaPr)      // F.G.T.S.
				nBx_Pis  += Eval(cValBxaPr)      // P.I.S.
				If Eval(cPdBxaPr) $ cCodFerMs .Or. Eval(cPdBxaPr) $ cCodAdicMs .Or. Eval(cPdBxaPr) $ cCodUmTerMs
					nBx_InsMs += Eval(cValBxaPr) // I.N.S.S. do Proximo Mes
					nBx_FgtMs += Eval(cValBxaPr) // F.G.T.S. do Proximo Mes
					nBx_PisMs += Eval(cValBxaPr) // P.I.S.   do Proximo Mes
				EndIf
			Endif
         
			If Eval(cPdBxaPr) $ cCodSalV .Or. Eval(cPdBxaPr) $ cCodSalVMs
				nBx_SalVa += Eval(cValBxaPr)       //-- Baixa Media Salario Vacacional
				If Eval(cPdBxaPr) $ cCodSalVMs
					nBx_SalVMs += Eval(cValBxaPr)   //-- Media Sal. Vacac.Prox.Mes
				EndIf
			Endif

			//Ŀ
			// Abono Pecuniario											 
			//
			If Eval(cPdBxaPr) $ cCodAbono  .Or. Eval(cPdBxaPr) $ cCodAboMs
				If PosSrv(Eval(cPdBxaPr),TPR->PR_FILIAL,"RV_INSS") == "N"
					nValAboInss += Eval(cValBxaPr)
					If Eval(cPdBxaPr) $ cCodAboMs
					    If cTpBxFer != "2"
							nBx_InsMs -= Eval(cValBxaPr) // I.N.S.S. do Proximo Mes
						Else
							nBx_InsAbMs += Eval(cValBxaPr) // I.N.S.S. de Abono do Proximo Mes
						EndIf
					EndIf
				Endif
				If PosSrv(Eval(cPdBxaPr),TPR->PR_FILIAL,"RV_FGTS") == "N"
					nValAboFgts += Eval(cValBxaPr)
					If Eval(cPdBxaPr) $ cCodAboMs
					    If cTpBxFer != "2"
							nBx_FgtMs -= Eval(cValBxaPr) // F.G.T.S. do Proximo Mes
						Else
							nBx_FgtAbMs += Eval(cValBxaPr) // F.G.T.S. de Abono do Proximo Mes
						Endif
					EndIf
				Endif
				If PosSrv(Eval(cPdBxaPr),TPR->PR_FILIAL,"RV_PIS") == "N"
					nValAboPis += Eval(cValBxaPr)
					If Eval(cPdBxaPr) $ cCodAboMs
					    If cTpBxFer != "2"
							nBx_PisMs -= Eval(cValBxaPr) // P.I.S. do Proximo Mes
						Else
							nBx_PisAbMs += Eval(cValBxaPr) // P.I.S. de Abono do Proximo Mes
						Endif
					EndIf
				Endif
			Endif
		Endif
		(cArqBxaPr)->(dbSkip())
	Enddo

	If cPaisLoc == "BRA"
		nBx_Inss := NoRound((nBx_Inss - nValAboInss) * (nPercEmp+nPercTer+nPercAcTrab))
		nBx_Fgts := NoRound((nBx_Fgts - nValAboFgts) * nPercFgts )
		nBx_Pis  := NoRound((nBx_Pis  - nValAboPis)  * nPercPis )
	ElseIf cPaisLoc == "URU"
     	nBx_Inss := NoRound((nBx_Inss * nCSocial) / 100)
		nBx_Fgts := (nBx_Fgts * nAliqBse)/100
		nBx_Fgts += NoRound((nBx_Fgts * nBSeFixo) / 100)
		nBx_Pis  := 0
	ElseIf cPaisLoc == "ARG"
		nBx_Inss := fCalcEncLoc(nBx_Inss, aObraSoc)
		nBx_Fgts := fCalcEncLoc(nBx_Fgts, aJubila)
		nBx_Pis := fCalcEncLoc(nBx_Pis, aLey)
	Endif

	//Ŀ
	// Verifica se deve baixar pelas ferias do mes e mes seguinte	 |
	//
	If cTpBxFer == "2"
		//Ŀ
		// Calculo do INSS e FGTS do Proximo Mes                        |
		//
		nBx_InsMs := NoRound(nBx_InsMs * (nPercEmp+nPercTer+nPercAcTrab))
		nBx_FgtMs := NoRound(nBx_FgtMs * nPercFgts )
		nBx_PisMs := NoRound(nBx_PisMs * nPercPis )
		nBx_InsAbMs:= NoRound(nBx_InsAbMs * (nPercEmp+nPercTer+nPercAcTrab))
		nBx_FgtAbMs:= NoRound(nBx_FgtAbMs * nPercFgts )
		nBx_PisAbMs:= NoRound(nBx_PisAbMs * nPercPis )
		//Ŀ
		// Subtrai os valores do proximo mes do total do mes            |
		//
		If lFerMes
			nBx_Valor -= nBx_ValMs
			nBx_Adic  -= nBx_AdiMs
			nBx_UmTer -= nBx_UmTMs
			nBx_Inss  -= nBx_InsMs
			nBx_Inss  += nBx_InsAbMs
			nBx_Fgts  -= nBx_FgtMs
			nBx_Fgts  += nBx_FgtAbMs
			nBx_Pis   -= nBx_PisMs
			nBx_Pis   += nBx_PisAbMs
			nBx_SalVa -= nBx_SalVMs
			//Ŀ
			// Grava a diferenca que sera baixada no proximo mes            |
			// Condicao: Ja possuir ferias vencidas ou entao nao ter ferias |
			// vencidas e ter quitado o direito as ferias proporcionais.    |
			// neste caso deve deixar saldo atual a ser baixado no mes      |
			// seguinte.                                                    |
			//
			If aFerVenc[_Anter,_Dias] > 0 .Or. (aFerVenc[_Anter,_Dias] == 0 .And. lTrocouPer)
				aFerVenc[_Atual,_Prov] := nBx_ValMs
				aFerVenc[_Atual,_Adic] := nBx_AdiMs
				aFerVenc[_Atual,_1Ter] := nBx_UmTMs
				aFerVenc[_Atual,_INSS] := nBx_InsMs
				aFerVenc[_Atual,_FGTS] := nBx_FgtMs
				aFerVenc[_Atual,_PIS]  := nBx_PisMs
				If cPaisLoc == "URU"
					aFerVenc[_Atual,_SalV] := nBx_SalVMs
				Endif	
			Endif
		EndIf
	EndIf

	//Ŀ
	// Ponto de Entrada para Alterar valores de Inss e Fgts Baixas  |
	//
	If ExistBlock("GP070BIF")
		EXECBLOCK("GP070BIF",.F.,.F.)
	Endif

	//Ŀ
	// Grava no array os valores de baixa							 
	//
	aFerVenc[_BxFer,_Prov] := nBx_Valor
	aFerVenc[_BxFer,_Adic] := nBx_Adic
	aFerVenc[_BxFer,_1Ter] := nBx_UmTer
	aFerVenc[_BxFer,_INSS] := nBx_Inss
	aFerVenc[_BxFer,_FGTS] := nBx_Fgts
	aFerVenc[_BxFer,_PIS]  := nBx_Pis
	If cPaisLoc == "URU"
		aFerVenc[_BxFer,_SalV] := nBx_SalVa
	Endif	
Endif

If lExeQry
	(cArqBxaPr)->(dbCloseArea())
	dbSelectArea( cOldArq )
EndIf

RestArea( aArea )

Return (nBx_Valor+nBx_Adic+nBx_UmTer > 0)

/*


Ŀ
Funao	 fProv13o   Autor  Emerson Rosa de Souza	 Data  26.06.00 
Ĵ
Descriao  Calcula provisao de 13 Salario     						  
Ĵ
Sintaxe	  fProv13o(cAbatAci,cAbatDoe,nTipoMovMes,cAbatAdo)		      
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fProv13o(cAbatAci,cAbatDoe,nTipoMovMes,cAbatAdo)
Local lCongela13o := .F.
Local nAvosDed    := nAvosAf := nV_DFal13o := 0
Local dDtI13	  := CTOD("")
Local cTiposAfa   := ""
Local nB_FGTS	  := 0
Local nB_PIS 	  := 0
Local aAfast      := {}
Local nAvos_OQ
Local nAvos_B
Local nFaltas13	  := 0

//Ŀ
// Variaveis utilizadas nos pontos de entrada				     
//
Private nV_Valor := nV_Adic := nV_1Par13 := nV_Inss := nV_Fgts := nV_Pis := nTotMes := 0
Private nV_CSocial := nV_Bse := 0
Private nV_ObraSoc := nV_Ley := nV_Jubil := nP_ObraSoc := nP_Ley  := nP_Jubil := 0

//Ŀ
// Verifica se houve afastamento e se deve congelar			 
//
If nTipoMovMes != 6 .And. TPR->PR_SITFOLH == "A" .And. !TPR->PR_AFASFGT $ cAfastProv
	lCongela13o := .T.
EndIf
//Ŀ
// Verifica os tipos de afastamento que deverao ser tratados	 
//
If cAbatAci == "S" .And. ( cAbatAfas == "S" .Or. "O" $ cAbatAfas )
	cTiposAfa += "O*" //Acidente de Trabalho
EndIf
If cAbatDoe  == "S" .And. ( cAbatAfas == "S" .Or. "P" $ cAbatAfas )
	cTiposAfa += "P*" //Doenca
EndIf
If cPgSalMat == "N" .And. ( cAbatAfas == "S" .Or. "Q" $ cAbatAfas )
	cTiposAfa += "Q*" //Auxilio Maternidade
EndIf        
If cAbatAfas == "S" .Or.  ( "R" $ cAbatAfas )
	cTiposAfa += "R*" //Servico Militar
EndIf
If cAbatAfas == "S" .Or.  ( "X" $ cAbatAfas )
	cTiposAfa += "X*" //Licenca Nao Remunerada
EndIf
If cAbatAdo == "S" 
	cTiposAfa += "B*" //Auxilio Adocao
EndIf
If cAbatAfas == "S" .Or. "W" $ cAbatAfas
	cTiposAfa += "W*" //Mandato Sindical
EndIf
If cAbatAfas == "S" .Or. "1" $ cAbatAfas
	cTiposAfa += "1*" //Aposentadoria por invalidez
EndIf

If !Empty(cTiposAfa)
	nAvosAf := 0
	dDtI13  := CTOD("01/01/"+Str(Year(dDataRef),4), "DDMMYY")
	dDtDem	:= TPR->PR_DEMISSA
	
	dbSelectArea("TRP")
	TRP->( dbGoTop() )
	
	If !Empty( dDtDem ) .And. dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + "3" + "998" + Alltrim( Str( Year( dDtDem ), 4 ) ) + Alltrim( Strzero( Month( dDtDem ), 2 ) ) )
		nFaltas13 := TRP->RP_HORAS
	EndIf
	
	fRetAfas(dDtI13,If(lDemitido .And. lProvResc,dDtDem,dDataRef),cTiposAfa,@nAvosAf,,@aAfast,,,,lDemitido .And. lProvResc,nFaltas13)
	nAvosDed += nAvosAf
EndIf

//Ŀ
// Verifica tipo de movimentacao do funcionario				 
//
nTipoMovMes := If(lCongela13o, If(nTipoMovMes==_Cong_Fer,_Cong_F13,_Cong_13s), nTipoMovMes)

//Ŀ
// Verifica se deve pagar os Adicionais						 
//
If cCodAdt # Space(3) .And. PosSrv(cCodAdt,TPR->PR_FILIAL,'RV_INCORP') = 'S'
	nAdtServ := 0.00
Endif
If cCodIns # Space(3) .And. PosSrv(cCodIns,TPR->PR_FILIAL,'RV_INCORP') = 'S'
	nInsal := 0.00
Endif
If TPR->PR_PERICUL > 0.00 .And. PosSrv(aCodfol[36,1],TPR->PR_FILIAL,'RV_INCORP') = 'S'
	nPeric := 0.00
Endif

If ( !lDemitido .Or. lProvResc ) .And. !lCongela13o

	dbSelectArea("TRP")
	//Ŀ
	// Busca o Adicional Medias									 
	//
	If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT + "3" + "999" + "99MD")
		nV_Adic := TRP->RP_VALATU + fDsrHrsAtiv("3",aCodFol)
		//Ŀ
		// Calcula Peric./Insal Verba de Medias Que Tem Incidencia      
		//
		nMedPer := nMedIns := 0.00
		FMedPerIns(@nMedPer,@nMedIns,'3',nSalHora,nSalMin,aCodFol)
		nV_Adic += (nMedPer+nMedIns)
	Endif

	//Ŀ
	// Busca a 1 Parcela Antecipada								 
	//
	If lDesc1Parc
		//Ŀ
		// Pesquisa Adiantamento da 1 Parcela 13 Salario no acumulado    
		//
		If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT + "3" + "997" + "9598")
			nV_1Par13 := TRP->RP_VALATU
		Endif

		//Ŀ
		// Pesquisa Adiantamento da 1 Parcela 13 Salario no movimento    
		//
		If !lFechouMes
			dbSelectArea("SRC")
			If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[022,1])
				nV_1Par13 += SRC->RC_VALOR
			EndIf
			//Ŀ
			// Pesquisa a Diferenca do Adiantamento da 1 Parcela 13 Salario  
			//
			If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[163,1])
				nV_1Par13 += SRC->RC_VALOR
			EndIf
			dbSelectArea("TRP")
		Endif
	Endif

	//Ŀ
	// Busca as Faltas em Avos 									 
	//
	If dbSeek(TPR->PR_FILIAL + TPR->PR_MAT + "3" + "998" + "9998")
		nV_DFal13o := TRP->RP_HORAS
	Endif

	//Ŀ
	// Calcula os Avos do Funcionario								 
	//
	fAvos13(@nTotMes,If(lProvResc .And. lDemitido,dDataDem1,dDataRef),nV_DFal13o,nFaltas13)
	
	nTotMes := If( nTipoMovMes == 6 .And. TPR->PR_SITFOLH == "A" .And. !TPR->PR_AFASFGT $ cAfastProv, nTotMes - 1, nTotMes )

	//Ŀ
	// Abater Avos Afastados no Ano								 
	//
	nTotMes := If (nTotMes - nAvosDed > 0 , nTotMes - nAvosDed , 0)

	//Ŀ
	// Calculo do Mes												 
	//
	nV_Valor  := Round((( nSalMes * nTotMes ) / 12 ) , 2 )
	nV_Adic   += Round(((nPeric+nAdtServ+nInsal) * nTotMes) / 12 , 2 )

   If cPaisLoc == "PAR"
	   nV_Valor += Round((fLocCalAd13() / 12 ), 2 )
   Endif
	//Ŀ
	// Ponto de Entrada para ALterrar valores 13o. e  Adicional	 
	//
	If ExistBlock("GP090DEC")
		EXECBLOCK("GP090DEC",.F.,.F.)
	Endif
	
	//Ŀ
	// Base para calculo do FGTS e PIS							     
	//
	nB_FGTS := nV_Valor + nV_Adic
	nB_PIS  := nV_Valor + nV_Adic

	//Ŀ
	// Calcula FGTS com base total se afast. por auxilio maternidade
	//
	nAvos_OQ := 0
	nAvos_B	 := 0

    Aeval( aAfast ,{ |X| nAvos_OQ += If( X[5] $ "O*Q*B", X[1], 0 ) })
    Aeval( aAfast ,{ |X| nAvos_B += If( X[5] $ "B", X[1], 0 ) })

	If nAvos_OQ > 0
		nB_FGTS := NoRound( fRetDec(@nB_FGTS) / nTotMes * (nTotMes + nAvos_OQ), 2 )
	EndIf

   If !(cPaisLoc $ "URU|ARG")
		nV_Tot13  := ( nV_Valor + nV_Adic )
		nV_Tot13o := ( nV_Valor + nV_Adic ) - nV_1Par13

		If nAvos_B > 0
			//Quando for recolhimento da contribuicao patronal sobre a receita bruta e ter que efetuar a 
			//proporcionalizacao dos avos adquiridos antes e apos o inicio da desoneracao
			If (cRecFatEmp $ "S*M*C" .And. lDesAtiv) .Or. ( (cRecFatEmp == "oM" .Or. cRecFatEmp == "oS") .And. lOneAtiv)
				nInssAnt  := NoRound( ( ( nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ) ) / nTotMes  ) * nAvosAnt )
				nInssAnt  := NoRound( nInssAnt * ( nPercAnt + nPercTer + nPercAcTrab ) )
				nInssDes  := NoRound( ( ( nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ) ) / nTotMes  ) * ( nTotMes - nAvosAnt ) )
				nInssDes  := NoRound( nInssDes * ( nPerEmp13 + nPercTer + nPercAcTrab ) )
				nV_Inss   := NoRound( nInssAnt + nInssDes )
			//Caso contrario, apenas aplica o percentual no valor total do 13o.
			Else
				nV_Inss   := NoRound((nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ) )* ( nPerEmp13 + nPercTer + nPercAcTrab ) )
			EndIf
		Else
			//Quando for recolhimento da contribuicao patronal sobre a receita bruta e ter que efetuar a 
			//proporcionalizacao dos avos adquiridos antes e apos o inicio da desoneracao
			If (cRecFatEmp $ "S*M*C" .And. lDesAtiv) .Or. ( (cRecFatEmp == "oM" .Or. cRecFatEmp == "oS") .And. lOneAtiv)
				nInssAnt  := NoRound( ( nV_Tot13 / nTotMes ) * nAvosAnt )
				nInssAnt  := NoRound( nInssAnt * ( nPercAnt + nPercTer + nPercAcTrab ) )
				nInssDes  := NoRound( ( nV_Tot13 / nTotMes ) * ( nTotMes - nAvosAnt ) )
				nInssDes  := NoRound( nInssDes * ( nPerEmp13 + nPercTer + nPercAcTrab ) )
				nV_Inss   := NoRound( nInssAnt + nInssDes )
			//Caso contrario, apenas aplica o percentual no valor total do 13o.
			Else
				nV_Inss   := NoRound(nV_Tot13 * ( nPerEmp13 + nPercTer + nPercAcTrab ) )
			EndIf
		EndIf
	
		//Ŀ
		// Verifica se o Codigo de 1 Parcela esta com Incidencia	FGTS 
		//
		If PosSrv(aCodFol[022,1],TPR->PR_FILIAL,"RV_FGTS") == "S"
			nV_Fgts := NoRound((( nB_FGTS ) - nV_1Par13 ) * nPercFgts)
		Else
			nV_Fgts := NoRound(( nB_FGTS ) * nPercFgts)
		Endif

		//Ŀ
		// Verifica se o Codigo de 1 Parcela esta com Incidencia de PIS
		//
		If PosSrv(aCodFol[022,1],TPR->PR_FILIAL,"RV_PIS") == "S"
			nV_Pis := NoRound((( nB_PIS ) - nV_1Par13 ) * nPercPis)
		Else
			nV_Pis := NoRound(( nB_PIS ) * nPercPis)
		Endif
	ElseIf cPaisLoc == "URU"
		nV_CSocial := (nV_Valor * nCSocial) / 100
		nV_Bse	 := (nV_Valor * nAliqBse)/100
		nV_Bse    += (nV_Bse * nBSeFixo) / 100
	ElseIf cPaisLoc == "ARG
		nV_Tot13  := ( nV_Valor + nV_Adic )
		nV_ObraSoc := fCalcEncLoc(nV_Tot13, aObraSoc)
		nV_Jubil := fCalcEncLoc(nV_Tot13, aJubila)
		nV_Ley := fCalcEncLoc(nV_Tot13, aLey)
	Endif	

	//Ŀ
	// Ponto de Entrada para Alterar valores de Inss e Fgts do 13o. 
	//
	If ExistBlock("GP090DIF")
		EXECBLOCK("GP090DIF",.F.,.F.)
	Endif

	//Ŀ
	// Grava o valor da baixa da 1a. parcela se houver baixa da 2a. 
	//

	If a13Salar[_Bx13o,_Prov]+a13Salar[_Bx13o,_Adic] > 0
		a13Salar[_Bx13o,_1Par] := nV_1Par13
	EndIf
	

	//Ŀ
	// Se houver identifcadores de bxa de 13o, for mes 12 e         
	// funcionario nao for demitido, zerar os valores "Atual"       
	// para que o ajuste "No Mes" seja feito pela baixa             
	//
	If lBx13Pgt .And. Month(dDataRef) == 12 .and. !lDemitido
		If n14Salario > 0    
			a14Salar[_Atual,_Avos] := 0
			a14Salar[_Atual,_Prov] := ( nV_Valor  	* n14Salario )
			a14Salar[_Atual,_Adic] := ( nV_Adic   	* n14Salario )
			a14Salar[_Atual,_1Par] := 0
			a14Salar[_Atual,_INSS] := ( nV_Inss  	* n14Salario )
			a14Salar[_Atual,_FGTS] := ( nV_Fgts  	* n14Salario )
		Endif
		a13Salar[_Atual,_Avos] := 0
  		a13Salar[_Atual,_Prov] := 0
  		a13Salar[_Atual,_Adic] := 0
  		a13Salar[_Atual,_1Par] := 0
  		a13Salar[_Atual,_INSS] := 0
  		a13Salar[_Atual,_FGTS] := 0
  		a13Salar[_Atual,_PIS]  := 0

	Else
		//Ŀ
		// Grava os valores calculados no array (Subtraindo as baixas)  
		//
		a13Salar[_Atual,_Avos] := nTotMes   - a13Salar[_Bx13o,_Avos]
		a13Salar[_Atual,_Prov] := nV_Valor  - a13Salar[_Bx13o,_Prov]
		a13Salar[_Atual,_Adic] := nV_Adic   - a13Salar[_Bx13o,_Adic]
		a13Salar[_Atual,_1Par] := nV_1Par13 - a13Salar[_Bx13o,_1Par]

		If cPaisLoc == "BRA"
			a13Salar[_Atual,_INSS] := nV_Inss - a13Salar[_Bx13o,_INSS]
			a13Salar[_Atual,_FGTS] := nV_Fgts - a13Salar[_Bx13o,_FGTS]
			a13Salar[_Atual,_PIS]  := nV_Pis- a13Salar[_Bx13o,_PIS]
		ElseIf cPaisLoc == "URU"	
			a13Salar[_Atual,_INSS] := nV_CSocial - a13Salar[_Bx13o,_INSS]
			a13Salar[_Atual,_FGTS] := nV_Bse - a13Salar[_Bx13o,_FGTS]
			a13Salar[_Atual,_PIS]  := 0
		ElseIf cPaisLoc == "ARG"
			a13Salar[_Atual,_INSS] := nV_ObraSoc - a13Salar[_Bx13o,_INSS]
			a13Salar[_Atual,_FGTS] := nV_Jubil - a13Salar[_Bx13o,_FGTS]
			a13Salar[_Atual,_PIS]  := nV_Ley - a13Salar[_Bx13o,_PIS]
		Endif	
	EndIf

	//Ŀ
	// Calcula o 14o. salario a partir dos valores de 13o.          
	//
	If n14Salario > 0
		IF  !(lBx13Pgt .And. Month(dDataRef) == 12 .and. !lDemitido ) 
			a14Salar[_Atual,_Avos] := 0
			a14Salar[_Atual,_Prov] := ( a13Salar[_Atual,_Prov] * n14Salario )
			a14Salar[_Atual,_Adic] := ( a13Salar[_Atual,_Adic] * n14Salario )
			a14Salar[_Atual,_1Par] := 0
			a14Salar[_Atual,_INSS] := ( a13Salar[_Atual,_INSS] * n14Salario )
			a14Salar[_Atual,_FGTS] := ( a13Salar[_Atual,_FGTS] * n14Salario )
			a14Salar[_Atual,_PIS]  := ( a13Salar[_Atual,_PIS]  * n14Salario )
		EndIf 
	EndIf
//Ŀ
// Congela Provisao Para Funcionario Afastado  				 
//
Elseif !lDemitido .And. lCongela13o 
		If lBx13Pgt .And. Month(dDataRef) == 12  
			a13Salar[_Atual,_Avos] := 0
  			a13Salar[_Atual,_Prov] := 0
	  		a13Salar[_Atual,_Adic] := 0
  			a13Salar[_Atual,_1Par] := 0
  			a13Salar[_Atual,_INSS] := 0
	  		a13Salar[_Atual,_FGTS] := 0
  			a13Salar[_Atual,_PIS]  := 0

		Else
			a13Salar[_Atual,_Avos] := a13Salar[_Anter,_Avos]
			a13Salar[_Atual,_Prov] := a13Salar[_Anter,_Prov]
			a13Salar[_Atual,_Adic] := a13Salar[_Anter,_Adic]
			a13Salar[_Atual,_1Par] := a13Salar[_Anter,_1Par]
			a13Salar[_Atual,_INSS] := a13Salar[_Anter,_INSS]
			a13Salar[_Atual,_FGTS] := a13Salar[_Anter,_FGTS]
			a13Salar[_Atual,_PIS]  := a13Salar[_Anter,_PIS]      
		EndIf	

	If n14Salario > 0
		a14Salar[_Atual,_Avos] := a14Salar[_Anter,_Avos]
		a14Salar[_Atual,_Prov] := a14Salar[_Anter,_Prov]
		a14Salar[_Atual,_Adic] := a14Salar[_Anter,_Adic]
		a14Salar[_Atual,_1Par] := a14Salar[_Anter,_1Par]
		a14Salar[_Atual,_INSS] := a14Salar[_Anter,_INSS]
		a14Salar[_Atual,_FGTS] := a14Salar[_Anter,_FGTS]
		a14Salar[_Atual,_PIS]  := a14Salar[_Anter,_PIS]
	EndIf
Endif

Return

/*


Ŀ
Funao	 fBxa13oPro Autor  Emerson Rosa de Souza	 Data  26.06.00 
Ĵ
Descriao  Busca a Baixa de 13o Salario								  
Ĵ
Sintaxe	  fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13cDatBxa13,...)	  
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13,cDatBxa13,cPdBxa13,cValBxa13)

Local nBxa13o		:= nBxaAdi := nBxaIns := nBxaFgt := nBxaPis := 0
Local nBxContr		:= 0
Local nDif13		:= 0
Local nInssAnt		:= 0
Local nInssDes		:= 0
Local nTotMes		:= 0
Local nV_Inss		:= 0

Local cChaveBusca	:= ""
Local cDataBusca	:= If(lFechouMes,Left(DtoS(dDataRef),4)+"13",Strzero(Year(dDataRef),4))
Local cOldArq		:= cArqBxa13

Local lSomaAdic
Local lBxa13o		:= .F.
Local lExeQry		:= .F.

Local aArea			:= GetArea()

//Ŀ
// Define a chave de busca do arquivo (SRI ou SRD)    			 
//
If cArqBxa13 == "SRI"
	cChaveBusca := TPR->PR_FILIAL + TPR->PR_MAT
Else
	cChaveBusca := TPR->PR_FILIAL + TPR->PR_MAT + cDataBusca
EndIf

//Ŀ
//  Query para buscar informacoes do SRI ou SRD     			 
//
fQry13oBx(@cArqBxa13,,cDataBusca,,@lExeQry)

//Ŀ
// Baixa pelo Valor Pago no Mes ATual   						 
//
dbSelectArea( cArqBxa13 )

If lExeQry
	lBxa13o	:= !(cArqBxa13)->(Eof())
	fChgAlias(.F.,cArqBxa13,cOldArq,@cDatBxa13,@cFilBxa13,@cMatBxa13,@cPdBxa13,@cValBxa13)
Else
	lBxa13o := dbSeek( cChaveBusca )
EndIf

If lBxa13o
	While !(cArqBxa13)->(Eof()) .And. ( Eval(cFilBxa13) + Eval(cMatBxa13) == TPR->PR_FILIAL + TPR->PR_MAT ) .And.;
									( Eval(cDatBxa13) == cDataBusca )

		//Ŀ
		// Verifica se deve considerar diferenca de 13o Sal. negativa	 
		//
		If Eval(cPdBxa13) == aCodFol[028,1] .And. Eval(cValBxa13) < 0 .And. !lDif13Neg
			(cArqBxa13)->(dbSkip())
			Loop
		EndIf

		If Eval(cPdBxa13) $ cCod13o
			nBxa13o += Eval(cValBxa13)  //-- Baixa Valor do 13o Salario
		Endif
		
		If Eval(cPdBxa13) == aCodFol[024,1]//Parcela Final 13o. Sal
			If !lFechouMes
				nTotMes := (cArqBxa13)->RI_HORAS
			Else
				nTotMes := (cArqBxa13)->RD_HORAS
			EndIf
		EndIf

		//Ŀ
		// Se a verba atual nao estiver contida nos codigos de adicionais
		// verifica se e um provento e se incide media p/ que seja somada
		// na coluna de adicionais e utilizada para efetuar a baixa.	  
		//
		lSomaAdic := .F.
		If !(Eval(cPdBxa13) $ cCodAd13o)
		    PosSrv( Eval(cPdBxa13), TPR->PR_FILIAL )
		    If SRV->RV_TIPOCOD == "1" .And. !Empty(SRV->RV_MED13) .And. SRV->RV_MED13 # "N "
				lSomaAdic := .T.
		    EndIf
		    dbSelectArea( cArqBxa13 )
		EndIf

		If Eval(cPdBxa13) $ cCodAd13o .Or. lSomaAdic
			nBxaAdi += Eval(cValBxa13)  //-- Baixa de Adicionais
		Endif
		If Eval(cPdBxa13) $ cCod13o .Or. Eval(cPdBxa13) $ cCodAd13o .Or. lSomaAdic
			nBxaIns += Eval(cValBxa13)  //-- I.N.S.S.
			nBxaFgt += Eval(cValBxa13)  //-- F.G.T.S.
			nBxaPis += Eval(cValBxa13)  //-- P.I.S.
		Endif
		If Eval(cPdBxa13) == aCodFol[183,1]
			nBxaFgt -= If(lDesc1Parc,Eval(cValBxa13),0.00)  //-- Subtrai 1a parcela
		EndIf
		If Eval(cPdBxa13) $ cInss13o
			nBxContr += Eval(cValBxa13)  //-- Baixa Valor do INSS de13o Salario
		Endif
		(cArqBxa13)->(dbSkip())
	Enddo
    
	If lExeQry
		(cArqBxa13)->(dbCloseArea())
		dbSelectArea( cOldArq )
	EndIf

	//Ŀ
	// Busca a diferenca de 13o no movimento mensal - SRC		     
	//
	If !lFechouMes
		dbSelectArea( "SRC" )
		If lExeQry
			cArqBxa13 := "SRC"
			fQry13oBx(@cArqBxa13,,,)
			dbSelectArea( cArqBxa13 )
			If !Eof() .And. ( (cArqBxa13)->RC_VALOR > 0 .Or. lDif13Neg )
				nBxa13o += (cArqBxa13)->RC_VALOR    //-- Baixa Valor do 13o Salario
				nBxaIns += (cArqBxa13)->RC_VALOR    //-- I.N.S.S.
				nBxaFgt += (cArqBxa13)->RC_VALOR    //-- F.G.T.S.
				nBxaPis += (cArqBxa13)->RC_VALOR    //-- P.I.S.
				nDif13	+= (cArqBxa13)->RC_VALOR
			EndIf
			
			(cArqBxa13)->(dbCloseArea())
		Else
			If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[028,1] ) .Or.;
		       dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + aCodFol[348,1] ) 
				If SRC->RC_VALOR > 0 .Or. lDif13Neg
					nBxa13o += SRC->RC_VALOR    //-- Baixa Valor do 13o Salario
					nBxaIns += SRC->RC_VALOR    //-- I.N.S.S.
					nBxaFgt += SRC->RC_VALOR    //-- F.G.T.S.
					nBxaPis += SRC->RC_VALOR    //-- P.I.S.
					nDif13	+= SRC->RC_VALOR
				EndIf
			EndIf
		EndIf
	Else
		dbSelectArea( "SRD" )
		If lExeQry
			cArqBxa13 := "SRD"
			fQry13oBx(@cArqBxa13,dDataRef,,.T.)
			dbSelectArea( cArqBxa13 )
			If !Eof() .And. ( (cArqBxa13)->RD_VALOR > 0 .Or. lDif13Neg )
				nBxa13o += (cArqBxa13)->RD_VALOR    //-- Baixa Valor do 13o Salario
				nBxaIns += (cArqBxa13)->RD_VALOR    //-- I.N.S.S.
				nBxaFgt += (cArqBxa13)->RD_VALOR    //-- F.G.T.S.
				nBxaPis += (cArqBxa13)->RD_VALOR    //-- P.I.S.
				nDif13	+= (cArqBxa13)->RD_VALOR
			EndIf
			
			(cArqBxa13)->(dbCloseArea())
		Else
			If dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[028,1] ) .Or.;
		       dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + MesAno(dDataRef) + aCodFol[348,1] )
				If SRD->RD_VALOR > 0 .Or. lDif13Neg
					nBxa13o += SRD->RD_VALOR    //-- Baixa Valor do 13o Salario
					nBxaIns += SRD->RD_VALOR    //-- I.N.S.S.
					nBxaFgt += SRD->RD_VALOR    //-- F.G.T.S.
					nBxaPis += SRD->RD_VALOR    //-- P.I.S.
					nDif13	+= SRD->RD_VALOR
				EndIf
			EndIf
		EndIf
	EndIf
	
	//Ŀ
	// Grava no array os valores de baixa							 
	//
	If nBxa13o + nBxaAdi + nBxaIns + nBxaFgt + nBxaPis > 0
		a13Salar[_Bx13o,_Prov] := nBxa13o
		a13Salar[_Bx13o,_Adic] := nBxaAdi
		a13Salar[_Bx13o,_1Par] := 0.00 //-- Busca o valor da 1a.parcela atraves do GPEXMED
		If !(cPaisLoc $ "URU|ARG")
			If cPaisLoc == "BRA" .And. ( (cRecFatEmp $ "S*M*C" .And. lDesAtiv) .Or. ((cRecFatEmp == "oM" .Or. cRecFatEmp == "oS") .And. lOneAtiv) )
				nInssAnt  := NoRound( ( ( nBxaIns - nDif13 ) / nTotMes ) * nAvosAnt )
				nInssAnt  := NoRound( nInssAnt * ( nPercAnt + nPercTer + nPercAcTrab ) )
				nInssDes  := NoRound( ( ( nBxaIns - nDif13 ) / nTotMes ) * ( nTotMes - nAvosAnt ) )
				nInssDes  := NoRound( ( nInssDes + nDif13 ) * ( nPerEmp13 + nPercTer + nPercAcTrab ) )
				nV_Inss   := NoRound( nInssAnt + nInssDes )
				a13Salar[_Bx13o,_INSS] := nV_Inss
			Else
				a13Salar[_Bx13o,_INSS] := NoRound(nBxaIns * (nPerEmp13+nPercTer+nPercAcTrab))
			EndIf
			a13Salar[_Bx13o,_FGTS] := NoRound(nBxaFgt * nPercFgts )
			a13Salar[_Bx13o,_PIS]  := NoRound(nBxaPis * nPercPis )
		ElseIf cPaisLoc == "URU"
			a13Salar[_Bx13o,_INSS] := NoRound( nBxaIns * nCSocial / 100 )
			a13Salar[_Bx13o,_FGTS] := NoRound( nBxaFgt * nAliqBse /100 )
			a13Salar[_Bx13o,_FGTS] += NoRound( a13Salar[_Bx13o,_FGTS] * nBseFixo / 100)
			a13Salar[_Bx13o,_PIS]  := 0
		ElseIf cPaisLoc == "ARG"
			a13Salar[_Bx13o,_INSS] := fCalcEncLoc(nBxaIns, aObraSoc)
			a13Salar[_Bx13o,_FGTS] := fCalcEncLoc(nBxaFgt, aJubila)
			a13Salar[_Bx13o,_PIS]  := fCalcEncLoc(nBxaPis, aLey)
		Endif	
	Endif
Endif

If lExeQry .And. ( Select( cArqBxa13 ) > 0 )
	(cArqBxa13)->(dbCloseArea())
	dbSelectArea( cOldArq )
EndIf

RestArea( aArea )

Return ( nBxa13o + nBxaAdi + nBxaIns + nBxaFgt + nBxaPis > 0 )

/*


Ŀ
Funao	  GPM070Ok  Autor  Emerson R. de Souza	 Data  26.06.00 
Ĵ
Descriao  Grava os valores da provisao no arquivo SRT				  
Ĵ
Sintaxe	  GPM070Ok() 						                          
Ĵ
 Uso	 	  Generico 												  
ٱ
 */

Static Function GPM070Ok()
Return (MsgYesNo(OemToAnsi(STR0013),OemToAnsi(STR0012))) //"Confirma configurao dos parmetros?"###"ATENCAO"

/*


Ŀ
Funao	 fEncargEmp Autor  Emerson R. de Souza	 Data  26.06.00 
Ĵ
Descriao  Carrega variaveis para calculo dos encargos				  
Ĵ
Sintaxe	  fEncargEmp(nPercEmp, nPercTer, nPercAcTrab, nPercFgts)     
Ĵ
Parametros nPercEmp 	 - Percentual da Empresa					  
           nPerTerc  	 - Percentual de Terceiros					  
           nPercAcTrab   - Percentual de Acidente de Trabalho         
           nPercFgts 	 - Percentual para o FGTS funcionario  8%     
           nPercFgC 	 - Percentual para o FGTS contribuicao 0.5%   
           cRecFatEmp 	 - Recolhe contribuicao sobre faturamento     
           nPerEmp13 	 - Percentual da Empresa p/ 13o. Salario      
Ĵ
 Uso	 	  Generico 												  
ٱ
 */
Static Function fEncargEmp(nPercEmp, nPercTer, nPercAcTrab, nPercFgts, nPercFgC, cRecFatEmp, nPerEmp13)

//Se pais Brasil, verifica se calcula INSS para o funcionrio
If cPaisLoc == "BRA" .And. lINSSAut .And. TPR->PR_INSSAUT == "N"
	nPercEmp 	:= 0.00
	nPerEmp13 	:= 0.00
	nPercTer    := 0.00
	nPercAcTrab := 0.00
Else
	//Ŀ
	// Verificar Tipo de Contrato para Calculo de encargos 		 
	//
	cRecFatEmp	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[27, 1] , aInssEmp[27, 2])
	If cPaisLoc == "BRA" .And. (cRecFatEmp $ "S*M*C" .Or. (cAnoMes > cOnefol .And. !Empty(cOneFol) .And. SubStr(cOneFol,1,4) == SubStr(cAnoMes,1,4) ) )
		fPercEmp( @cRecFatEmp, @nPercEmp, @nPerEmp13 )
	Else
		nPercEmp	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
		nPerEmp13   := If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	EndIf
	nPercTer 	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[02, 1] , aInssEmp[02, 2])
	nPercAcTrab := If (TPR->PR_TPCONTR$ " *1", aInssEmp[03, 1] , aInssEmp[03, 2])

	//Ŀ
	// Busca o % Acid. Trab. no Funcionario/Centro Custo e Terceiros|
	//| no Centro de Custo                                           |
	//
	fBuscaAci(@nPercAcTrab,@nPercTer)
	
	//Ŀ
	// Deduzir o % de terceiros definido no parametro 15			 |
	//
	nPercTer -= fP15Terc(TPR->PR_CC,aGPSPer,"*")
EndIf
nPercFgts 	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[04, 1] , aInssEmp[04, 2])

//Ŀ
// Busca o % de FGTS do cadastro de funcionarios				 |
//
If Type("SRA->RA_PERFGTS") # "U" .And. SRA->RA_PERFGTS > 0.00
   nPercFgts := SRA->RA_PERFGTS / 100
Endif

//Ŀ
// Soma o % de FGTS referente a contribuicao de 0.5			 |
//
nPercFgts += nPercFgC

Return Nil

/*


Ŀ
Funao	 fBusCodBx  Autor  Emerson R. de Souza	 Data  27.06.00 
Ĵ
Descriao  Carrega Codigos de Ferias Para Baixa da Provisao		      
Ĵ
Sintaxe	  fBusCodBx()   											  
Ĵ
 Uso	 	  Generico 												  
ٱ
 */
Static Function fBusCodBx()

//Ŀ
// Codigos para baixa da provisao de ferias         			 |
//
cCodFer 	:= aCodFol[072,1] + "*" + aCodFol[074,1] + "*" + aCodFol[088,1] + "*" + aCodFol[094,1] + "*"
cCodUmTer	:= aCodFol[077,1] + "*" + aCodFol[079,1] + "*" + aCodFol[090,1] + "*" + aCodFol[095,1] + "*"
cCodFerMs	:= aCodFol[073,1] + "*" + aCodFol[089,1] + "*" + aCodFol[205,1] + "*" + aCodFol[207,1] + "*"
cCodUmTerMs := aCodFol[078,1] + "*" + aCodFol[091,1] + "*" + aCodFol[206,1] + "*" + aCodFol[208,1] + "*"
cCodAbono	:= aCodFol[074,1] + "*" + aCodFol[079,1] + "*" + aCodFol[094,1] + "*" + aCodFol[095,1] + "*"
cCodAboMs	:= aCodFol[205,1] + "*" + aCodFol[207,1] + "*" + aCodFol[206,1] + "*" + aCodFol[208,1] + "*"
cCodAdicMs  := aCodFol[076,1] + "*" + aCodFol[081,1] + "*" + aCodFol[083,1] + "*" + aCodFol[085,1] + "*" +;
               aCodFol[093,1] + "*" + aCodFol[097,1] + "*" + aCodFol[099,1] + "*" + aCodFol[344,1] + "*" +;
			   aCodFol[346,1] + "*" + aCodFol[637,1]
cCodAdFer	:= aCodFol[075,1] + "*" + aCodFol[080,1] + "*" + aCodFol[082,1] + "*" + aCodFol[084,1] + "*" +;
			   aCodFol[092,1] + "*" + aCodFol[096,1] + "*" + aCodFol[098,1] + "*" + aCodFol[343,1] + "*" +;
			   aCodFol[345,1] + "*" + aCodFol[636,1]
cCodSalV    := aCodFol[361,1]
cCodSalVMs  := aCodFol[362,1]
//Ŀ
// Codigos para baixa da provisao de 13o. Salario     			 |
//
cCod13o	  := aCodFol[024,1] + "*" + aCodFol[028,1] + "*" + aCodFol[348,1]
cCodAd13o := aCodFol[001,1] + "*" + aCodFol[002,1] + "*" + aCodFol[003,1] + "*" + aCodFol[004,1] + "*"+;
		     aCodFol[005,1] + "*" + aCodFol[036,1] + "*" + aCodFol[037,1] + "*" + aCodFol[038,1] + "*"+;
			 aCodFol[039,1] + "*" + aCodFol[123,1] + "*" + aCodFol[124,1] + "*" + aCodFol[181,1] + "*"+;
			 aCodFol[182,1]
cInss13o  := aCodFol[148,1]
If cPaisLoc $ "ARG|URU"
	cCod13o := If(Month(dDataRef)==nFec131,aCodFol[022,1],aCodFol[024,1])+"*"+aCodFol[028,1]+"*"+aCodFol[348,1] 
Endif
//Ŀ
// Ponto de Entrada para acrescentar verbas aos codigos padrao. |
//
If ExistBlock("GP070COD")
	ExecBlock("GP070COD",.F.,.F.)
Endif

Return Nil

/*


Ŀ
Funao	 fLimpaArra Autor  Emerson R. de Souza	 Data  27.06.00 
Ĵ
Descriao  Limpa o array de provisao para calculo					  
Ĵ
Sintaxe	  fLimpaArray(aProvisao)									  
Ĵ
Parametros aProvisao	 - Array que sera zerado					  
           uConteudo	 - Conteudo que sera gravado no array		  
Ĵ
 Uso	 	  Generico 												  
ٱ
 */
Function fLimpaArray(aProvisao,uConteudo,cNaoLimpar,nLinProv)
Local nCnt1, nCnt2

cNaoLimpar := If(cNaoLimpar == Nil, "", cNaoLimpar)

DEFAULT nLinProv := _Linhas

For nCnt1 := 1 To nLinProv
	If !Str(nCnt1,1) $ cNaoLimpar
		For nCnt2 := 1 To _Colunas
			aProvisao[nCnt1,nCnt2] := uConteudo
		Next nCnt2
	EndIf	
Next nCnt1

Return Nil

/*


Ŀ
Funao	 fIdentProv Autor  Emerson R. de Souza	 Data  27.06.00 
Ĵ
Descriao  Carrega Codigos de Provisao Para Lancamentos no SRT	      
Ĵ
Sintaxe	  fIdentProv(aVerba,aCodFol)					     		  
Ĵ
 Uso	 	  Generico 												  
ٱ
 */
Function fIdentProv(aVerba,aCodFol)

aVerba := {}

If cPaisLoc == "BRA"
	Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias	
  	Aadd(aVerba, { _FerVenc, _Atual, _1Ter, aCodFol[255,1], "255" }) // Um Terco Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Atual, _INSS, aCodFol[131,1], "131" }) // INSS Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _FGTS, aCodFol[132,1], "132" }) // FGTS Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _PIS,  aCodFol[416,1], "416" }) // PIS Provisao de Ferias

	Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _Adic, aCodFol[256,1], "256" }) // Correcao Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _1Ter, aCodFol[257,1], "257" }) // Correcao Um Terco Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _INSS, aCodFol[134,1], "134" }) // Correcao INSS Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _FGTS, aCodFol[135,1], "135" }) // Correcao FGTS Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _PIS,  aCodFol[417,1], "417" }) // Correcao PIS Provisao de Ferias

	Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _1Ter, aCodFol[259,1], "259" }) // Baixa Um Terco Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _INSS, aCodFol[234,1], "234" }) // Baixa Inss Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _FGTS, aCodFol[235,1], "235" }) // Baixa Fgts Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _PIS,  aCodFol[418,1], "418" }) // Baixa PIS Provisao Ferias
	
	Aadd(aVerba, { _FerVenc, _BxTrf, _Prov, aCodFol[239,1], "239" }) // Baixa Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _Adic, aCodFol[260,1], "260" }) // Baixa Adicional Provisao de Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _1Ter, aCodFol[261,1], "261" }) // Baixa Um Terco Provisao de Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _INSS, aCodFol[240,1], "240" }) // Baixa Inss Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _FGTS, aCodFol[241,1], "241" }) // Baixa Fgts Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _PIS,  aCodFol[419,1], "419" }) // Baixa PIS Provisao Ferias Transferidos
	                                                
	Aadd(aVerba, { _FerVenc, _BxRes, _Prov, aCodFol[262,1], "262" }) // Baixa Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _Adic, aCodFol[263,1], "263" }) // Baixa Adicional Provisao de Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _1Ter, aCodFol[264,1], "264" }) // Baixa Um Terco Provisao de Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _INSS, aCodFol[265,1], "265" }) // Baixa Inss Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _FGTS, aCodFol[266,1], "266" }) // Baixa Fgts Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _PIS,  aCodFol[420,1], "420" }) // Baixa PIS Provisao Ferias Rescisao

	Aadd(aVerba, { _FerVMes, _Atual, _Prov, aCodFol[960,1], "960" }) // Prov. Ms Frias
	Aadd(aVerba, { _FerVMes, _Atual, _Adic, aCodFol[962,1], "962" }) // Prov. Ms Adicional de Frias
	Aadd(aVerba, { _FerVMes, _Atual, _1Ter, aCodFol[961,1], "961" }) // Prov. Ms 1/3 de Frias
	Aadd(aVerba, { _FerVMes, _Atual, _INSS, aCodFol[963,1], "963" }) // Prov. Ms INSS de Frias
	Aadd(aVerba, { _FerVMes, _Atual, _FGTS, aCodFol[964,1], "964" }) // Prov. Ms FGTS de Frias
	Aadd(aVerba, { _FerVMes, _Atual, _PIS,  aCodFol[965,1], "965" }) // Prov. Ms PIS de Frias

ElseIf cPaisLoc == "CHI"
	Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _Adic, aCodFol[256,1], "256" }) // Correcao Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _1Ter, aCodFol[257,1], "257" }) // Correcao Um Terco Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _1Ter, aCodFol[259,1], "259" }) // Baixa Um Terco Provisao de Ferias

ElseIf cPaisLoc == "PAR"
	Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _Adic, aCodFol[256,1], "256" }) // Correcao Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias

ElseIf cPaisLoc == "URU"
	Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
  	Aadd(aVerba, { _FerVenc, _Atual, _1Ter, aCodFol[255,1], "255" }) // Um Terco Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Atual, _INSS, aCodFol[383,1], "383" }) // C.Social Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _FGTS, aCodFol[384,1], "384" }) // BSE Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _SalV, aCodFol[405,1], "405" }) // Adicional Sal.Vac.Provisao de Ferias	

	Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _1Ter, aCodFol[257,1], "257" }) // Correcao Um Terco Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _INSS, aCodFol[387,1], "387" }) // Correcao C.Social Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _FGTS, aCodFol[388,1], "388" }) // Correcao BSE Provisao de Ferias

	Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _1Ter, aCodFol[259,1], "259" }) // Baixa Um Terco Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _INSS, aCodFol[385,1], "385" }) // Baixa C.Social Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxFer, _FGTS, aCodFol[386,1], "386" }) // Baixa BSE Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxFer, _SalV, aCodFol[406,1], "406" }) // Baixa Adicional Sal.Vac. Provisao de Ferias
ElseIf cPaisLoc == "ARG
	Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias	
	Aadd(aVerba, { _FerVenc, _Atual, _INSS, aCodFol[679,1], "679" }) // Obras Socias Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _FGTS, aCodFol[680,1], "680" }) // Jubilacion  de Ferias
	Aadd(aVerba, { _FerVenc, _Atual, _PIS,  aCodFol[681,1], "681" }) // Ley 19032 Provisao de Ferias	

	Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _Adic, aCodFol[256,1], "256" }) // Correcao Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _INSS, aCodFol[682,1], "682" }) // Correcao Obr.Soc. Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _FGTS, aCodFol[683,1], "683" }) // Correcao Jub. Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _Corre, _PIS,  aCodFol[684,1], "684" }) // Correcao Ley Provisao de Ferias

	Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _INSS, aCodFol[685,1], "685" }) // Baixa Obr.Soc. Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _FGTS, aCodFol[686,1], "686" }) // Baixa Jub. Provisao Ferias
	Aadd(aVerba, { _FerVenc, _BxFer, _PIS,  aCodFol[687,1], "687" }) // Baixa Ley Provisao Ferias

	Aadd(aVerba, { _FerVenc, _BxTrf, _Prov, aCodFol[239,1], "239" }) // Baixa Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _Adic, aCodFol[260,1], "260" }) // Baixa Adicional Provisao de Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _INSS, aCodFol[688,1], "688" }) // Baixa Ob.Soc. Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _FGTS, aCodFol[689,1], "689" }) // Baixa Jub. Provisao Ferias Transferidos
	Aadd(aVerba, { _FerVenc, _BxTrf, _PIS,  aCodFol[690,1], "690" }) // Baixa Ley Provisao Ferias Transferidos

	Aadd(aVerba, { _FerVenc, _BxRes, _Prov, aCodFol[262,1], "262" }) // Baixa Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _Adic, aCodFol[263,1], "263" }) // Baixa Adicional Provisao de Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _INSS, aCodFol[691,1], "691" }) // Baixa Ob.Soc. Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _FGTS, aCodFol[692,1], "692" }) // Baixa Jub. Provisao Ferias Rescisao
	Aadd(aVerba, { _FerVenc, _BxRes, _PIS,  aCodFol[693,1], "693" }) // Baixa Ley Provisao Ferias Rescisao
EndIf

If cPaisLoc == "BRA"
	Aadd(aVerba, { _13Salar, _Atual, _Prov, aCodFol[136,1], "136" }) // Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _Adic, aCodFol[267,1], "267" }) // Adicional Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao
	Aadd(aVerba, { _13Salar, _Atual, _INSS, aCodFol[137,1], "137" }) // INSS Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _FGTS, aCodFol[138,1], "138" }) // FGTS Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _PIS,  aCodFol[421,1], "421" }) // PIS Provisao 13o Salario

	Aadd(aVerba, { _13Salar, _Corre, _Prov, aCodFol[139,1], "139" }) // Correcao Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _Adic, aCodFol[269,1], "269" }) // Correcao Adicional Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _INSS, aCodFol[140,1], "140" }) // Correcao INSS Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _FGTS, aCodFol[141,1], "141" }) // Correcao FGTS Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _PIS,  aCodFol[422,1], "422" }) // Correcao PIS Provisao 13o Salario

	Aadd(aVerba, { _13Salar, _Bx13o, _Prov, aCodFol[332,1], "332" }) // Baixa Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _Adic, aCodFol[333,1], "333" }) // Baixa Adicional Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _1Par, aCodFol[334,1], "334" }) // Baixa Antecipacao 1a Parcela do 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _INSS, aCodFol[335,1], "335" }) // Baixa Inss Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _FGTS, aCodFol[336,1], "336" }) // Baixa Fgts Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _PIS,  aCodFol[423,1], "423" }) // Baixa PIS Provisao 13o Salario

	Aadd(aVerba, { _13Salar, _BxTrf, _Prov, aCodFol[270,1], "270" }) // Baixa Provisao 13o Salario Transferido
	Aadd(aVerba, { _13Salar, _BxTrf, _Adic, aCodFol[271,1], "271" }) // Baixa Adicional Provisao de 13o Salario Transferido
	Aadd(aVerba, { _13Salar, _BxTrf, _INSS, aCodFol[272,1], "272" }) // Baixa Inss Provisao 13o Salario Transferido
	Aadd(aVerba, { _13Salar, _BxTrf, _FGTS, aCodFol[273,1], "273" }) // Baixa Fgts Provisao 13o Salario Transferido
	Aadd(aVerba, { _13Salar, _BxTrf, _PIS,  aCodFol[424,1], "424" }) // Baixa PIS Provisao 13o Salario Transferido

	Aadd(aVerba, { _13Salar, _BxRes, _Prov, aCodFol[274,1], "274" }) // Baixa Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _Adic, aCodFol[275,1], "275" }) // Baixa Adicional Provisao de 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _INSS, aCodFol[276,1], "276" }) // Baixa Inss Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _FGTS, aCodFol[277,1], "277" }) // Baixa Fgts Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _PIS,  aCodFol[425,1], "425" }) // Baixa PIS Provisao 13o Salario Rescisao

	Aadd(aVerba, { _13SVMes, _Atual, _Prov, aCodFol[966,1], "966" }) // 966 - Prov. Ms 13 Salrio
	Aadd(aVerba, { _13SVMes, _Atual, _Adic, aCodFol[967,1], "967" }) // 967 - Prov. Ms Adcional de 13 Salrio
	Aadd(aVerba, { _13SVMes, _Atual, _1Par, aCodFol[968,1], "968" }) // 968 - 1a. Parcela 13o Provisao
	Aadd(aVerba, { _13SVMes, _Atual, _INSS, aCodFol[969,1], "969" }) // 969 - Prov. Ms INSS de 13 Salrio
	Aadd(aVerba, { _13SVMes, _Atual, _FGTS, aCodFol[970,1], "970" }) // 970 - Prov. Ms FGTS de 13 Salrio
	Aadd(aVerba, { _13SVMes, _Atual, _PIS,  aCodFol[971,1], "971" }) // 971 - Prov. Ms PIS de 13 Salrio

	Aadd(aVerba, { _14Salar, _Atual, _Prov, aCodFol[142,1], "142" }) // Provisao de 14o Salario
	Aadd(aVerba, { _14Salar, _Atual, _Adic, aCodFol[278,1], "278" }) // Adicional Provisao de 14o Salario
	Aadd(aVerba, { _14Salar, _Atual, _INSS, aCodFol[143,1], "143" }) // INSS Provisao 14o Salario
	Aadd(aVerba, { _14Salar, _Atual, _FGTS, aCodFol[144,1], "144" }) // FGTS Provisao 14o Salario
	Aadd(aVerba, { _14Salar, _Atual, _PIS,  aCodFol[426,1], "426" }) // PIS Provisao 14o Salario
	
	Aadd(aVerba, { _14Salar, _Corre, _Prov, aCodFol[145,1], "145" }) // Correcao Provisao 14o Salario
	Aadd(aVerba, { _14Salar, _Corre, _Adic, aCodFol[279,1], "279" }) // Correcao Adicional Provisao de 14o Salario
	Aadd(aVerba, { _14Salar, _Corre, _INSS, aCodFol[146,1], "146" }) // Correcao INSS Provisao 14o Salario
	Aadd(aVerba, { _14Salar, _Corre, _FGTS, aCodFol[147,1], "147" }) // Correcao FGTS Provisao 14o Salario
	Aadd(aVerba, { _14Salar, _Corre, _PIS,  aCodFol[427,1], "427" }) // Correcao PIS Provisao 14o Salario
	
	Aadd(aVerba, { _14Salar, _BxTrf, _Prov, aCodFol[280,1], "280" }) // Baixa Provisao 14o Salario Transferido
	Aadd(aVerba, { _14Salar, _BxTrf, _Adic, aCodFol[281,1], "281" }) // Baixa Adicional Provisao de 14o Salario Transferido
	Aadd(aVerba, { _14Salar, _BxTrf, _INSS, aCodFol[282,1], "282" }) // Baixa Inss Provisao 14o Salario Transferido
	Aadd(aVerba, { _14Salar, _BxTrf, _FGTS, aCodFol[283,1], "283" }) // Baixa Fgts Provisao 14o Salario Transferido
	Aadd(aVerba, { _14Salar, _BxTrf, _PIS,  aCodFol[428,1], "428" }) // Baixa PIS Provisao 14o Salario Transferido

	Aadd(aVerba, { _14Salar, _BxRes, _Prov, aCodFol[284,1], "284" }) // Baixa Provisao 14o Salario Rescisao
	Aadd(aVerba, { _14Salar, _BxRes, _Adic, aCodFol[285,1], "285" }) // Baixa Adicional Provisao de 14o Salario Rescisao
	Aadd(aVerba, { _14Salar, _BxRes, _INSS, aCodFol[286,1], "286" }) // Baixa Inss Provisao 14o Salario Rescisao
	Aadd(aVerba, { _14Salar, _BxRes, _FGTS, aCodFol[287,1], "287" }) // Baixa Fgts Provisao 14o Salario Rescisao
	Aadd(aVerba, { _14Salar, _BxRes, _PIS,  aCodFol[429,1], "429" }) // Baixa PIS Provisao 14o Salario Rescisao
ElseIf cPaisLoc =="PAR"
	Aadd(aVerba, { _13Salar, _Atual, _Prov, aCodFol[136,1], "136" }) // Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _Adic, aCodFol[267,1], "267" }) // Adicional Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao
	Aadd(aVerba, { _13Salar, _Corre, _Prov, aCodFol[139,1], "139" }) // Correcao Provisao 13o Salario
	Aadd(aVerba, { _14Salar, _Atual, _Prov, aCodFol[142,1], "142" }) // Provisao de 14o Salario
	Aadd(aVerba, { _14Salar, _Corre, _Prov, aCodFol[145,1], "145" }) // Correcao Provisao 14o Salario
ElseIf cPaisLoc == "URU
	Aadd(aVerba, { _13Salar, _Atual, _Prov, aCodFol[136,1], "136" }) // Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao
	Aadd(aVerba, { _13Salar, _Atual, _INSS, aCodFol[389,1], "389" }) // C.Social Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _FGTS, aCodFol[390,1], "390" }) // BSE Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _Prov, aCodFol[139,1], "139" }) // Correcao Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _INSS, aCodFol[393,1], "393" }) // Correcao C.Social Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _FGTS, aCodFol[394,1], "394" }) // Correcao BSE Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _Prov, aCodFol[332,1], "332" }) // Baixa Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _1Par, aCodFol[334,1], "334" }) // Baixa Antecipacao 1a Parcela do 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _INSS, aCodFol[391,1], "391" }) // Baixa C.Social Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _FGTS, aCodFol[392,1], "392" }) // Baixa BSE Provisao 13o Salario    
ElseIf cPaisLoc == "ARG"
	Aadd(aVerba, { _13Salar, _Atual, _Prov, aCodFol[136,1], "136" }) // Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao
	Aadd(aVerba, { _13Salar, _Atual, _INSS, aCodFol[694,1], "694" }) // Obras Socias Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _FGTS, aCodFol[695,1], "695" }) // Jubilacion  de 13o Salario
	Aadd(aVerba, { _13Salar, _Atual, _PIS,  aCodFol[696,1], "696" }) // Ley 19032 Provisao de 13o Salario	

	Aadd(aVerba, { _13Salar, _Corre, _Prov, aCodFol[139,1], "139" }) // Correcao Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _INSS, aCodFol[697,1], "697" }) // Correcao Obr.Soc. Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _FGTS, aCodFol[698,1], "698" }) // Correcao Jub. Provisao de 13o Salario
	Aadd(aVerba, { _13Salar, _Corre, _PIS,  aCodFol[699,1], "699" }) // Correcao Ley Provisao de 13o Salario

	Aadd(aVerba, { _13Salar, _Bx13o, _Prov, aCodFol[332,1], "332" }) // Baixa Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _1Par, aCodFol[334,1], "334" }) // Baixa Antecipacao 1a Parcela do 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _INSS, aCodFol[700,1], "700" }) // Baixa Obr.Soc. Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _FGTS, aCodFol[701,1], "701" }) // Baixa Jub. Provisao 13o Salario
	Aadd(aVerba, { _13Salar, _Bx13o, _PIS,  aCodFol[702,1], "702" }) // Baixa Ley Provisao 13o Salario

	Aadd(aVerba, { _13Salar, _BxTrf, _Prov, aCodFol[270,1], "270" }) // Baixa Provisao 13o Salario Transferido
	Aadd(aVerba, { _13Salar, _BxTrf, _INSS, aCodFol[703,1], "703" }) // Baixa Ob.Soc. Provisao 13o Salario Transferidos
	Aadd(aVerba, { _13Salar, _BxTrf, _FGTS, aCodFol[704,1], "704" }) // Baixa Jub. Provisao 13o Salario Transferidos
	Aadd(aVerba, { _13Salar, _BxTrf, _PIS,  aCodFol[705,1], "705" }) // Baixa Ley Provisao 13o Salario Transferidos

	Aadd(aVerba, { _13Salar, _BxRes, _Prov, aCodFol[274,1], "274" }) // Baixa Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _INSS, aCodFol[706,1], "706" }) // Baixa Ob.Soc. Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _FGTS, aCodFol[707,1], "707" }) // Baixa Jub. Provisao 13o Salario Rescisao
	Aadd(aVerba, { _13Salar, _BxRes, _PIS,  aCodFol[708,1], "708" }) // Baixa Ley Provisao 13o Salario Rescisao
Endif

Return Nil

/*


Ŀ
Funao	 fBusCabSRT Autor  Emerson R. de Souza	 Data  21.06.00 
Ĵ
Descriao  Busca informacoes de cabecalho no SRT        			  
Ĵ
Sintaxe	  fBusCabSRT(dDtBusca,aCabProv)					          
Ĵ
Parametros 															  
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function fBusCabSRT(dDtBusca,aCabProv)
Local lRet, cAlias := ALIAS()
Local cCusto	:= ""
Local cCC 	:= ""

If Type("lItemClVl") == "U"
	lItemClVl   := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13"
Endif

aCabProv := Array(11) 
If !Empty(cTpRtProv)
	dbSelectArea( "RHT" )
	cCusto	:= TPR->PR_CCMVTO
	If lItemClVl
		cItem	:= TPR->PR_ITMMVTO 
		cClvl	:= TPR->PR_CLVMVTO
	EndIf
	cCC :=  cCusto
Else 
	dbSelectArea( "SRT" )
	cCusto	:= TPR->PR_CC
	If lItemClVl
		cItem	:= TPR->PR_ITEM 
		cClvl	:= TPR->PR_CLVL
	EndIf
	cCC :=  cCusto
Endif
If lItemClvl
	dbSetOrder(4)
	lRet := dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cCusto + cItem + cClvl + MesAno(dDtBusca) )
Else
	dbSetOrder(1)
	lRet := dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cCusto + MesAno(dDtBusca) )
EndIf	

If Empty(cTpRtProv) .Or. (  !Empty(cTpRtProv)  .and. !lRet )

	// Para os movimentos anteriores dever utilizar as informaes do cabealho do mes corrente //
	If  !Empty(cTpRtProv)  .and. !lRet

		dbSelectArea( "SRT" )
		cCusto	:= TPR->PR_CC
		If lItemClvl
			dbSetOrder(4)
			lRet := dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cCusto + cItem + cClvl + MesAno(dDtBusca) )
		Else
			dbSetOrder(1)
			lRet := dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + cCusto + MesAno(dDtBusca) )
		EndIf	

	EndIf

	aCabProv[_DatCalc] 	:=  SRT->RT_DATACAL
	aCabProv[_CentroC] 	:=  cCC
	aCabProv[_DBsProv] 	:= SRT->RT_DATABAS
	aCabProv[_DFerVen] 	:= SRT->RT_DFERVEN
	aCabProv[_DFerPro] 	:= SRT->RT_DFERPRO
	aCabProv[_DFalVen] 	:= SRT->RT_DFALVEN
	aCabProv[_DFalPro] 	:= SRT->RT_DFALPRO
	aCabProv[_DFerAnt] 	:= SRT->RT_DFERANT
	aCabProv[_Avos13S] 	:= SRT->RT_AVOS13S
	aCabProv[_MovProv] 	:= SRT->RT_TIPMOVI
	aCabProv[_SalProv] 	:= SRT->RT_SALARIO
	    
	If !Empty(cTpRtProv)  .and. !lRet
		dbSelectArea( "RHT" )
		cCusto	:= TPR->PR_CCMVTO
	EndIf
Else
	aCabProv[_DatCalc] 	:= RHT->RHT_DTCALC
	aCabProv[_CentroC] 	:= RHT->RHT_CC
	aCabProv[_DBsProv] 	:= RHT->RHT_DTBASE
	aCabProv[_DFerVen] 	:= RHT->RHT_DFERVE
	aCabProv[_DFerPro] 	:= RHT->RHT_DFERPR
	aCabProv[_DFalVen] 	:= RHT->RHT_DFALVE
	aCabProv[_DFalPro] 	:= RHT->RHT_DFALPR
	aCabProv[_DFerAnt] 	:= RHT->RHT_DFERAN
	aCabProv[_Avos13S] 	:= RHT->RHT_AVOS13
	aCabProv[_MovProv] 	:= RHT->RHT_TIPMOV
	aCabProv[_SalProv] 	:= RHT->RHT_SALAR
EndIf

dbSelectArea( cAlias )

//Para o clculo por rateio dever considerar os meses que no possui movimento para demonstrar a totalizao - mes = 0  e anterior com valores. 
//O Filtro esta definido na query da gerao do arquivo TPR
If !Empty(cTpRtProv)
	lRet := .T.
EndIf

Return lRet

/*


Ŀ
Funao	 fBusDetSRT| Autor  Emerson R. de Souza	 Data  21.06.00 
Ĵ
Descriao  Busca os valores da provisao no arquivo SRT				  
Ĵ
Sintaxe	  fBusDetSRT(aProvisao,aRecnos,aVerba,aTransf,dDataRef)	  
Ĵ
Parametros aProvisao	 - Array que contera os valores da provisao	  
           aRecnos  	 - Array onde sera gravado os registros       
           aVerba   	 - Verbas de Ferias / 13 Sal / 14 Sal       
           aTransf  	 - Funcionarios Transferidos no mes           
           dDataRef 	 - Data de referencia para busca dos valores  
           nTipoProv	 - Tipo de provisao a buscar (Venc,Prop,13)  |
           lTrataTrf	 - Indica se deve tratar os transferidos      |
           lCalcula  	 - Indica se deve calcular o valor do mes     |
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function fBusDetSRT(aProvisao,aRecnos,aVerba,aTransf,dDataRef,nTipoProv,lTrataTrf,lCalcula,lSoMes)
Local cBusMesAnt,cBusMesAtu,nCnt1
Local nTpMov      := 0
Local nPosTrf	  := 0
Local nPosVerba	  := 0
Local cAlias      := ALIAS()
Local cAliasSRT   := "SRT"
Local cAnoMesAnt  := MesAno( dDataRef - Day(dDataRef) )
Local cAnoMesAtu  := MesAno( dDataRef )
Local cOrdemBusca := &("{ || SRT->RT_FILIAL + SRT->RT_MAT + SRT->RT_CC + MesAno(SRT->RT_DATACAL) }")
Local lTrfEmpAmes := .F.
Local lAdiant13	  := .F.
Local cAliasArq	  := If (Empty(cTpRtProv), "SRT", "RHT")
Local cTpProvMes  := ""
Local cEmpQryAnt  := cEmpAnt
Local cModo		  := ""
Local cSvEmpAnt   := ""

Default lSoMes := .F.

If Type( "lProvResc" ) == "U"
	lProvResc := ( SuperGetMv( "MV_PROVRES",,"N" ) == "S" ) //-- Indica se devera provisionar no mes da rescisao
EndIf

If Type( "lTrfAMES" ) == "U"
	cTrfAMES     := ( SuperGetMv( "MV_TRFAMES",, Space(6) ) ) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
	lTrfAMES     := ( !Empty(cTrfAMES) .And. MesAno( dDataRef ) >= cTrfAMES )
EndIf

If Type( "lTrfSld" ) == "U" .Or. lTrfSld
	lTrfSld := .F.
EndIf

aRecnos    := If(aRecnos   == Nil, Array(_Linhas,_Colunas), aRecnos)
lCalcula   := If(lCalcula  == Nil, .F., lCalcula)

If !Empty(cTpRtProv)
	If lItemClVl
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + (cAliasSRT)->RHT_ITEM + (cAliasSRT)->RHT_CLVL + MesAno((cAliasSRT)->RHT_DTCALC) }")   
	Else
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + MesAno((cAliasSRT)->RHT_DTCALC) }")    
	EndIf	
	cTpProvMes := If(lFerias, "'1','2'", "'3'")
ElseIf lItemClVl
	cOrdemBusca := &("{ || SRT->RT_FILIAL + SRT->RT_MAT + SRT->RT_CC + SRT->RT_ITEM + SRT->RT_CLVL + MesAno(SRT->RT_DATACAL) }")
Endif

If !lSoMes

	If !lProvResc .And. TPR->PR_TIPMOVI == _Demitido
		nPosTrf		:= Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
	
		If nPosTrf > 0 .and. ;
			aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta]==;
			aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta]
			nPosTrf		:= 0
	  	EndIf
	
		lTrfSld		:= nPosTrf > 0
		nTpMov		:= TPR->PR_TIPMOVI //Gravar tipo de movimento de demissao
	
	EndIf

	//Ŀ
	//	Limpa o array com o conteudo especificado no 2 parametro    
	//
	fLimpaArray( @aProvisao, 0 )
	fLimpaArray( @aRecnos,   0 )
	
	//Ŀ
	//	Chave de busca do mes anterior e atual                       
	//
	If lItemClVl
		cBusMesAnt := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + TPR->PR_ITEM + TPR->PR_CLVL + cAnoMesAnt 
		cBusMesAtu := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + TPR->PR_ITEM + TPR->PR_CLVL + cAnoMesAtu
	Else
		cBusMesAnt := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + cAnoMesAnt
		cBusMesAtu := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + cAnoMesAtu
	EndIf

	//Ŀ
	// Se nao trata transferencia buscar C. de Custo do mes anterior|
	//
	If !lTrataTrf .Or. lTrfAMES .Or. lTrfSld
		If !lTrfSld
            If lItemClVl
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat]+X[_TAtual,_TItm]+X[_TAtual,_TClv] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT+TPR->PR_ITEM+TPR->PR_CLVL })
			Else
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
			EndIf
	
	    	//Se anterior igual a destino entao nao houve transferencia.
			If nPosTrf > 0 .and. ;
				( lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta]+aTransf[nPosTrf,_TDest ,_TItm]+aTransf[nPosTrf,_TDest ,_TClv] ) .Or.;
				( !lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta] )
				nPosTrf:=0
			EndIf	
		EndIf
	
		If nPosTrf > 0
			If lItemClVl
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv]+cAnoMesAnt
			Else
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAnt
			EndIf
			cEmpQryAnt := aTransf[nPosTrf,_TAnter,_TEmp]
			//Ŀ
			// Se transferencia ocorreu apos mes atual preserva mes anterior|
			//
			If aTransf[nPosTrf,_TAnter,_TDta] > cAnoMesAtu
				If lItemClVl
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv]+cAnoMesAtu
				Else
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAtu
				EndIf
				lTrfSld := .F.
			EndIf
			lTrfEmpAmes := aTransf[nPosTrf,_TAnter,_TEmp] <> aTransf[nPosTrf,_TAtual,_TEmp]
		ElseIf TPR->PR_TIPMOVI == _Trfe_Sai
			If lItemClVl
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat]+X[_TAnter,_TItm]+X[_TAnter,_TClv] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT+TPR->PR_ITEM+TPR->PR_CLVL })
			Else
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
			EndIf
			If nPosTrfAmes > 0
				lTrfEmpAmes := aTransf[nPosTrfAmes,_TAnter,_TEmp] <> aTransf[nPosTrfAmes,_TAtual,_TEmp]
			Endif
		EndIf
	EndIf
	
	If !Empty(cTpRtProv)
		dbSelectArea( "RHT" )	
	Else
		dbSelectArea( "SRT" )
	Endif
	If lItemClVl
		dbSetOrder(4)
	Else
		dbSetOrder(1)
	EndIf	

	If !Empty(cTpRtProv)
		RHT->( dbSetOrder( RetOrdem( "RHT" , "RHT_FILIAL+RHT_MAT+RHT_CC+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )	
		If RHT->(dbSeek( TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CCMVTO + DTOS(dDataRef) + "1" ))
			While RHT->(!Eof()) .And. RHT->RHT_FILIAL + RHT->RHT_MAT + RHT->RHT_CC + DTOS(RHT->RHT_DTCALC) == TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CCMVTO + DTOS(dDataRef)
				If ( cTpRtProv == 'RPF' .And. RHT->RHT_TPPROV == "1" ) 
					If RHT->RHT_VERBA == aCodFol[960,1]
						aFerVenc[1,_Prov] := RHT->RHT_VALOR
						aFerVenc[1,_Avos] := 0 
						aFerVenc[1,_SalV] := 0
					ElseIf RHT->RHT_VERBA == aCodFol[962,1] 
						aFerVenc[1,_Adic] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[961,1]
						aFerVenc[1,_1Ter] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[963,1]
						aFerVenc[1,_INSS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[964,1]
						aFerVenc[1,_FGTS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[965,1]
						aFerVenc[1,_PIS] := RHT->RHT_VALOR	
					EndIf
				ElseIf ( cTpRtProv == 'RPF' .And. RHT->RHT_TPPROV == "2" )
					If RHT->RHT_VERBA == aCodFol[960,1]
						aFerProp[1,_Prov] := RHT->RHT_VALOR
						aFerProp[1,_Avos] := 0 
						aFerProp[1,_SalV] := 0
					ElseIf RHT->RHT_VERBA == aCodFol[962,1] 
						aFerProp[1,_Adic] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[961,1]
						aFerProp[1,_1Ter] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[963,1]
						aFerProp[1,_INSS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[964,1]
						aFerProp[1,_FGTS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[965,1]
						aFerProp[1,_PIS] := RHT->RHT_VALOR	
					EndIf				
				ElseIf ( cTpRtProv == 'RP13' .And. RHT->RHT_TPPROV == "3" ) 
					If RHT->RHT_VERBA == aCodFol[966,1]
						a13Salar[1,_Prov] := RHT->RHT_VALOR
						a13Salar[1,_Avos] := 0 
						a13Salar[1,_SalV] := 0
					ElseIf RHT->RHT_VERBA == aCodFol[967,1] 
						a13Salar[1,_Adic] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[968,1]
						a13Salar[1,_1Par] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[969,1]
						a13Salar[1,_INSS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[970,1]
						a13Salar[1,_FGTS] := RHT->RHT_VALOR
					ElseIf RHT->RHT_VERBA == aCodFol[971,1]
						a13Salar[1,_PIS] := RHT->RHT_VALOR
					EndIf
				Endif
				
				RHT->(dbSkip())
			EndDo
		Endif
		Return
	Endif
	
	//Se funcionario veio de outra empresa, abre a tabela da empresa anterior
	If cEmpQryAnt != cEmpAnt
		cSvEmpAnt := cEmpAnt
	 	cModo 	  := FWModeAccess(cAliasSRT)
		UniqueKey( NIL , cAliasSRT , .T. )
		EmpOpenFile(cAliasSRT,cAliasSRT,1,.t.,cEmpQryAnt,@cModo)
	
		nAT := AT(cAliasSRT,cArqTab)
		IF nAT > 0
			cArqTab := SubStr(cArqTab,1,nAT+2)+cModo+SubStr(cArqTab,nAT+4)
		Else
			cArqTab += cAliasSRT+cModo+"/"
		EndIF	
	EndIf

	//Ŀ
	// Carrega o array com os valores do mes anterior. (Nao carregar
	// se provisao de 13 salario e mes de referencia for janeiro). 
	//
	If dbSeek( cBusMesAnt ) .And. !(nTipoProv == _13Salar .And. Month(dDataRef) == 1)
		If !lTrfSld
			If nTipoProv == _FerVenc
				aProvisao[_Anter,_Dias] := SRT->RT_DFERVEN
			ElseIf nTipoProv == _FerProp
				aProvisao[_Anter,_Dias] := SRT->RT_DFERPRO
			ElseIf nTipoProv == _13Salar
				aProvisao[_Anter,_Avos] := SRT->RT_AVOS13S	
			EndIf
		EndIf
	
	
		While !Eof() .And. Eval(cOrdemBusca) == cBusMesAnt
			If SRT->RT_TIPPROV == Str(nTipoProv,1)
			    nPosVerba := Ascan(aVerba, { |X| X[4] == SRT->RT_VERBA })
		       	lAdiant13 := SRT->RT_VERBA == aCodFol[268,1]    //Verba 1.parcela do 13.sal    		
		       	
				//Ŀ
				// Busca o atual do mes anterior e grava no anterior do mes     
				//
			    If nPosVerba > 0 .And. aVerba[nPosVerba,2] == _Atual
		   		    nPosCol := aVerba[nPosVerba,3]
					aProvisao[_Anter,nPosCol] := SRT->RT_VALOR  
				
					//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa 
					// de rescisao da 1.parcela
					If lAdiant13 .and. nTpMov == _Demitido .and. nTipoProv == _13Salar
						aProvisao[_BxRes,nPosCol] := SRT->RT_VALOR    						             
					EndIf
	
				EndIf
			EndIf
			dbSkip()
		EndDo
	EndIf
	
	//Se funcionario veio de outra empresa, restaura a tabela da empresa atual
	If cEmpQryAnt != cEmpAnt
	 	cModo 	  := FWModeAccess(cAliasSRT)
		UniqueKey( NIL , cAliasSRT , .T. )
		EmpOpenFile(cAliasSRT,cAliasSRT,1,.t.,cSvEmpAnt,@cModo)
	
		nAT := AT(cAliasSRT,cArqTab)
		IF nAT > 0
			cArqTab := SubStr(cArqTab,1,nAT+2)+cModo+SubStr(cArqTab,nAT+4)
		Else
			cArqTab += cAliasSRT+cModo+"/"
		EndIF	
	EndIf

	//Ŀ
	// Carrega o array com os valores do mes atual                  
	//
	If dbSeek( cBusMesAtu )
		nTpMov := SRT->RT_TIPMOVI
		If !lTrfSld
			If nTipoProv == _FerVenc
				aProvisao[_NoMes,_Dias] := SRT->RT_DFALVEN
				aProvisao[_Atual,_Dias] := SRT->RT_DFERVEN-If(SRT->RT_DFERVEN > 0, SRT->RT_DFERANT,0)-SRT->RT_DFALVEN
			ElseIf nTipoProv == _FerProp
				aProvisao[_NoMes,_Dias] := SRT->RT_DFALPRO
				aProvisao[_Atual,_Dias] := SRT->RT_DFERPRO-SRT->RT_DFALPRO
			ElseIf nTipoProv == _13Salar
				aProvisao[_NoMes,_Avos] := SRT->RT_AVOS13S	
			EndIf
		EndIf
	
		While !Eof() .And. Eval(cOrdemBusca) == cBusMesAtu
			If SRT->RT_TIPPROV == Str(nTipoProv,1)	
		    	nPosVerba := Ascan(aVerba, { |X| X[4] == SRT->RT_VERBA })   
		       	lAdiant13 := SRT->RT_VERBA == aCodFol[268,1]    //Verba 1.parcela do 13.sal
	   
	    		If nPosVerba > 0
				    nPosLin := aVerba[nPosVerba,2]
		   		    nPosCol := aVerba[nPosVerba,3]
					aProvisao[nPosLin,nPosCol] := SRT->RT_VALOR
					aRecnos[nPosLin,nPosCol]   := RECNO()      
	
					//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa 
					// de rescisao da 1.parcela
					If lAdiant13 .and. nTpMov == _Demitido .and. nTipoProv == _13Salar
						aProvisao[_BxRes,nPosCol] := SRT->RT_VALOR    						             
					EndIf
				EndIf
			EndIf	
			dbSkip()
		EndDo
	EndIf
	
Endif //Fim do IF lSoMes
	
//Ŀ
// Calcula os valores de Baixa e o valor No Mes 			     
//
If lCalcula
	//Ŀ
	// Gravar valores coluna de rescisao quando nao existir identif.|
	//| de rescisao pois,neste caso, a baixa estara na coluna ferias.|
	//
	If nTpMov == _Demitido
		fChkDemit(aProvisao,aVerba,nTipoProv,_BxRes,_BxFer)
	EndIf
	//Ŀ
	//| Total de baixas                                              |
	//
	aProvisao[_BxTot,_Prov] := aProvisao[_BxTrf,_Prov]+aProvisao[_BxFer,_Prov]+aProvisao[_BxRes,_Prov]
	aProvisao[_BxTot,_Adic] := aProvisao[_BxTrf,_Adic]+aProvisao[_BxFer,_Adic]+aProvisao[_BxRes,_Adic]
    If cPaisLoc == "URU"
		aProvisao[_BxTot,_SalV] := aProvisao[_BxTrf,_SalV]+aProvisao[_BxFer,_SalV]+aProvisao[_BxRes,_SalV]
	Endif
	aProvisao[_BxTot,_1Ter] := aProvisao[_BxTrf,_1Ter]+aProvisao[_BxFer,_1Ter]+aProvisao[_BxRes,_1Ter]
	aProvisao[_BxTot,_INSS] := aProvisao[_BxTrf,_INSS]+aProvisao[_BxFer,_INSS]+aProvisao[_BxRes,_INSS]
	aProvisao[_BxTot,_FGTS] := aProvisao[_BxTrf,_FGTS]+aProvisao[_BxFer,_FGTS]+aProvisao[_BxRes,_FGTS]
	aProvisao[_BxTot,_PIS]  := aProvisao[_BxTrf,_PIS] +aProvisao[_BxFer,_PIS] +aProvisao[_BxRes,_PIS]
	//Ŀ
	//| Provisao do Mes												 |
	//
	aProvisao[_NoMes,_Prov] := aProvisao[_Atual,_Prov]-aProvisao[_Anter,_Prov]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_Prov], aProvisao[_BxTot,_Prov] )
	aProvisao[_NoMes,_Adic] := aProvisao[_Atual,_Adic]-aProvisao[_Anter,_Adic]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_Adic], aProvisao[_BxTot,_Adic] )
	If cPaisLoc == "URU"
		aProvisao[_NoMes,_SalV] := aProvisao[_Atual,_SalV]-aProvisao[_Anter,_SalV]+aProvisao[_BxTot,_SalV]
	Endif
	aProvisao[_NoMes,_1Ter] := aProvisao[_Atual,_1Ter]-aProvisao[_Anter,_1Ter]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_1Ter], aProvisao[_BxTot,_1Ter] )
	aProvisao[_NoMes,_INSS] := aProvisao[_Atual,_INSS]-aProvisao[_Anter,_INSS]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_INSS], aProvisao[_BxTot,_INSS] )
	aProvisao[_NoMes,_FGTS] := aProvisao[_Atual,_FGTS]-aProvisao[_Anter,_FGTS]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_FGTS], aProvisao[_BxTot,_FGTS] )
	aProvisao[_NoMes,_PIS]  := aProvisao[_Atual,_PIS] -aProvisao[_Anter,_PIS] +If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_PIS],  aProvisao[_BxTot,_PIS]  )

	If lProvResc .And. nTpMov == _Demitido
		//Ŀ
		//| Zera a linha de provisao atual quando o funcionario estiver demitido|
		//| e o parametro MV_PROVRES estiver configurado com "S"                |
		//
		For nCnt1 := 1 To _Colunas
			aProvisao[_Atual,nCnt1]	:= 0
		Next nCnt1
	Endif

	If lTrfAMES
		//Ŀ
		//| Transfere o saldo anterior para a coluna Transf. Entrada	 |
		//
		If TPR->PR_TIPMOVI == _Trfe_Ent .Or. ((TPR->PR_TIPMOVI == _Anter) .And. (aProvisao[_BxRes,_Prov]+aProvisao[_BxRes,_Adic]+aProvisao[_Bx13o,_Prov]+aProvisao[_Bx13o,_Adic] <> 0) .And. (nPosTrf > 0))
			For nCnt1 := 1 To _Colunas
			If !lTrfEmpAmes 
				aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
				aProvisao[_Anter,nCnt1]  := 0
			Else
				aProvisao[_NoMes,nCnt1] += aProvisao[_Anter,nCnt1]
				aProvisao[_Anter,nCnt1]  := 0	
			EndIf	
			Next nCnt1                  
			
			If aProvisao[_Bx13o,_Prov]+aProvisao[_Bx13o,_Adic] > 0
				aProvisao[_BxRes,_1Par] := 0
			EndIf	

		ElseIf nPosTrf > 0 .and. nTipoProv == 2 .and. TPR->PR_TIPMOVI == _Anter
   			For nCnt1 := 1 To _Colunas
				aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
				aProvisao[_Anter,nCnt1]  := 0
			Next nCnt1  

		//Ŀ
		//| Transfere o saldo de Baixa por Transf. p/coluna Transf. Saida|
		//
		ElseIf TPR->PR_TIPMOVI == _Trfe_Sai
				For nCnt1 := 1 To _Colunas
					If !lTrfEmpAmes		// nao e transferencia entre empresas.
						aProvisao[_TrfSai,nCnt1] := aProvisao[_BxTrf,nCnt1]
						aProvisao[_BxTrf,nCnt1]  := 0
					Else
						aProvisao[_NoMes,nCnt1]  -= aProvisao[_BxTrf,nCnt1]
						aProvisao[_BxTrf,nCnt1]  := 0
					Endif
				Next nCnt1
				//-- Ajusta o valor da baixa da primeira parcela na linha
				//-- de transferencia de saida
				//-- Devolve o valor para a linha No Mes
				//-- Tratamento exclusivo para 13o salario - 1a parcela
				If !lTrfEmpAmes .And. nTipoProv == _13Salar // nao e transferencia entre empresas.
					aProvisao[_TrfSai,_1Par]  := aProvisao[_Anter,_1Par]
					aProvisao[_NoMes,_1Par]   += aProvisao[_Anter,_1Par]
				Endif
			EndIf
		EndIf

  	If lTrfSld .And. fChkIdent(aVerba,If(nTipoProv==2,1,nTipoProv),{_BxRes},.F.) .and. fChkIdent(aVerba,If(nTipoProv==2,1,nTipoProv),{_BxTrf},.F.)
		For nCnt1 := 1 To _Colunas
			aProvisao[_NoMes,nCnt1] := aProvisao[_Anter,nCnt1]
			aProvisao[_Anter,nCnt1] := 0
		Next nCnt1
	EndIf

	Else
		//Ŀ
		//| Se nao calcular, limpar as colunas do array (Menos o Mes Ant)|
		//
		fLimpaArray( @aProvisao, 0, Str(_Anter,1) )
	EndIf

dbSelectArea( cAlias )

Return Nil

/*


Ŀ
Funao	 fQryDetSRT| Autor  Ricardo Duarte Costa   Data  22.01.07 
Ĵ
Descriao  Busca os valores da provisao no arquivo SRT				  
Ĵ
Sintaxe	  < vide parametros abaixo >                                 
Ĵ
Parametros aVerba   	 - Verbas de Ferias / 13 Sal / 14 Sal       
           aTransf  	 - Funcionarios Transferidos no mes           
           dDataRef 	 - Data de referencia para busca dos valores  
           nTipoProv	 - Tipo de provisao a buscar (Venc,Prop,13)  |
           lTrataTrf	 - Indica se deve tratar os transferidos      |
           lCalcula  	 - Indica se deve calcular o valor do mes     |
           lFerias   	 - Indica se deve buscar as ferias            |
           l13oSal       - Indica se deve buscar o 13o salario        |
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,lCalcula,lFerias,l13oSal,lSoMes)
Local cBusMesAnt,cBusMesAtu,nCnt1
Local cFilQryAnt,cMatQryAnt,cCCQryAnt,cFilQryAtu,cMatQryAtu,cCCQryAtu,cDtIQryAnt,cDtFQryAnt,cDtIQryAtu,cDtFQryAtu
Local cItmQryAnt,cClvQryAnt,cItmQryAtu,cClvQryAtu
Local nTpMov      := 0
Local nPosTrf	  := 0
Local nPosVerba	  := 0
Local nreg		  := 0
Local nTipoProv   := 0
Local nCntSRT	  := 0
Local nYears		:= 0
Local cAlias      := ALIAS()
Local cAnoMesAnt  := MesAno( dDataRef - Day(dDataRef) )
Local cAnoMesAtu  := MesAno( dDataRef )
Local cOrdemAnt   := &("{ || (cAliasAnt)->RT_FILIAL + (cAliasAnt)->RT_MAT + (cAliasAnt)->RT_CC + MesAno((cAliasAnt)->RT_DATACAL) }")
Local cOrdemBusca := &("{ || (cAliasSRT)->RT_FILIAL + (cAliasSRT)->RT_MAT + (cAliasSRT)->RT_CC + MesAno((cAliasSRT)->RT_DATACAL) }")
Local cCposQuery  := ""
Local aProvisao   := {}
Local axFerVenc   := {}
Local axFerProp   := {}
Local ax13Salar   := {}
Local ax14Salar   := {}
Local lInAS400	  := ExeInAS400()
Local lTrfEmpAmes := .F.
Local lAdiant13	  := .F.                            
Local cFilMatCC 
Local cAliasArq	  := If (Empty(cTpRtProv), "SRT", "RHT")    
Local cAliasAnt   := "QSRT2"
Local cAliasRHT := "QRHT"
Local cTpProvMes  := ""
Local cEmpQryAnt  := ""
Local cSvEmpAnt   := ""
Local cTabAnt     := ""
Local lQryAnt	  := .F.  
Local dPerAqui 		:= CTOD("//")
Local d1NextPer 	:= CTOD("//")
Local lBxMesRat	:= .F.
Local nRHTValor 	:= 0
Local nRHTAtuVlr	:= 0

Default lSoMes := .F.

If Type( "lProvResc" ) == "U"
	lProvResc := ( SuperGetMv( "MV_PROVRES",,"N" ) == "S" ) //-- Indica se devera provisionar no mes da rescisao
EndIf

If Type("lItemClVl") == "U"
	lItemClVl   := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13"
Endif

If Type( "lTrfAMES" ) == "U"
	cTrfAMES     := ( SuperGetMv( "MV_TRFAMES",, Space(6) ) ) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
	lTrfAMES     := ( !Empty(cTrfAMES) .And. MesAno( dDataRef ) >= cTrfAMES )
EndIf

If Type( "lTrfSld" ) == "U" .Or. lTrfSld
	lTrfSld := .F.
EndIf

lCalcula   := If(lCalcula  == Nil, .F., lCalcula)
lFerias	   := If(lFerias   == Nil, .T., lFerias)
l13oSal    := If(l13oSal   == Nil, .T., l13oSal) 

If !Empty(cTpRtProv)
	If lItemClVl
		cOrdemAnt   := &("{ || (cAliasAnt)->RHT_FILIAL + (cAliasAnt)->RHT_MAT + (cAliasAnt)->RHT_CC + (cAliasAnt)->RHT_ITEM + (cAliasAnt)->RHT_CLVL + MesAno((cAliasAnt)->RHT_DTCALC) }")    
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + (cAliasSRT)->RHT_ITEM + (cAliasSRT)->RHT_CLVL + MesAno((cAliasSRT)->RHT_DTCALC) }")   
	Else
		cOrdemAnt   := &("{ || (cAliasAnt)->RHT_FILIAL + (cAliasAnt)->RHT_MAT + (cAliasAnt)->RHT_CC + MesAno((cAliasAnt)->RHT_DTCALC) }")    
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + MesAno((cAliasSRT)->RHT_DTCALC) }")    
	EndIf
	cTpProvMes := If(lFerias, "'1','2'", "'3'")
ElseIf lItemClVl
	cOrdemAnt   := &("{ || (cAliasAnt)->RT_FILIAL + (cAliasAnt)->RT_MAT + (cAliasAnt)->RT_CC + (cAliasAnt)->RT_ITEM + (cAliasAnt)->RT_CLVL + MesAno((cAliasAnt)->RT_DATACAL) }")	
	cOrdemBusca := &("{ || (cAliasSRT)->RT_FILIAL + (cAliasSRT)->RT_MAT + (cAliasSRT)->RT_CC + (cAliasSRT)->RT_ITEM + (cAliasSRT)->RT_CLVL + MesAno((cAliasSRT)->RT_DATACAL) }")
Endif

If !lSoMes

	If !lProvResc .And. TPR->PR_TIPMOVI == _Demitido
	
		nPosTrf		:= Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == cEmpAnt+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
		If nPosTrf > 0 .and. ;
			aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]==;
			aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]
			nPosTrf		:= 0
	  	EndIf
	
		lTrfSld		:= nPosTrf > 0
		nTpMov		:= TPR->PR_TIPMOVI //Gravar tipo de movimento de demissao
		
	EndIf

	//Ŀ
	//	Chave de busca do mes anterior e atual                       
	//
	If lItemClVl
		cBusMesAnt  := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + TPR->PR_ITEM + TPR->PR_CLVL + cAnoMesAnt 
	Else
		cBusMesAnt  := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + cAnoMesAnt
	EndIf
	cFilQryAnt	:= "'"+TPR->PR_FILIAL+"'"
	cMatQryAnt	:= "'"+TPR->PR_MAT+"'"
	cCCQryAnt	:= "'"+TPR->PR_CC+"'"
	cEmpQryAnt	:= cEmpAnt
	If lItemClVl
		cItmQryAnt	:= "'"+TPR->PR_ITEM+"'"
		cClvQryAnt	:= "'"+TPR->PR_CLVL+"'"
	EndIf
	
	If lItemClVl
		cBusMesAtu := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + TPR->PR_ITEM + TPR->PR_CLVL + cAnoMesAtu
	Else
		cBusMesAtu := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + cAnoMesAtu
	EndIf
	cFilQryAtu	:= "'"+TPR->PR_FILIAL+"'"
	cMatQryAtu	:= "'"+TPR->PR_MAT+"'"
	cCCQryAtu	:= "'"+TPR->PR_CC+"'"
	If lItemClVl
		cItmQryAtu	:= "'"+TPR->PR_ITEM+"'"
		cClvQryAtu	:= "'"+TPR->PR_CLVL+"'"
	EndIf

	//Ŀ
	// Se nao trata transferencia buscar C. de Custo do mes anterior|
	//
	If !lTrataTrf .Or. lTrfAMES .Or. lTrfSld
		If !lTrfSld
            If lItemClVl
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat]+X[_TAtual,_TItm]+X[_TAtual,_TClv] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT+TPR->PR_ITEM+TPR->PR_CLVL })
			Else
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
			EndIf
	
		    //Se anterior igual a destino entao nao houve transferencia.
			If nPosTrf > 0 .and. ;
				(( lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta]+aTransf[nPosTrf,_TDest ,_TItm]+aTransf[nPosTrf,_TDest ,_TClv] ) .Or.;
				( !lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta] ))
				nPosTrf:=0
			EndIf	
	
		EndIf
	
		If nPosTrf > 0
			If lItemClVl
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv]+cAnoMesAnt
			Else
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAnt
			EndIf
			cFilQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TFil]+"'"
			cMatQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TMat]+"'"
			cCCQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TCC]+"'"
			cEmpQryAnt	:= aTransf[nPosTrf,_TAnter,_TEmp]
			If lItemClVl
				cItmQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TItm]+"'"
				cClvQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TClv]+"'"
			EndIf
			//Ŀ
			// Se transferencia ocorreu apos mes atual preserva mes anterior|
			//
			If aTransf[nPosTrf,_TAnter,_TDta] > cAnoMesAtu
				If lItemClVl
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItm]+aTransf[nPosTrf,_TAnter,_TClv]+cAnoMesAtu
				Else
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAtu
				EndIf
				cFilQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TFil]+"'"
				cMatQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TMat]+"'"
				cCCQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TCC]+"'"
				If lItemClVl
					cItmQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TItm]+"'"
					cClvQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TClv]+"'"
				EndIf
	
				lTrfSld := .F.
			EndIf
			lTrfEmpAmes := aTransf[nPosTrf,_TAnter,_TEmp] <> aTransf[nPosTrf,_TAtual,_TEmp]
		ElseIf TPR->PR_TIPMOVI == _Trfe_Sai
			If lItemClVl
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat]+X[_TAnter,_TItm]+X[_TAnter,_TClv] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT+TPR->PR_ITEM+TPR->PR_CLVL })
			Else
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat] == FWGrpCompany(cAliasArq)+TPR->PR_FILIAL+TPR->PR_CC+TPR->PR_MAT })
			EndIf
			If nPosTrfAmes > 0
				lTrfEmpAmes := aTransf[nPosTrfAmes,_TAnter,_TEmp] <> aTransf[nPosTrfAmes,_TAtual,_TEmp]
			Endif
		Endif
	EndIf
	
	cAliasSRT	:= "QSRT" 
	If Empty(cTpRtProv)	
		aStruSRT 	:= SRT->(dbStruct())
	Else
		aStruSRT	:= RHT->(dbStruct())
	Endif
	
	For nCntSRT := 1 To Len(aStruSRT)
		If nCntSRT < Len(aStruSRT)
			cCposQuery	+= aStruSRT[nCntSRT,1] + ", "
		Else
			cCposQuery	+= aStruSRT[nCntSRT,1]
		EndIf
	Next nCntSRT
	
	//-- Monta a query para selecao dos dados
	If lInAS400
		cCposQuery	+=	", RRN(SRT) RECNO_ "
	Else
		cCposQuery	+=	", R_E_C_N_O_ AS RECNO_"
	EndIF
	
	cCposQuery	:=	"% "+cCposQuery+" %"
	
	If lItemClVl
		cOrdem		:= If (Empty(cTpRtProv), SqlOrder( SRT->( IndexKey(4) ) ), SqlOrder( RHT->( IndexKey(4) ) ) )
	Else
		cOrdem		:= If (Empty(cTpRtProv), SqlOrder( SRT->( IndexKey(1) ) ), SqlOrder( RHT->( IndexKey(1) ) ) )
	EndIf
	cOrdem		:= "% "+cOrdem+" %"
	cDtIQryAnt	:= "'"+cAnoMesAnt+"01'"
	cDtFQryAnt	:= "'"+Dtos(dDataRef-Day(dDataRef))+"'"
	cDtIQryAtu	:= "'"+cAnoMesAtu+"01'"
	cDtFQryAtu	:= "'"+cAnoMesAtu+strzero(f_Ultdia(dDataRef),2)+"'"
	
	If !Empty(cTpRtProv)
		If lItemClVl
			cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
							" AND RHT.RHT_DTCALC BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) "
			cWhere		+= " AND RHT.RHT_CC = "+TPR->PR_CCMVTO+ " AND RHT.RHT_ITEM = "+TPR->PR_ITMMVTO+ " AND RHT.RHT_CLVL = "+TPR->PR_CLVMVTO+ " AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"		
		Else
			cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
							" AND RHT.RHT_DTCALC BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) "
			cWhere		+= " AND RHT.RHT_CC = '"+TPR->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
		EndIf
	Else
		If lItemClVl
			cWhere		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_ITEM = "+cItmQryAnt+" AND SRT.RT_CLVL = "+cClvQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhere		:=	"( "+cWhere+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_ITEM = "+cItmQryAtu+" AND SRT.RT_CLVL = "+cClvQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"		
		Else
			cWhere		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhere		:=	"( "+cWhere+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"
		EndIf
	EndIf				
	
	/***************************************************************************************
	* Filtra pelos Identificadores de calculo do Rateio de provisao de Ferias ou 13 Salario*
	* Ferias: 960 - 961 - 962 - 963 - 964 - 965                                            *
	* 13 Sal: 966 - 967 - 968 - 969 - 970                                                  *
	***************************************************************************************/
	If cTpRtProv == "RPF" //RPF - Rateio Provisao Frias
		cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+;
	  											  aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"') "
	ElseIf cTpRtProv == "RP13" //RP13 - Rateio Provisao 13 Salario
		cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+;
												  aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"') "
	EndIf
	
	cWhere		:= "%"+cWhere+"%"

	If Empty(cTpRtProv)	
		BeginSql alias cAliasSRT
			SELECT %exp:cCposQuery% 
			FROM %table:SRT% SRT 
			WHERE %exp:cWhere% AND SRT.%notDel% 
			ORDER BY %exp:cOrdem%
		EndSql
		
		If cEmpQryAnt != cEmpAnt
			lQryAnt   := .T.
			cSvEmpAnt := cEmpAnt			
			cEmpAnt   := cEmpQryAnt
			cTabAnt   := "%" + RetFullName("SRT") + "%"
			BeginSql alias cAliasAnt
				SELECT %exp:cCposQuery% 
				FROM %exp:cTabAnt% SRT 
				WHERE %exp:cWhere% AND SRT.%notDel% 
				ORDER BY %exp:cOrdem%
			EndSql
			cEmpAnt := cSvEmpAnt			
		EndIf
	Else
		BeginSql alias cAliasSRT
			SELECT %exp:cCposQuery% 
			FROM %table:RHT% RHT 
			WHERE %exp:cWhere% AND RHT.%notDel% 
			ORDER BY %exp:cOrdem%
		EndSql	
	Endif
	
	//-- Ajusta a estrutura dos campos
	For nReg := 1 To Len(aStruSRT)
		If ( aStruSRT[nReg][2] <> "C" )
			TcSetField(cAliasSRT,aStruSRT[nReg][1],aStruSRT[nReg][2],aStruSRT[nReg][3],aStruSRT[nReg][4])
		EndIf
	Next nReg
	If lQryAnt
		For nReg := 1 To Len(aStruSRT)
			If ( aStruSRT[nReg][2] <> "C" )
				TcSetField(cAliasAnt,aStruSRT[nReg][1],aStruSRT[nReg][2],aStruSRT[nReg][3],aStruSRT[nReg][4])
			EndIf
		Next nReg	
	EndIf
	
	//Ŀ
	//	Limpa os arrays de provisao.                                 
	//
	If Type("aFerVenc") # "U"
		fLimpaArray( @aFerVenc, 0 )
		fLimpaArray( @aFerProp, 0 )
		If !lCalcula
			fLimpaArray( @aRecVenc, 0 )
			fLimpaArray( @aRecProp, 0 )
		Endif
	EndIf
	If Type("a13Salar") # "U"
		fLimpaArray( @a13Salar, 0 )
		fLimpaArray( @a14Salar, 0 )
		If !lCalcula
			fLimpaArray( @aRec13Sl, 0 )
			fLimpaArray( @aRec14Sl, 0 )
		Endif
	EndIf
	
	dbSelectArea( cAliasSRT )
	
	//----------------------------------------------------------------------
	// Entra neste bloco na impressao do relatorio de valores do mes
	//----------------------------------------------------------------------
	If !Empty(cTpRtProv)
			If cTpRtProv == 'RPF' 
				While  (cAliasSRT)->( !Eof() )
					If (cAliasSRT)->RHT_TPPROV == '1' // Frias Vencidas
						If (cAliasSRT)->RHT_VERBA == aCodFol[960,1]
							aFerVenc[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
							aFerVenc[_NoMes,_Avos] := 0 
							aFerVenc[_NoMes,_SalV] := 0
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[962,1] 
							aFerVenc[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[961,1]
							aFerVenc[_NoMes,_1Ter] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[963,1]
							aFerVenc[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[964,1]
							aFerVenc[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[965,1]
							aFerVenc[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR
						EndIf 
					Else 
						If (cAliasSRT)->RHT_VERBA == aCodFol[960,1]
							aFerProp[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
							aFerProp[_NoMes,_Avos] := 0 
							aFerProp[_NoMes,_SalV] := 0
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[962,1] 
							aFerProp[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[961,1]
							aFerProp[_NoMes,_1Ter] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[963,1]
							aFerProp[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[964,1]
							aFerProp[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[965,1]
							aFerProp[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR	
						EndIf 					
					Endif
					 (cAliasSRT)->( dbSkip() )
				EndDo
			Else
				While  (cAliasSRT)->( !Eof() )
					If (cAliasSRT)->RHT_VERBA == aCodFol[966,1]
						a13Salar[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
						a13Salar[_NoMes,_Avos] := 0 
						a13Salar[_NoMes,_SalV] := 0
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[967,1] 
						a13Salar[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[968,1]
						a13Salar[_NoMes,_1Par] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[969,1]
						a13Salar[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[970,1]
						a13Salar[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[971,1]
						a13Salar[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR
					EndIf
					 (cAliasSRT)->( dbSkip() )
				Enddo
			Endif
			
			// Totalizar o Saldo Anterior atravs de Query //			
			If cTpRtProv == "RPF" //RPF - Rateio Provisao Frias

				cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu
				
				//Verificar se a data do perodo aquisitivo  maior que a data do perodo solicitado //
				DbSelectArea( "SRF" )
				DbSetOrder( 1 )                    
				DbSeek( TPR->PR_FILIAL + TPR->PR_MAT, .F. )
				If !Eof() .and. SRF->RF_DATABAS >= dDataRef 
					
					nYears := DateDiffYear( SRF->RF_DATABAS, dDataRef  )					
					nYears := If(nYears>0, nYears, 1)
					dPerAqui := "'" + DTOS(YearSub( SRF->RF_DATABAS, nYears ) ) + "'"
					cWhere += " AND RHT.RHT_DTCALC BETWEEN " + dPerAqui  + " AND " + cDtFQryAtu + " ) "
				Else
					cWhere += " AND RHT.RHT_DTCALC BETWEEN SRF.RF_DATABAS AND " + cDtFQryAtu + " ) "
				EndIf
				
				If lItemClVl
					cWhere		+= " AND RHT.RHT_CC = "+TPR->PR_CCMVTO+ " AND RHT.RHT_ITEM = "+TPR->PR_ITMMVTO+ " AND RHT.RHT_CLVL = "+TPR->PR_CLVMVTO+ " AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"		
				Else                                                                  '
					cWhere		+= " AND RHT.RHT_CC = '"+TPR->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				EndIf
				cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+;
																				  aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"') "
			ElseIf cTpRtProv == "RP13" //RP13 - Rateio Provisao 13 Salario
			
				cDtIQryAtu	:= StrZero(Ano( dDataRef  ),4)+"0101"
				If lItemClVl
					cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
									" AND RHT.RHT_DTCALC BETWEEN " +  cDtIQryAtu + " AND " + cDtFQryAtu + " ) "
					cWhere		+= " AND RHT.RHT_CC = "+TPR->PR_CCMVTO+ " AND RHT.RHT_ITEM = "+TPR->PR_ITMMVTO+ " AND RHT.RHT_CLVL = "+TPR->PR_CLVMVTO+ " AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"		
				Else
					cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
									" AND RHT.RHT_DTCALC BETWEEN " +  cDtIQryAtu + " AND " + cDtFQryAtu + " ) "
					cWhere		+= " AND RHT.RHT_CC = '"+TPR->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				EndIf

				cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+;
													  aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"') "

			EndIf
			cWhere		:= "%"+cWhere+"%"

			BeginSql alias cAliasRHT
				SELECT RHT.RHT_DTCALC, SRF.RF_DATABAS, RHT.RHT_VERBA, RHT.RHT_TPPROV, SUM(RHT_VALOR) RHT_VALOR
				FROM %table:RHT% RHT
				INNER JOIN %table:SRF%  SRF
				ON SRF.RF_FILIAL = RHT.RHT_FILIAL
					 AND SRF.RF_MAT = RHT.RHT_MAT           
				WHERE %exp:cWhere% AND RHT.%notDel% 
				GROUP BY RHT.RHT_DTCALC, SRF.RF_DATABAS, RHT.RHT_VERBA, RHT.RHT_TPPROV
			EndSql
			
			If cTpRtProv == 'RPF' 
				While  (cAliasRHT)->( !Eof() )

					If (cAliasRHT)->RHT_TPPROV == '1' // Frias Vencidas

						// Ignorar os valores do Mes corrente //
						nRHTValor := (cAliasRHT)->RHT_VALOR
						nRHTAtuVlr := nRHTValor
						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef)
							nRHTValor := 0
						EndIf

						If (cAliasRHT)->RHT_VERBA == aCodFol[960,1]
							aFerVenc[_Anter,_Prov] += nRHTValor
							aFerVenc[_Anter,_Avos] := 0 
							aFerVenc[_Anter,_SalV] := 0

							// Anterior + Atual
							aFerVenc[_Atual,_Prov] +=  nRHTAtuVlr
							aFerVenc[_Anter,_Avos] := 0 
							aFerVenc[_Anter,_SalV] := 0							
							
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[962,1] 
							aFerVenc[_Anter,_Adic] += nRHTValor
							aFerVenc[_Atual,_Adic] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[961,1]
							aFerVenc[_Anter,_1Ter] += nRHTValor
							aFerVenc[_Atual,_1Ter] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[963,1]
							aFerVenc[_Anter,_INSS] += nRHTValor
							aFerVenc[_Atual,_INSS] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[964,1]
							aFerVenc[_Anter,_FGTS] += nRHTValor
							aFerVenc[_Atual,_FGTS] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[965,1]
							aFerVenc[_Anter,_PIS] += nRHTValor
							aFerVenc[_Atual,_PIS] +=  nRHTAtuVlr
						EndIf 
					Else                                                                    
					
						// Tratar as ferias a vencer apenas no intervalo de datas do periodo aquisitivo com a data de provisao selecionada //
						// Considerando 3 periodos vencidos - Para Provisao a virada ocorre no 11o. Mes =
						If nYears <= 0
							dPerAqui 	:= STOD((cAliasRHT)->RF_DATABAS) 
						EndIf
						d1NextPer := MonthSub( YearSum( STOD((cAliasRHT)->RF_DATABAS), 1 ),1)-1 // Proximo Perodo de Frias
                                                                                             
						// Ocorrem baixas de frias
						lBxMesRat := .F.
						If AnoMes( dDataRef ) == AnoMes( d1NextPer )
							lBxMesRat := .T.
						EndIf
						
						
						// Os dias pertencem ao 2o. perodo ou superior
						If dDataRef >  d1NextPer
							dPerAqui 	:= YearSum( dPerAqui , 1 )
							d1NextPer := YearSum( d1NextPer , 1 ) // Proximo Perodo de Frias

							// Ocorrem baixas de frias
							If AnoMes( dDataRef ) == AnoMes( d1NextPer )
								lBxMesRat := .T.
							EndIf

							// Os dias pertencem ao 3o. perodo ou superior
							If dDataRef >  d1NextPer
								dPerAqui 	:= YearSum( dPerAqui , 1 )
								d1NextPer := YearSum( d1NextPer , 1 ) // Proximo Perodo de Frias
							EndIf

						EndIf

						nRHTValor := 0
						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) >= AnoMes( dPerAqui ) .AND. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <= AnoMes(d1NextPer)
							nRHTValor := (cAliasRHT)->RHT_VALOR
							nRHTAtuVlr := nRHTValor
						ElseIf DateDiffMonth(Stod((cAliasRHT)->RHT_DTCALC),dPerAqui)== 1
							nRHTValor := ((cAliasRHT)->RHT_VALOR) * -1
							nRHTAtuVlr := 0
						Else
							nRHTAtuVlr := nRHTValor
						EndIf
						
						// Ignorar os valores do Mes corrente //
					
						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef) .And. !(DateDiffMonth(Stod((cAliasRHT)->RHT_DTCALC),dPerAqui)== 1)
							nRHTValor := 0
						EndIf

						If (cAliasRHT)->RHT_VERBA == aCodFol[960,1]
							aFerProp[_Anter,_Prov] += nRHTValor 
							aFerProp[_Anter,_Avos] := 0
							aFerProp[_Anter,_SalV] := 0
							
							aFerProp[_Atual,_Prov] += nRHTAtuVlr
							aFerProp[_Atual,_Avos] := 0 
							aFerProp[_Atual,_SalV] := 0

						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[962,1] 
							aFerProp[_Anter,_Adic] += nRHTValor 
							aFerProp[_Atual,_Adic] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[961,1]
							aFerProp[_Anter,_1Ter] += nRHTValor 
							aFerProp[_Atual,_1Ter] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[963,1]
							aFerProp[_Anter,_INSS] += nRHTValor
							aFerProp[_Atual,_INSS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[964,1]
							aFerProp[_Anter,_FGTS] += nRHTValor 
							aFerProp[_Atual,_FGTS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[965,1]
							aFerProp[_Anter,_PIS] += nRHTValor 
							aFerProp[_Atual,_PIS] += nRHTAtuVlr
						EndIf 
						
						// Se ocorrer no mes da baixa de ferias 
						If lBxMesRat 
							aFerProp[_Anter,_Prov]		:= aFerProp[_NoMes,_Prov]*-1
							aFerProp[_Atual,_Prov] 		:= 0
							aFerProp[_Anter,_1Ter] 		:= aFerProp[_NoMes,_1Ter]*-1
							aFerProp[_Atual,_1Ter] 		:= 0
							aFerProp[_Anter,_INSS] 	:= aFerProp[_NoMes,_INSS]*-1
							aFerProp[_Atual,_INSS]		:= 0
							aFerProp[_Anter,_FGTS] 	:= aFerProp[_NoMes,_FGTS]*-1
							aFerProp[_Atual,_FGTS]		:= 0
							aFerProp[_Anter,_PIS] 		:= aFerProp[_NoMes,_PIS]*-1
							aFerProp[_Atual,_PIS] 		:= 0
						EndIf

					Endif
					
					 (cAliasRHT)->( dbSkip() )
				EndDo
			Else
				While  (cAliasRHT)->( !Eof() )
				
					// Ignorar os valores do Mes corrente //
					nRHTValor := (cAliasRHT)->RHT_VALOR
					nRHTAtuVlr := nRHTValor
					If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef)
						nRHTValor := 0
					EndIf
				
					If (cAliasRHT)->RHT_VERBA == aCodFol[966,1]
						a13Salar[_Anter,_Prov] += nRHTValor
						a13Salar[_Anter,_Avos] := 0 
						a13Salar[_Anter,_SalV] := 0

						a13Salar[_Atual,_Prov] += nRHTAtuVlr
						a13Salar[_Atual,_Avos] := 0 
						a13Salar[_Atual,_SalV] := 0

					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[967,1] 
						a13Salar[_Anter,_Adic] += nRHTValor
						a13Salar[_Atual,_Adic] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[968,1]
						a13Salar[_Anter,_1Par] += nRHTValor
						a13Salar[_Atual,_1Par] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[969,1]
						a13Salar[_Anter,_INSS] += nRHTValor
						a13Salar[_Atual,_INSS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[970,1]
						a13Salar[_Anter,_FGTS] += nRHTValor
						a13Salar[_Atual,_FGTS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[971,1]
						a13Salar[_Anter,_PIS] += nRHTValor
						a13Salar[_Atual,_PIS] += nRHTAtuVlr
					EndIf
					 (cAliasRHT)->( dbSkip() )
				Enddo
			Endif
			(cAliasRHT)->(dbCloseArea())
			(cAliasSRT)->(dbCloseArea())
			dbSelectArea( cAlias )
			Return
	EndIf	

	While !Eof()
		//Ŀ
		// Carrega o array com os valores do mes anterior. (Nao carregar
		// se provisao de 13 salario e mes de referencia for janeiro). 
		//
		If !lQryAnt .And. Eval(cOrdemBusca) == cBusMesAnt
			//-- Somente para o registro de cabecalho
			If !lTrfSld
				If !((cAliasSRT)->RT_TIPPROV == str(_13Salar,1) .And. Month(dDataRef) == 1) .And. !Empty((cAliasSRT)->RT_DATABAS)
					If lFerias
						aFerVenc[_Anter,_Dias] := (cAliasSRT)->RT_DFERVEN
						aFerProp[_Anter,_Dias] := (cAliasSRT)->RT_DFERPRO
					Endif
					If l13oSal
						a13Salar[_Anter,_Avos] := (cAliasSRT)->RT_AVOS13S
					Endif
				Endif
			EndIf
		    
		    nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasSRT)->RT_VERBA })
	       	lAdiant13 := (cAliasSRT)->RT_VERBA == aCodFol[268,1]   //1.Parcela 13.Sal
		    
			//Ŀ
			// Busca o atual do mes anterior e grava no anterior do mes     
			//
		    If nPosVerba > 0 .And. aVerba[nPosVerba,2] == _Atual
	   		    nPosCol := aVerba[nPosVerba,3]
				If lFerias
					If (cAliasSRT)->RT_TIPPROV == Str(_FerVenc,1)
						aFerVenc[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_FerProp,1)
						aFerProp[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					Endif
				Endif
				If l13oSal
					If (cAliasSRT)->RT_TIPPROV == Str(_13Salar,1) .and. !(Month(dDataRef) == 1)
						a13Salar[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR   
						//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa 
						// de rescisao da 1.parcela
						If lAdiant13 .and. nTpMov == _Demitido
							a13Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR   						             
						EndIf
						
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_14Salar,1) .and. !(Month(dDataRef) == 1)
						a14Salar[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					EndIf
				Endif
			EndIf
		EndIf
		
		//Ŀ
		// Carrega o array com os valores do mes atual                  
		//
		If Eval(cOrdemBusca) == cBusMesAtu
			//-- Somente para o registro de cabecalho
			If !lTrfSld
				If !Empty((cAliasSRT)->RT_DATABAS)
					nTpMov := (cAliasSRT)->RT_TIPMOVI
					If lFerias .And. ( (cAliasSRT)->RT_TIPPROV == Str(_FerProp,1) .or. ( (cAliasSRT)->RT_TIPPROV == Str(_FerVenc,1)) )
						aFerVenc[_NoMes,_Dias] := (cAliasSRT)->RT_DFALVEN
						aFerVenc[_Atual,_Dias] := (cAliasSRT)->RT_DFERVEN-If((cAliasSRT)->RT_DFERVEN > 0, (cAliasSRT)->RT_DFERANT,0)-(cAliasSRT)->RT_DFALVEN
						aFerProp[_NoMes,_Dias] := (cAliasSRT)->RT_DFALPRO
						aFerProp[_Atual,_Dias] := (cAliasSRT)->RT_DFERPRO-(cAliasSRT)->RT_DFALPRO
					Endif
					If l13oSal
						a13Salar[_NoMes,_Avos] := (cAliasSRT)->RT_AVOS13S	
					Endif
				Endif
			EndIf
			
	    	nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasSRT)->RT_VERBA })
	    	lAdiant13 := (cAliasSRT)->RT_VERBA == aCodFol[268,1]  //1.Parcela 13.Sal
	    	
	    	If nPosVerba > 0
				nPosLin := aVerba[nPosVerba,2]
				nPosCol := aVerba[nPosVerba,3]
				If lFerias
					If (cAliasSRT)->RT_TIPPROV == Str(_FerVenc,1)
						If lCalcula
							aFerVenc[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRecVenc[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_FerProp,1)
						If lCalcula 
							aFerProp[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRecProp[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					Endif
				Endif
				If l13oSal
	 				If (cAliasSRT)->RT_TIPPROV == Str(_13Salar,1)
						If lCalcula
							a13Salar[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR   
							//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa 
							// de rescisao da 1.parcela
							If lAdiant13 .and. nTpMov == _Demitido
								a13Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR   						             
							EndIf
						Else
							aRec13Sl[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_14Salar,1)
						If lCalcula 
							a14Salar[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRec14Sl[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					EndIf
				Endif
			EndIf
		EndIf
		dbSkip()
	EndDo
	
	If lQryAnt
		dbSelectArea(cAliasAnt)
		While !Eof()
			//Ŀ
			// Carrega o array com os valores do mes anterior. (Nao carregar
			// se provisao de 13 salario e mes de referencia for janeiro). 
			//
			If Eval(cOrdemAnt) == cBusMesAnt
				//-- Somente para o registro de cabecalho
				If !lTrfSld
					If !((cAliasAnt)->RT_TIPPROV == str(_13Salar,1) .And. Month(dDataRef) == 1) .And. !Empty((cAliasAnt)->RT_DATABAS)
						If lFerias
							aFerVenc[_Anter,_Dias] := (cAliasAnt)->RT_DFERVEN
							aFerProp[_Anter,_Dias] := (cAliasAnt)->RT_DFERPRO
						Endif
						If l13oSal
							a13Salar[_Anter,_Avos] := (cAliasAnt)->RT_AVOS13S
						Endif
					Endif
				EndIf
			    
			    nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasAnt)->RT_VERBA })
		       	lAdiant13 := (cAliasAnt)->RT_VERBA == aCodFol[268,1]   //1.Parcela 13.Sal
			    
				//Ŀ
				// Busca o atual do mes anterior e grava no anterior do mes     
				//
			    If nPosVerba > 0 .And. aVerba[nPosVerba,2] == _Atual
		   		    nPosCol := aVerba[nPosVerba,3]
					If lFerias
						If (cAliasAnt)->RT_TIPPROV == Str(_FerVenc,1)
							aFerVenc[_Anter,nPosCol] := (cAliasAnt)->RT_VALOR
						ElseIf (cAliasAnt)->RT_TIPPROV == Str(_FerProp,1)
							aFerProp[_Anter,nPosCol] := (cAliasAnt)->RT_VALOR
						Endif
					Endif
					If l13oSal
						If (cAliasAnt)->RT_TIPPROV == Str(_13Salar,1) .and. !(Month(dDataRef) == 1)
							a13Salar[_Anter,nPosCol] := (cAliasAnt)->RT_VALOR   
							//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa 
							// de rescisao da 1.parcela
							If lAdiant13 .and. nTpMov == _Demitido
								a13Salar[_BxRes,nPosCol] := (cAliasAnt)->RT_VALOR   						             
							EndIf
							
						ElseIf (cAliasAnt)->RT_TIPPROV == Str(_14Salar,1) .and. !(Month(dDataRef) == 1)
							a14Salar[_Anter,nPosCol] := (cAliasAnt)->RT_VALOR
						EndIf
					Endif
				EndIf
			EndIf
			dbSkip()
		EndDo
	EndIf

Endif //Fim do IF lSoMes

//Ŀ
// Calcula os valores de Baixa e o valor No Mes 			     
//
If lCalcula

	//-- Salva a informacao antes de processar o calculo da provisao no mes
	If lFerias
		axFerVenc	:= aClone(aFerVenc)
		axFerProp	:= aClone(aFerProp)
	Endif
	If l13oSal
		ax13Salar	:= aClone(a13Salar)
		ax14Salar	:= aClone(a14Salar)
	Endif

	For nTipoProv := 1 to 4
		If ( l13oSal .And. (nTipoProv == 3 .Or. nTipoProv == 4) ) .Or.;
		   ( lFerias .And. (nTipoProv == 1 .Or. nTipoProv == 2) )
			//-- Verifica o tipo de provisao a ser processado
			If nTipoProv == 1 
				aProvisao	:= aFerVenc
			ElseIf nTipoProv == 2
				aProvisao	:= aFerProp
			ElseIf nTipoProv == 3
				aProvisao	:= a13Salar
			ElseIf nTipoProv == 4
				aProvisao	:= a14Salar
			Endif
			
			//Ŀ
			// Gravar valores coluna de rescisao quando nao existir identif.|
			//| de rescisao pois,neste caso, a baixa estara na coluna ferias.|
			//
			If nTpMov == _Demitido
				fChkDemit(aProvisao,aVerba,nTipoProv,_BxRes,_BxFer)
			EndIf
			//Ŀ
			//| Total de baixas                                              |
			//
			aProvisao[_BxTot,_Prov] := aProvisao[_BxTrf,_Prov]+aProvisao[_BxFer,_Prov]+aProvisao[_BxRes,_Prov]
			aProvisao[_BxTot,_Adic] := aProvisao[_BxTrf,_Adic]+aProvisao[_BxFer,_Adic]+aProvisao[_BxRes,_Adic]
			If cPaisLoc == "URU"
				aProvisao[_BxTot,_SalV] := aProvisao[_BxTrf,_SalV]+aProvisao[_BxFer,_SalV]+aProvisao[_BxRes,_SalV]
			Endif
			aProvisao[_BxTot,_1Ter] := aProvisao[_BxTrf,_1Ter]+aProvisao[_BxFer,_1Ter]+aProvisao[_BxRes,_1Ter]
			aProvisao[_BxTot,_INSS] := aProvisao[_BxTrf,_INSS]+aProvisao[_BxFer,_INSS]+aProvisao[_BxRes,_INSS]
			aProvisao[_BxTot,_FGTS] := aProvisao[_BxTrf,_FGTS]+aProvisao[_BxFer,_FGTS]+aProvisao[_BxRes,_FGTS]
			aProvisao[_BxTot,_PIS]  := aProvisao[_BxTrf,_PIS] +aProvisao[_BxFer,_PIS] +aProvisao[_BxRes,_PIS]
			//Ŀ
			//| Provisao do Mes												 |
			//
			aProvisao[_NoMes,_Prov] := aProvisao[_Atual,_Prov]-aProvisao[_Anter,_Prov]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_Prov], aProvisao[_BxTot,_Prov] )
			aProvisao[_NoMes,_Adic] := aProvisao[_Atual,_Adic]-aProvisao[_Anter,_Adic]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_Adic], aProvisao[_BxTot,_Adic] )
			If cPaisLoc == "URU"
				aProvisao[_NoMes,_SalV] := aProvisao[_Atual,_SalV]-aProvisao[_Anter,_SalV]+aProvisao[_BxTot,_SalV]
			Endif
			aProvisao[_NoMes,_1Ter] := aProvisao[_Atual,_1Ter]-aProvisao[_Anter,_1Ter]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_1Ter], aProvisao[_BxTot,_1Ter] )
			aProvisao[_NoMes,_INSS] := aProvisao[_Atual,_INSS]-aProvisao[_Anter,_INSS]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_INSS], aProvisao[_BxTot,_INSS] )
			aProvisao[_NoMes,_FGTS] := aProvisao[_Atual,_FGTS]-aProvisao[_Anter,_FGTS]+If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_FGTS], aProvisao[_BxTot,_FGTS] )
			aProvisao[_NoMes,_PIS]  := aProvisao[_Atual,_PIS] -aProvisao[_Anter,_PIS] +If( nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13o,_PIS],  aProvisao[_BxTot,_PIS]  )

			If lProvResc .And. nTpMov == _Demitido
				//Ŀ
				//| Zera a linha de provisao atual quando o funcionario estiver demitido|
				//| e o parametro MV_PROVRES estiver configurado com "S"                |
				//
				For nCnt1 := 1 To _Colunas
					aProvisao[_Atual,nCnt1]	:= 0
				Next nCnt1
			Endif
		
			If lTrfAMES
				//Ŀ
				//| Transfere o saldo anterior para a coluna Transf. Entrada	 |
				//
				If TPR->PR_TIPMOVI == _Trfe_Ent .Or. ((TPR->PR_TIPMOVI == _Anter) .And. (aProvisao[_BxRes,_Prov]+aProvisao[_BxRes,_Adic]+aProvisao[_Bx13o,_Prov]+aProvisao[_Bx13o,_Adic] <> 0) .And. (nPosTrf > 0))
					For nCnt1 := 1 To _Colunas
					If !lTrfEmpAmes
						aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
						aProvisao[_Anter,nCnt1]  := 0
					Else
						aProvisao[_NoMes,nCnt1] += aProvisao[_Anter,nCnt1]
						aProvisao[_Anter,nCnt1]  := 0	
					EndIf	
					Next nCnt1
					
					If aProvisao[_Bx13o,_Prov]+aProvisao[_Bx13o,_Adic] > 0
						aProvisao[_BxRes,_1Par] := 0
					EndIf	
				
				ElseIf  (nPosTrf > 0 .and. nTipoProv==2 .and. TPR->PR_TIPMOVI == _Anter)
		   			For nCnt1 := 1 To _Colunas
						aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
						aProvisao[_Anter,nCnt1]  := 0
					Next nCnt1  
		   			
				//Ŀ
				//| Transfere o saldo de Baixa por Transf. p/coluna Transf. Saida|
				//
				ElseIf TPR->PR_TIPMOVI == _Trfe_Sai
					For nCnt1 := 1 To _Colunas
						If !lTrfEmpAmes		// nao e transferencia entre empresas.
							aProvisao[_TrfSai,nCnt1] := aProvisao[_BxTrf,nCnt1]
							aProvisao[_BxTrf,nCnt1]  := 0
						Else
							aProvisao[_NoMes,nCnt1]  -= aProvisao[_BxTrf,nCnt1]
							aProvisao[_BxTrf,nCnt1]  := 0
						Endif
					Next nCnt1
					//-- Ajusta o valor da baixa da primeira parcela na linha de transferencia de saida
					//-- Devolve o valor para a linha No Mes
					//-- Tratamento exclusivo para 13o salario - 1a parcela
					If !lTrfEmpAmes .And. nTipoProv == _13Salar // nao e transferencia entre empresas.
						aProvisao[_TrfSai,_1Par]  := aProvisao[_Anter,_1Par]
						aProvisao[_NoMes,_1Par]   += aProvisao[_Anter,_1Par]
					Endif
				EndIf
			EndIf
			
		  	If lTrfSld .And. fChkIdent(aVerba,If(nTipoProv==2,1,nTipoProv),{_BxRes},.F.) .and. fChkIdent(aVerba,If(nTipoProv==2,1,nTipoProv),{_BxTrf},.F.)
				For nCnt1 := 1 To _Colunas
					aProvisao[_NoMes,nCnt1] := aProvisao[_Anter,nCnt1]
					aProvisao[_Anter,nCnt1]  := 0
				Next nCnt1
			EndIf
	
			//-- Salva o array processado
			If nTipoProv == 1 
				axFerVenc	:= aClone(aProvisao)
			ElseIf nTipoProv == 2
				axFerProp	:= aClone(aProvisao)
			ElseIf nTipoProv == 3
				ax13Salar	:= aClone(aProvisao)
			ElseIf nTipoProv == 4
				ax14Salar	:= aClone(aProvisao)
			Endif
		Endif

	Next nTipoProv

	//-- Devolve o array para o processo normal
	If lFerias
		aFerVenc	:= aClone(axFerVenc)
		aFerProp	:= aClone(axFerProp)
	Endif
	If l13oSal
		a13Salar	:= aClone(ax13Salar)
		a14Salar	:= aClone(ax14Salar)
	Endif
	
Endif 

If !lSoMes
	(cAliasSRT)->(dbCloseArea())
	If lQryAnt
		(cAliasAnt)->(dbCloseArea())
	EndIf
	dbSelectArea( cAlias )
Endif

Return Nil

/*


Ŀ
Funao	  fGeraSRT  Autor  Emerson R. de Souza	 Data  26.06.00 
Ĵ
Descriao  Grava os valores da provisao no arquivo SRT				  
Ĵ
Sintaxe	  fGeraSRT(aProvisao,aVerba,dDataRef,nTipoMovMes,nSalMes...) 
Ĵ
Parametros aProvisao	 - Array que contera os valores da provisao	  
           aVerba   	 - Verbas de Ferias / 13Sal / 14Sal         
           aRecnos   	 - Indica os recnos que serao avaliados       
           dDataRef   	 - Data de referencia p/ gravacao dos valores 
           nTipoMovMes 	 - Tipo de movimentacao no mes                |
           nSalMes  	 - Valor do salario no mes                    
           dDtBasFer  	 - Data base de ferias                        
           nDiaFeAnt  	 - Dias de ferias antecipadas                 
           nTipoProv	 - Tipo de provisao a buscar (Venc,Prop,13)  |
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fGeraSRT(aProvisao,aRecnos,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDiaFeAnt,nTipoProv)
Local cAlias    := Alias(), nTipo2, nTipo3, nCnt
Local nProvBus  := If(nTipoProv == _FerProp,_FerVenc,nTipoProv)
Local cChave	:= ""
Local cFilAux   := cFilAnt
Local lCabProp  := .F.
Local lGp070Grv := ExistBlock( "GP070GRV" )

//Ŀ
// Posiciona cFilAnt na filial corrente p/ garantir Integridade 
//
cFilAnt := TPR->PR_FILIAL

//Ŀ
// Se nao existir identificadores de baixa de rescisao,somar na |
// coluna de baixa de ferias e zerar coluna de baixa de rescisao|
//
fChkDemit(aProvisao,aVerba,nTipoProv,_BxFer,_BxRes)

//Ŀ
// Ponto de Entrada para checar registros perdidos no SRT.      |
//
If ExistBlock("GP070CHK")
	ExecBlock("GP070CHK",.F.,.F.)
Endif

//Ŀ
// Grava o array provisao no arquivo SRT                        
//
dbSelectArea( "SRT" )
If lItemClVl
	dbSetOrder(4)
Else
	dbSetOrder(1)
EndIf

For nTipo2 := 1 To _Linhas
	//Ŀ
	// Linhas que nao deverao ser gravadas no arquivo				 |
	//
	If nTipo2 == _Anter .Or. nTipo2 == _NoMes .Or. nTipo2 == _BxTot
		Loop
	EndIf

	//Ŀ
	// Grava as colunas de valores no arquivo detalhe               
	//
	For nTipo3 := 1 To _Colunas
		//Ŀ
		// Busca a verba e grava os lancamentos no arquivo detalhe      
		//
        nPosVerba := Ascan(aVerba, { |X| X[1] == nProvBus .And. X[2] == nTipo2 .And. X[3] == nTipo3 })
        cCodVerba := If( nPosVerba > 0, aVerba[nPosVerba,4], Space(3) )
		
        If !Empty(cCodVerba)
	        If ValType(aRecnos[nTipo2,nTipo3]) <> "U" .And. aRecnos[nTipo2,nTipo3] > 0
    	    	dbGoTo( aRecnos[nTipo2,nTipo3] )
        		RecLock( "SRT", .F. )
		    	If aProvisao[nTipo2,nTipo3] == 0
					dbDelete()
					MsUnlock()
					Loop
				EndIf
			Else
				If aProvisao[nTipo2,nTipo3] # 0
					RecLock( "SRT", .T. )
				Else
					Loop
				EndIf        
        	EndIf
			SRT->RT_FILIAL  := TPR->PR_FILIAL
			SRT->RT_MAT     := TPR->PR_MAT
			SRT->RT_CC      := TPR->PR_CC
			If lItemClVl
				SRT->RT_ITEM    := TPR->PR_ITEM
				SRT->RT_CLVL    := TPR->PR_CLVL
	        EndIf
			SRT->RT_TIPPROV := Str(nTipoProv,1)
			SRT->RT_VERBA   := cCodVerba
			SRT->RT_VALOR   := aProvisao[nTipo2,nTipo3]
			SRT->RT_DATACAL := dDataRef

		    //Ŀ
			// Ponto de Entrada para gravar campos personalizados do SRT.   |
			//
			If lGp070Grv
				ExecBlock( "GP070GRV", .F., .F., {TPR->PR_FILIAL, TPR->PR_MAT, nTipoProv} )
			Endif

			MsUnlock()
            
            //Gravao das baixas no arquivo de proviso mensal - RHT
            If lGeraPmes .And. ( nTipo2 == _BxTrf .Or. nTipo2 == _BxFer .Or. nTipo2 == _Bx13o .Or. nTipo2 == _BxRes)
            	fGeraBaixaMes()
            Endif
            
		    //integracao com modulo SIGAPCO
			PcoDetLan("000091","01","GPEA070")

		EndIf
	Next nTipo3
Next nTipo2

If lItemClVl
	cChave := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + TPR->PR_ITEM +  TPR->PR_CLVL + MesAno(dDataRef)
Else
	cChave := TPR->PR_FILIAL + TPR->PR_MAT + TPR->PR_CC + MesAno(dDataRef)
EndIf

//Ŀ
// Grava as informacoes de cabecalho						     
//
If dbSeek( cChave ) .Or. ( lCabProp := ( nTipoProv == _FerProp .And. aProvisao[_Anter,_Dias] > 0 ) )
	If lCabProp
		RecLock( "SRT", .T. )
		SRT->RT_FILIAL  := TPR->PR_FILIAL
		SRT->RT_MAT     := TPR->PR_MAT
		SRT->RT_CC      := TPR->PR_CC
		If lItemClVl
			SRT->RT_ITEM    := TPR->PR_ITEM
			SRT->RT_CLVL    := TPR->PR_CLVL
        EndIf
		SRT->RT_TIPPROV := Str(nTipoProv,1)
		SRT->RT_VERBA   := ""
		SRT->RT_VALOR   := 0.00
		SRT->RT_DATACAL := dDataRef
	Else
		RecLock( "SRT", .F. )
	EndIf
	SRT->RT_DATABAS := dDtBasFer
	SRT->RT_DFERANT := nDiaFeAnt
	SRT->RT_DFALVEN := nV_DFalFer
	SRT->RT_DFALPRO := nP_DFalFer
	SRT->RT_TIPMOVI := nTipoMovMes
	SRT->RT_SALARIO := nSalMes
	If nTipoProv == _FerVenc
		SRT->RT_DFERVEN := aProvisao[_Atual,_Dias]
	ElseIf nTipoProv == _FerProp
		SRT->RT_DFERPRO := aProvisao[_Atual,_Dias]
	ElseIf nTipoProv == _13Salar
		SRT->RT_AVOS13S := aProvisao[_Atual,_Avos]
	EndIf
	MsUnLock()
EndIf
dbSelectArea( cAlias )

//Ŀ
// Retorna filial original para o cFilAnt                       
//
cFilAnt := cFilAux

Return Nil

/*


Ŀ
Funao	  fGeraMes  Autor  Kelly Soares       	 Data  15.06.12 
Ĵ
Descriao  Grava os valores mensais da provisao no arquivo SRT       
Ĵ
Sintaxe	  fGeraMes(aProvisao,aVerba,dDataRef,nTipoMovMes,nSalMes...) 
Ĵ
Parametros aProvisao	 - Array que contera os valores da provisao	  
           aVerba   	 - Verbas de Ferias / 13Sal / 14Sal         
           aRecnos   	 - Indica os recnos que serao avaliados       
           dDataRef   	 - Data de referencia p/ gravacao dos valores 
           nTipoMovMes 	 - Tipo de movimentacao no mes                |
           nSalMes  	 - Valor do salario no mes                    
           dDtBasFer  	 - Data base de ferias                        
           nDiaFeAnt  	 - Dias de ferias antecipadas                 
           nTipoProv	 - Tipo de provisao a buscar (Venc,Prop,13)  |
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fGeraMes()

Local nX		:= 0
Local nC		:= 0
Local nPos		:= 0
Local nQtd		:= 0
Local nPerc		:= 0
Local nValDiv 	:= 0
Local nVlComp	:= 0
Local nValor  	:= 0
Local aArea	:= GetArea()

Private aRateio	:= {}

DbSelectArea("RHT")
DbSetOrder(1)

//Ŀ
// Carrega o rateio por centro de custo da tabela de Rateios - RHQ |
//
aRateio	:= {}

// Carrega os registros da tabela RHQ-Programacao de Rateio para pegar os percentuais x centro de custo
fRateio({},2, Substr(DtoS(dDataRef),1,4)+Substr(DtoS(dDataRef),5,2))

// Verifica o tamanho do retorno do array para criar ao menos um registro para a geracao
nQtd := Len(aRateio)

If nQtd == 0
	If lItemClVl
	   	aAdd(aRateio,{TPR->PR_CC, TPR->PR_ITEM, TPR->PR_CLVL, 100, "S", 0, ""})
	Else
	   	aAdd(aRateio,{TPR->PR_CC, Space(GetSx3Cache("RHQ_ITEM","X3_TAMANHO")), Space(GetSx3Cache("RHQ_CLVL","X3_TAMANHO")), 100, "S", 0, ""})
	Endif
	nQtd := 1
Else
	// Verifica se existem origens Sistemas (campo RHQ_ORIGEM = 'S') e tambem geradas pelo
	// usuario para considerar apenas os registros do tipo usuario (campos RHQ_ORIGEM = 'U'),
	// caso existir apenas um tipo, ira considerar o que existir
    If aScan(aRateio, { |X| X[5] == "S" })	> 0 .And. aScan(aRateio, { |X| X[5] == "U" })	> 0
	    For nC := 1 to Len(aRateio)
			If  ( nPosRateio := aScan(aRateio, { |X| X[5] == "S" })) > 0
				aDel(aRateio , nPosRateio)
				aSize(aRateio,Len(aRateio)-1)
			Endif
	    Next
		nQtd := Len(aRateio)
	Endif
Endif

For nX := 2 to _Colunas

//------------------------------------------------------------------------------------------//
// FERIAS VENCIDAS															 //
//------------------------------------------------------------------------------------------//
	nPos := aScan(aVerba,{|X| X[1] = _FerVMes .and. X[2] = _Atual .and. X[3] = nX})	
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//Rateio
			nValDiv := 0
			nVlComp := 0
			nValor  := aFerVenc[_NoMes,nX]
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round( nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif 
					
					nPerc := aRateio[nC,4]
					If nPerc < 1
						nPerc := nPerc * 100
					Endif
		
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )	
					If !RHT->(dbSeek(TPR->PR_FILIAL+TPR->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"1"+cCodVerba))
						RecLock( "RHT", .T. )
						RHT->RHT_FILIAL  := TPR->PR_FILIAL
						RHT->RHT_MAT     := TPR->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "1"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock( "RHT", .F. )
					Endif
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := nValDiv
					RHT->RHT_PERC	:= nPerc  
					If cCodVerba == aCodFol[960,1]
						RHT->RHT_DTBASE := dDtBasFer
					Endif
				
					MsUnlock()
				Next nC   
			Endif
		Endif		
	Endif

//------------------------------------------------------------------------------------------//
// FERIAS PROPORCIONAIS										 //
//------------------------------------------------------------------------------------------//
	nPos := aScan(aVerba,{|X| X[1] = _FerVMes .and. X[2] = _Atual .and. X[3] = nX})	
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//Rateio
			nValDiv := 0
			nVlComp := 0
			nValor  := aFerProp[_NoMes,nX]
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round( nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif
					  
					nPerc := aRateio[nC,4]
					If nPerc < 1
						nPerc := nPerc * 100
					Endif					
		
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )	
					If !RHT->(dbSeek(TPR->PR_FILIAL+TPR->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"2"+cCodVerba))
						RecLock( "RHT", .T. )
						RHT->RHT_FILIAL  := TPR->PR_FILIAL
						RHT->RHT_MAT     := TPR->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "2"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock( "RHT", .F. )
					Endif
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := nValDiv
					RHT->RHT_PERC	:= nPerc
					If cCodVerba == aCodFol[960,1]
						RHT->RHT_DTBASE := dDtBasFer
					Endif					
				
					MsUnlock()
				Next nC   
			Endif
		Endif		
	Endif


//------------------------------------------------------------------------------------------//
// 13 SALARIO																								 //
//------------------------------------------------------------------------------------------//
	nPos := aScan(aVerba,{|X| X[1] = _13SVMes .and. X[2] = _Atual .and. X[3] = nX})	
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//Rateio
			nValDiv := 0
			nVlComp := 0
			nValor  := a13Salar[_NoMes,nX] 
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round( nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif  
					
					nPerc := aRateio[nC,4]
					If nPerc < 1
						nPerc := nPerc * 100
					Endif
		
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )	
					If !RHT->(dbSeek(TPR->PR_FILIAL+TPR->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"3"+cCodVerba))
						RecLock( "RHT", .T. )
						RHT->RHT_FILIAL  := TPR->PR_FILIAL
						RHT->RHT_MAT     := TPR->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "3"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock( "RHT", .F. )
					Endif
					RHT->RHT_SALAR  	:= nSalMes
					RHT->RHT_DTCALC 	:= dDataRef
					RHT->RHT_VALOR  	:= nValDiv
					RHT->RHT_PERC		:= nPerc
				
					MsUnlock()
				Next nC      
			Endif
		Endif
	Endif

Next nX

RestArea(aArea)

Return nil

/*


Ŀ
Funao	  fChkIdent    Autor  Emerson R. de Souza Data  15.07.00 
Ĵ
Descriao  Verifica a existencia de identificadores                   
Ĵ
Sintaxe	  fChkIdent(aVerba,nTipProv,aTipId,lGeraLog)          		  
Ĵ
Parametros  aVerba   -Array com os identificadores a ser pesquisado   
            nTipProv -Tipo de provisao (Ferias,13,14)               
            aTipId   -Identificadores pesquisados(Trf,Res,Correcao)   
            lGeraLog -Indica se deve incluir o ident. em aIdProvis    
Ĵ
 Uso	 	  Generico   												  
ٱ

*/
Static Function fChkIdent(aVerba,nTipProv,aTipId,lGeraLog)
Local nCnt1, nCnt2, nPosElem, aElem := { _Prov, _Adic, _1Ter, _INSS, _FGTS }
Local aIdAuxTrf   := {}, lRet := .T.

//Ŀ
// Busca o Tipo de Provisao, Tipo de Identificador e Coluna da  
// Provisao. Se encontrou, verifica se cadastrou o identificador
//
For nCnt1  := 1 To Len(aTipId)
	nTipId := aTipId[nCnt1]
	For nCnt2 := 1 To Len(aElem)
		nPosElem := Ascan(aVerba, { |X| X[1] == nTipProv .And. X[2] == nTipId .And. X[3] == aElem[nCnt2] })
		//Ŀ
		// Array contendo as verbas nao cadastradas ou Ident. de Transf.
		//
		If nPosElem > 0
			If ( Type("aIdProvis") == "A" .And. lGeraLog )
				Aadd( aIdProvis, { aVerba[nPosElem,4], aVerba[nPosElem,5], nTipProv, nTipId } )
			EndIf
			If Empty(aVerba[nPosElem,4])
				lRet := .F.
			EndIf
		EndIf
	Next nCnt2
Next nCnt1

Return lRet

/*/


Ŀ
Funao	 fGrvArrPrv| Autor  Emerson Rosa de Souza  Data  15.07.00 
Ĵ
Descriao  Trata as baixas de transferencia e rescisao                
Ĵ
Sintaxe	  fGrvArrPrv(aProvisao, nElem1, nElem2, nIndice, aZerar)	  
Ĵ
Parametros aProvisao - Array contendo os valores da provisao		  
           nElem1    - Elemento que recebera o conteudo de gravacao	  |
           nElem2    - Elemento que sera gravado em nElem1         	  |
           nIndCorr  - Indice de correcao                          	  |
           aZerar	 - Elementos que deverao ser zerados		  	  |
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fGrvArrPrv(aProvisao, nElem1, nElem2, nIndCorr, aZerar)
Local  nCnt1	:= 0 

aProvisao[nElem1,_Dias] := Round( aProvisao[nElem2,_Dias] * nIndCorr, 2 )
aProvisao[nElem1,_Prov] := Round( aProvisao[nElem2,_Prov] * nIndCorr, 2 )
aProvisao[nElem1,_Adic] := Round( aProvisao[nElem2,_Adic] * nIndCorr, 2 )
If cPaisLoc == "URU"
	aProvisao[nElem1,_SalV] := NoRound( aProvisao[nElem2,_SalV] * nIndCorr )
Endif
aProvisao[nElem1,_1Ter] := Round( aProvisao[nElem2,_1Ter] * nIndCorr, 2 )
aProvisao[nElem1,_INSS] := Round( aProvisao[nElem2,_INSS] * nIndCorr, 2 )
aProvisao[nElem1,_FGTS] := Round( aProvisao[nElem2,_FGTS] * nIndCorr, 2 )
aProvisao[nElem1,_PIS]  := Round( aProvisao[nElem2,_PIS]  * nIndCorr, 2 )

For nCnt1 := 1 To Len(aZerar)
	aProvisao[ nElem1,aZerar[nCnt1]  ] := 0
Next nCnt1

Return Nil

/*/


Ŀ
Funao	 fMonta_TPR Autor  Emerson Rosa de Souza	 Data  02.03.00 
Ĵ
Descriao  Monta Arquivo de Trabalho para impressao da provisao       
Ĵ
Sintaxe	 fMonta_TPR(cTPRDbf,cTPRNtx,nOrdem,dDataRef,lSalInc,lTrataTrf
Ĵ
Parametros cTPRDbf   - Arquivo DBF temporario                         
           cTPRNtx   - Arquivo NTX temporario                         
           nOrdem    - Ordem de Calculo ou Impressao                  
           dDataRef  - Data de referencia para Calculo ou Impressao   
           lSalInc   - Indica se existe salario incorporado           
           lTrataTrf - Indica se deve tratar transferidos             
           aTransf   - Array que contera os transferidos no mes       
           lIncDemit - Indica se deve incluir os demitidos            
           cAcessaArq- Indica se tem dereito de acesso                
           lIncTodos - Indica se deve incluir todos os funcionarios   
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fMonta_TPR(cTPRDbf,cTPRNtx,nOrdem,dDataRef,lSalInc,lTrataTrf,aTransf,lIncDemit,cAcessaArq,lIncTodos,lTodosCpos)
Local nTpMv,cInicio,cFim,cIndCond,nK1,nK2,aVerbaProv,nPosFunc,nTrfProc, nPosFunc1
Local cSitFolh,cTipAfas,cCposQuery, cCusto, cCustoAtu
Local cClvl 		:= ""
Local cClvlAtu 		:= ""
Local cItem 		:= ""
Local cItemAtu 		:= ""
Local aCodFol := {},aStruSRA := {}
Local bChkSRA,bChkSRE
Local cAliasSRA		:= "SRA"
Local cOrdem		:= ""
Local nReg			:= 0
Local lTransfEmp	:= .F.
Local cAnoMesAtu,cDtIQryAtu,cDtFQryAtu,cLisVerbas,cCposGroup,cCposnOrd5,nK3,nTamArray,lTranfFil
Local aSRASRT		:= {}
Local nPR_TIPMOVI 	:= 0
Local cVerbaRPF 	:= ""
Local cVerbaRP13	:= ""
Local aVerbasTPR	:= {}
Local nVB			:= 0

lIncDemit  := If(lIncDemit  == Nil,  .T., lIncDemit)
lIncTodos  := If(lIncTodos  == Nil, .F., lIncTodos)
If Type("lItemClVl") == "U"
	lItemClVl := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13"
EndIf
lTodosCpos := If(lTodosCpos == Nil, .F., lTodosCpos)

//Ŀ
// Verifica se foi passado Bloco, String ou Nil				 |
//
If cAcessaArq == Nil .Or. Empty( cAcessaArq )
	bChkSRA := &( "{ || .T.}" )
	bChkSRE := &( "{ || .T.}" )
ElseIf ValType(cAcessaArq) == "B"
	cAcessaArq	:= StrTran( cAcessaArq, "SRA->","(cAliasSRA)->")   
	bChkSRA 	:= cAcessaArq
	bChkSRE 	:= &( "{ || .T.}" )
ElseIf ValType(cAcessaArq) == "C"
	cAcessaArq	:= StrTran( cAcessaArq, "SRA->","(cAliasSRA)->")   
	bChkSRA 	:= &( cAcessaArq )
	//Ŀ
	// Se houve C.Custo no filtro trocar pelo array aTransf.		 
	//
	If AT( "RA_CC", cAcessaArq ) > 0 
		cAcessaArq := STRTRAN(  cAcessaArq, "SRA->RA_CC", "aTransf[nK1,nTrfProc,_TCC]" )
	EndIf
	bChkSRE := &( cAcessaArq )
EndIf

//Ŀ
// Verifica a existencia dos identificadores de transferencia	 |
//
lTrataTrf := .F.
If Fp_CodFol(@aCodFol,cFilAnt)

	//Ŀ
	// Carrega os identificadores da provisao e testa se existem	 
	//
	fIdentProv(@aVerbaProv,aCodFol)

	//Ŀ
	// Verifica a existencia dos identificadores de transferencia	 
	//
	lTrataTrf := ( fChkIdent(aVerbaProv,_FerVenc,{_BxTrf},.F.) .And.;
					fChkIdent(aVerbaProv,_13Salar,{_BxTrf},.F.) )

	//Ŀ
	// Verifica a existencia dos identificadores da provisao Mes	 
	//
	If lGeraPMes .And. lTrataTrf
		lTrataTrf := ( 	fChkIdent(aVerba,_FerVMes,{_Atual},.F.) .And.;
						fChkIdent(aVerba,_13SVMes,{_Atual},.F.) )
	Endif
	
EndIf

//Ŀ
// Atualiza variaveis com os codigos das verbas de Rateio Provisao Mes 
//
If !Empty(cTpRtProv)
	cVerbaRPF 	:= "'"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"'"
	cVerbaRP13	:= "'"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"'"
Endif

//Ŀ
// Verificar se existe Campo Sal.Incorporado no cadastro      
//
dbSelectArea("SX3")
dbSetOrder( 2 )
If dbSeek("RA_SALINCO")
	lSalInc := .T.
Endif
lINSSAut := dbSeek("RA_INSSAUT")
dbsetOrder( 1 )

//-- campos da query
#IFDEF TOP 
	If lTodosCpos
		cCposQuery	:= "% * %"
	Else
		cCposQuery	:=	"RA_FILIAL, RA_MAT, RA_NOME, RA_CC, RA_CATFUNC, RA_ADMISSA, RA_SITFOLH, RA_AFASFGT, "+;
						"RA_DEMISSA, RA_TPCONTR, RA_HRSMES, RA_PERICUL, RA_ADTPOSE, RA_INSMIN, RA_INSMED, RA_INSMAX"
		cCposQuery	+= If(lSalInc,", RA_SALINCO","")
		cCposQuery	+= If(lItemClVl,", RA_ITEM, RA_CLVL","")
		If !Empty(cTpRtProv) .And. lItemClVl 
			cCposQuery	+= ", RHT_CC, RHT_ITEM, RHT_CLVL"
		ElseIf !Empty(cTpRtProv) .And. !lItemClVl 
			cCposQuery	+= ", RHT_CC"
		EndIf
		cCposQuery	+= If(lINSSAut,", RA_INSSAUT","")
		If !Empty(cTpRtProv)
			cCposnOrd5	:= If(nOrdem == 5 .AND. lItemClVl,", RHT_FILIAL, RHT_ITEM, RHT_CLVL, RHT_MAT",If(nOrdem == 5 .AND. !lItemClVl,", RHT_FILIAL, RHT_MAT",""))
		Else
			cCposnOrd5	:= If(nOrdem == 5 .AND. lItemClVl,", RT_FILIAL, RT_ITEM, RT_CLVL, RT_MAT",If(nOrdem == 5 .AND. !lItemClVl,", RT_FILIAL, RT_MAT",""))
		Endif
		cCposGroup	:=	"% "+cCposQuery+cCposnOrd5+" %"		
		cCposQuery	:=	"% "+cCposQuery+" %"

	Endif

	cAliasSRA	:= "QSRA"
	If ( Select( cAliasSRA ) > 0 )
		( cAliasSRA )->( dbCloseArea() )
	EndIf 

	aStruSRA 	:= SRA->(dbStruct())
	If !Empty(cTpRtProv)
		cOrdem		:= sqlorder(; 
								 If(nOrdem == 5 .AND. lItemClVl, "RHT_FILIAL, RHT_CC, RHT_ITEM, RHT_CLVL, RHT_MAT";
		                                                        , If(nOrdem == 5 .AND. !lItemClVl, "RHT_FILIAL, RHT_CC, RHT_MAT";
		                                                                                          , SRA->( IndexKey( If(nOrdem==4,8,nOrdem) ) ); 
		                                                             ); 
									);
		                        ) 
	Else 
		cOrdem		:= sqlorder(; 
								 If(nOrdem == 5 .AND. lItemClVl, "RT_FILIAL, RT_CC, RT_ITEM, RT_CLVL, RT_MAT";
		                                                        , If(nOrdem == 5 .AND. !lItemClVl, "RT_FILIAL, RT_CC, RT_MAT";
		                                                                                          , SRA->( IndexKey( If(nOrdem==4,8,nOrdem) ) ); 
		                                                             ); 
									);
		                        )	
	Endif		                        
	cOrdem		:= "% "+cOrdem+" %"
	cCatQuery := ""
	For nReg:=1 to Len(cCateg)
		cCatQuery += "'"+Subs(cCateg,nReg,1)+"'"
		If ( nReg+1 ) <= Len(cCateg)
			cCatQuery += "," 
		Endif
	Next nReg
	cCatQuery	:= "%" + cCatQuery + "%"
	cDemissa	:= "( SRA.RA_DEMISSA = '        ' OR SRA.RA_DEMISSA > '"+DTOS(dDataRef-day(dDataRef))+"' )"
	cDemissa	:= "% "+cDemissa+" %"

	If !Empty(cTpRtProv)

		cDtFQryAtu	:= MesAno( dDataRef ) +strzero(f_Ultdia(dDataRef),2)	
		If cTpRtProv == 'RPF'
			cLisVerbas	:= "%"+cVerbaRPF+"%"

			BeginSql alias cAliasSRA
				    SELECT %exp:cCposQuery%
				      FROM %table:SRA% SRA
				INNER JOIN %table:RHT% RHT
				        ON RHT.RHT_FILIAL = SRA.RA_FILIAL
		  			   AND RHT.RHT_MAT = SRA.RA_MAT
		  		INNER JOIN %table:SRF% SRF
		  			ON SRF.RF_FILIAL = RHT.RHT_FILIAL 
					 AND SRF.RF_MAT = RHT.RHT_MAT  
					 WHERE SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
						   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
						   SRA.RA_CC >= %exp:cCCDe% AND SRA.RA_CC <= %exp:cCCAte% AND
						   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
					       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
					       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND
					       %exp:cDemissa% AND				       
		     			   RHT.RHT_VERBA IN (%exp:cLisVerbas%) AND
		     			   RHT.RHT_DTCALC BETWEEN 
		     			   											CASE 
		     			   											WHEN SRF.RF_DATABAS > %exp:cDtFQryAtu%
		     			   												THEN SRA.RA_ADMISSA 
		     			   											ELSE SRF.RF_DATABAS
		     			   											END
		     			   											AND %exp:cDtFQryAtu% AND 
						   SRA.%notDel% AND
						   RHT.%notDel%
				  GROUP BY %exp:cCposGroup%  
			      ORDER BY %exp:cOrdem%
		 	EndSql	

		ElseIf cTpRtProv == 'RP13'
			cLisVerbas	:= "%"+cVerbaRP13+"%"

			cDtIQryAtu	:= StrZero(Ano( dDataRef  ),4)+"0101"
			
			BeginSql alias cAliasSRA
				    SELECT %exp:cCposQuery%
				      FROM %table:SRA% SRA
				INNER JOIN %table:RHT% RHT
				        ON RHT.RHT_FILIAL = SRA.RA_FILIAL
		  			   AND RHT.RHT_MAT = SRA.RA_MAT
		  		INNER JOIN %table:SRF% SRF
		  			ON SRF.RF_FILIAL = RHT.RHT_FILIAL 
					 AND SRF.RF_MAT = RHT.RHT_MAT  
					 WHERE SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
						   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
						   SRA.RA_CC >= %exp:cCCDe% AND SRA.RA_CC <= %exp:cCCAte% AND
						   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
					       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
					       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND
					       %exp:cDemissa% AND				       
		     			   RHT.RHT_VERBA IN (%exp:cLisVerbas%) AND
		     			   RHT.RHT_DTCALC BETWEEN %exp:cDtIQryAtu% AND %exp:cDtFQryAtu% AND
						   SRA.%notDel% AND
						   RHT.%notDel%
				  GROUP BY %exp:cCposGroup%  
			      ORDER BY %exp:cOrdem%
		 	EndSql	
			
		EndIf
	
	Else	
		BeginSql alias cAliasSRA
			SELECT %exp:cCposQuery%
			FROM %table:SRA% SRA
			WHERE  SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
				   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
				   SRA.RA_CC >= %exp:cCCDe% AND SRA.RA_CC <= %exp:cCCAte% AND
				   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
			       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
			       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND
			       %exp:cDemissa% AND
				   SRA.%notDel%   
			ORDER BY %exp:cOrdem%
	 	EndSql
	 EndIf

	//-- Ajusta a estrutura dos campos
	For nReg := 1 To Len(aStruSRA)
		If ( aStruSRA[nReg][2] <> "C" ) .And. If(!lTodosCpos,aStruSRA[nReg][1]$cCposQuery,.T.)
			TcSetField(cAliasSRA,aStruSRA[nReg][1],aStruSRA[nReg][2],aStruSRA[nReg][3],aStruSRA[nReg][4])
		EndIf
	Next nReg
#ELSE
	//Ŀ
	// Posiciona o SRA para a leitura e define indice para o TPR  
	//
	dbSelectArea( "SRA" )
	dbSetOrder( If(nOrdem == 4, 8, nOrdem) )
	If nOrdem == 1
		dbSeek( cFilDe + cMatDe, .T. )
	ElseIf nOrdem == 2
		dbSeek( cFilDe + cCcDe + cMatDe, .T. )
	ElseIf nOrdem == 3
		dbSeek( cFilDe + cNomeDe + cMatDe, .T. )
	ElseIf nOrdem == 4
		dbSeek( cFilDe + cCcDe + cNomeDe, .T. )
	Endif
#ENDIF

//-- Ordem do arquivo temporario
If nOrdem == 1
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cMatAte
	cIndCond := "PR_FILIAL + PR_MAT"
ElseIf nOrdem == 2
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cCcAte + cMatAte
	cIndCond := "PR_FILIAL + PR_CC + PR_MAT"	
ElseIf nOrdem == 3
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_NOME+"+(cAliasSRA)+"->RA_MAT"	
	cFim	 := cFilAte + cNomeAte + cMatAte
	cIndCond := "PR_FILIAL + PR_NOME + PR_MAT"	
ElseIf nOrdem == 4
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_NOME"
	cFim	 := cFilAte + cCcAte + cNomeAte
	cIndCond := "PR_FILIAL + PR_CC + PR_NOME"
ElseIf nOrdem == 5
	#IFDEF TOP 
		If !Empty(cTpRtProv)
			cInicio  :=  (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RHT_CC+"+(cAliasSRA)+"->RA_MAT"
	   	Else
	   		cInicio  :=  (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RT_CC+"+(cAliasSRA)+"->RA_MAT"
	   	Endif
	   	cFim	 :=  cFilAte + cCcAte + cMatAte
	   	cIndCond :=	 "PR_FILIAL + PR_CCMVTO + PR_MAT"	
	#ELSE
		cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_MAT"
		cFim	 := cFilAte + cCcAte + cMatAte
		cIndCond := "PR_FILIAL + PR_CC + PR_MAT"
	#ENDIF
ElseIf nOrdem == 6//"C.Custo + Item + Classe"
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cCcAte + cMatAte
	cIndCond := "PR_FILIAL + PR_CC + PR_ITEM + PR_CLVL + PR_MAT"
Endif

//Ŀ
// Monta Matriz com os Funcionarios Transferidos No Mes       |
//| Conteudo da Matriz - Empresa + Filial + CC + Matricula     |
//
aTransf := {}
fSeleTransf( @aTransf, dDataRef )

//Ŀ
// Cria o arquivo temporario "TPR" para impressao da provisao 
//
Cria_TPR(@cTPRDbf,@cTPRNtx,cIndCond)

//Ŀ
// Seleciona o SRA para a montagem do arquivo TPR			   
//
dbSelectArea( cAliasSRA )
    
//Ŀ
// Carrega Regua de Processamento						  
//
ProcRegua(RecCount())

While !Eof() .And. &cInicio <= cFim

	//Ŀ
	// Movimenta Regua de Processamento							 
	//
  	IncProc(STR0014) // "Selecionando Registros..."

	//Ŀ
	// Indica o tipo de movimento do funcionario				     
	//
	nTpMv 		:= 0
	lTransfEmp	:= .F.
	aSRASRT		:= {}
	aVerbasTPR	:= {}
	
	//Ŀ
	// Consiste Parametrizacao do Intervalo de Impressao			 
	//
	#IFNDEF TOP 
		If !lIncTodos
			If ((cAliasSRA)->RA_NOME < cNomeDe) .Or. ((cAliasSRA)->RA_NOME > cNomeAte) .Or. ;
				((cAliasSRA)->RA_MAT < cMatDe)	 .Or. ((cAliasSRA)->RA_MAT > cMatAte)	.Or. ;
				((cAliasSRA)->RA_CC < cCcDe)	 .Or. ((cAliasSRA)->RA_CC > cCCAte)
				dbSkip()
				Loop
			EndIf
			//Ŀ
			// Consiste Categoria do Funcionario              			     
			//
			If !((cAliasSRA)->RA_CATFUNC $ cCateg)
				dbSkip()
				Loop
			EndIf
			//Ŀ
			// Consiste Admissao do Funcionario              			     
			//
			If (cAliasSRA)->RA_ADMISSA > dDataRef
				dbSkip()
				Loop
			EndIf
		Endif
	#ENDIF
	
	If !Empty(cTpRtProv)
		//Ŀ
		// Verifica se esta afastado na data de referencia do calculo	 
		//
		cSitFolh := cTipAfas := ""
		fChkAfas((cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,dDataRef,,,@cTipAfas)
		cSitFolh := If( !Empty(cTipAfas) .And. cTipAfas # "F", "A", cSitFolh)
		
		#IFDEF TOP 
			If lItemClVl
				aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
				(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,(cAliasSra)->RA_TPCONTR,;
				(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),(cAliasSra)->RHT_CC,;
				(cAliasSra)->RA_INSMIN,(cAliasSra)->RA_INSMED,(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE,;
				(cAliasSra)->RHT_ITEM,(cAliasSra)->RHT_CLVL})
			Else
				aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
				(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,(cAliasSra)->RA_TPCONTR,;
				(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),(cAliasSra)->RHT_CC,;
				(cAliasSra)->RA_INSMIN,(cAliasSra)->RA_INSMED,(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE})				
			EndIf
		#ELSE

			RHT->( dbSetOrder( RetOrdem( "RHT" , "RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV" ) ) )	
			If RHT->(dbSeek( (cAliasSra)->RA_FILIAL +(cAliasSra)->RA_MAT + DTOS(dDataRef) + If(cTpRtProv == 'RPF',"1","3") ))

				cVerbaSRT := ""
				If cTpRtProv == 'RPF'
					cVerbaSRT	:= "("+cVerbaRPF+")"
				ElseIf cTpRtProv == 'RP13'
					cVerbaSRT	:= "("+cVerbaRP13+")"
				EndIf

				While RHT->(!Eof()) .And. RHT->RHT_FILIAL + RHT->RHT_MAT + DTOS(RHT->RHT_DTCALC) == (cAliasSra)->RA_FILIAL +(cAliasSra)->RA_MAT + DTOS(dDataRef) 

					If RHT->RHT_VERBA $ cVerbaSRT .And. ( If(cTpRtProv == 'RPF', RHT->RHT_TPPROV $ "1,2", RHT->RHT_TPPROV == "3"))
						If aScan(aSRASRT,{ |x| x[1]+x[2]+x[3]+x[13] ==(cAliasSra)->RA_FILIAL+(cAliasSra)->RA_MAT+(cAliasSra)->RA_CC+RHT->RHT_CC } ) == 0
							If lItemClVl
								aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
								(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,(cAliasSra)->RA_TPCONTR,;
								(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),RHT->RHT_CC,;
								(cAliasSra)->RA_INSMIN,(cAliasSra)->RA_INSMED,(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE,;
								RHT->RHT_ITEM,RHT->RHT_CLVL})
							Else
								aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
								(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,(cAliasSra)->RA_TPCONTR,;
								(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),RHT->RHT_CC,;
								(cAliasSra)->RA_INSMIN,(cAliasSra)->RA_INSMED,(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE})
							EndIf
						Endif
					Endif
					RHT->(dbSkip())
				Enddo
			Endif

		#ENDIF		 
	EndIf 
	
	If !lIncTodos
		cCusto 		:=  ""
		cCustoAtu	:=  ""
		cClvl 		:=  ""
		cClvlAtu 	:=  ""
		cItem 		:=  ""
		cItemAtu 	:=  ""
		
		//Ŀ
		// Consiste controle de acessos e filiais validas               
		//
		If !((cAliasSRA)->RA_FILIAL $ fValidFil()) .Or. !Eval(bChkSRA)
			dbSkip()
			Loop
		EndIf
		//Ŀ
		// Consiste Demissao e Transferencia (Se for Transferencia saida
		// despreza o funcionario pois sera tratado no array aTransf.   
		//
		If (cAliasSRA)->RA_SITFOLH == "D"                                     
			//Ŀ
			// Se transf. saida no Mes/Ano e nao encontrar no array ou      
			// o lTransfEmp for .T. (empresa anterior e empresa destino,    
			// for diferente) indica que e uma transferencia entre empresas 
			// e devera ser incluido mov. saida							 
			//
	     	nPosFunc := Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TMat] == FWGrpCompany("SRA")+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT })

  	  	  	If nPosFunc > 0
				lTransfEmp	:= aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp] .And. aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TAtual,_TEmp]
  				cCusto  	:= aTransf[nPosFunc,_TAnter,_TCC] // Centro de custo anterior
			    cCustoAtu	:= aTransf[nPosFunc,_TAtual,_TCC] // Centro de custo atual				
  				If lItemClVl
					cItem  		:= aTransf[nPosFunc,_TAnter,_TItm]// Item anterior
					cItemAtu	:= aTransf[nPosFunc,_TAtual,_TItm]// Item atual
					cClvl   	:= aTransf[nPosFunc,_TAnter,_TClv]// Classe anterior
					cClvlAtu	:= aTransf[nPosFunc,_TAtual,_TClv]// Classe atual
				EndIf
 	 	  	Else
				lTransfEmp	:= .F.       
			//Ŀ
			// Se nao for transferencia empresa, filial+matricula anterior igual RA_FILIAL+RA_MAT,    
			// EMPRESA + FILIAL anterior diferente da EMPRESA + FILIAL Destino, e MES\ANO ATUAL       
			//	IGUAL ao MES\ANO DESTINO,  utilizar C.CUSTO do atransf  anterior, e marcar funcionario 
			// para que nao ser incluido (analise feita na parte "Inclui os transferidos entre CC	   
 			//  no arquivo de provisao" - analise das transferencias )		                           
			//
 				nPosFunc1 := Ascan(aTransf, { |X| X[_TAnter,_TEmp] == FWGrpCompany("SRA") .And. X[_TAnter,_TFil]+X[_TAnter,_TMat] == (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT })
				If nPosFunc1 > 0 .and. aTransf[nPosFunc1,_TAnter,_TEmp]+aTransf[nPosFunc1,_TAnter,_TFil] <> aTransf[nPosFunc1,_TDest,_TEmp]+aTransf[nPosFunc1,_TDest,_TFil] .and. ;
									   aTransf[nPosFunc1,_TAtual,_TDta] == aTransf[nPosFunc1,_TDest,_TDta]
					cCusto := aTransf[nPosFunc1,_TAnter,_TCC] // Centro de custo anterior
					If lItemClVl
						cItem  := aTransf[nPosFunc1,_TAnter,_TItm]// Item anterior
						cClvl  := aTransf[nPosFunc1,_TAnter,_TClv]// Classe anterior
					EndIf
					aTransf[nPosFunc1,_TAnter,_TInc] := .T.  // Marca funcionario para que nao seja incluido
					If ( aTransf[nPosFunc1,_TAnter,_TEmp] <> aTransf[nPosFunc1,_TDest,_TEmp] )
						lTransfEmp	:= .T.       
            		EndIf
				Else	
					cCusto:= (cAliasSRA)->RA_CC
					If lItemClVl
						cItem := (cAliasSRA)->RA_ITEM 
						cClvl := (cAliasSRA)->RA_CLVL                    
					EndIf
				EndIf	                
			EndIf		          

			//Ŀ
			// Nao gravar movimento se for mes\ano da transferencia, nao utiliza identificador 
			// de baixa de transferencia e nao seja transferencia entre empresas.              
			//
			If !lTrataTrf .and. !lTransfEmp .and. ; 
				MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. ( (cAliasSRA)->RA_AFASFGT $ "5*N" ) .And. (nPosFunc == 0 .Or. (nPosFunc > 0 .And. lTransfEmp)) 
				dbSkip()
				Loop
			EndIf

		  //Ŀ
  		  // Na transferencia por empresa, verificar se mes\ano transf. e o mesma que mes\ano de ref. para  
		  //garantir na empresa origem a movimentacao de saida, independente do destino (ultima transf).    
  		  //
		If	( ( (nPosFunc > 0 .And.lTransfEmp ).And. ;
						( aTransf[nPosFunc,_TAnter,_TDta] == aTransf[nPosFunc,_TAtual,_TDta] ) .and. ;
						( aTransf[nPosFunc,_TAtual,_TDta] == MesAno(dDataRef) )	);
					.Or. (MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. (cAliasSRA)->RA_AFASFGT $ "5*N" .And. (nPosFunc == 0 .Or.	(nPosFunc > 0 .And. lTransfEmp) ) ) )
				nTpMv := _Trfe_Sai
			ElseIf MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. !( (cAliasSRA)->RA_AFASFGT $ "5*N" ) .And. lIncDemit
				nTpMv := _Demitido
			ElseIf MesAno((cAliasSRA)->RA_DEMISSA) < MesAno(dDataRef) .Or. (( (cAliasSRA)->RA_AFASFGT $ "5*N" ) .And. nPosFunc > 0 .And. !lTransfEmp) .Or.;
				   (MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. !lIncDemit) .OR. ;
				   (MesAno((cAliasSRA)->RA_DEMISSA) > MesAno(dDataRef) .and. (cAliasSRA)->RA_AFASFGT $ "5*N" )
				dbSkip()
				Loop
			EndIf
		EndIf
	EndIf
    
	If Empty(cTpRtProv)
		//Ŀ
		// Verifica se funcionario foi transferido apos data referencia 
		//
		nPosFunc := Ascan(aTransf, { |X| X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TCC]+X[_TDest,_TMat] == FWGrpCompany("SRA")+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_CC+(cAliasSRA)->RA_MAT })
		If nPosFunc > 0
			If !(;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]  ;
				)
	
				If aTransf[nPosFunc,_TDest,_TDta] > MesAno(dDataRef) // data de transferencia maior que data de processamento
					aTransf[nPosFunc,_TDest,_TInc] := .T.  // Marca funcionario para que nao seja incluido
					dbSelectArea( cAliasSRA )
					dbSkip()
					Loop
				EndIf
			EndIf
			aTransf[nPosFunc,_TDest,_TInc] := .T.  // Marca funcionario para que nao seja incluido
		EndIf	
	Endif

	//Ŀ
	// Verifica se e Transferencia Entrada  						 
	//
	If nTpMv == 0
		nPosFunc := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == FWGrpCompany("SRA")+((cAliasSRA)->RA_FILIAL)+(cAliasSRA)->RA_CC+(cAliasSRA)->RA_MAT })
		//Ŀ
		// Se transferido apos data de referencia, despreza funcionario,
		// caso contrario, marca transf. entrada para calculo/impressao 
		//
		If nPosFunc > 0
			If !(;
				( lItemClVl .And.;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat]+aTransf[nPosFunc,_TAtual,_TItm]+aTransf[nPosFunc,_TAtual,_TClv] == ;
				aTransf[nPosFunc,_TAnter,_TEmp]+aTransf[nPosFunc,_TAnter,_TFil]+aTransf[nPosFunc,_TAnter,_TCC]+aTransf[nPosFunc,_TAnter,_TMat]+aTransf[nPosFunc,_TAnter,_TItm]+aTransf[nPosFunc,_TAnter,_TClv] .And. ;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat]+aTransf[nPosFunc,_TAtual,_TItm]+aTransf[nPosFunc,_TAtual,_TClv] == ;
				aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]+aTransf[nPosFunc,_TDest ,_TItm]+aTransf[nPosFunc,_TDest ,_TClv]  ;
				);				
				.Or.;
				( !lItemClVl .And.; 
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				aTransf[nPosFunc,_TAnter,_TEmp]+aTransf[nPosFunc,_TAnter,_TFil]+aTransf[nPosFunc,_TAnter,_TCC]+aTransf[nPosFunc,_TAnter,_TMat] .And. ;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]  ;
				);
				)
				If aTransf[nPosFunc,_TAtual,_TDta] == MesAno(dDataRef)
					nTpMv := _Trfe_Ent 						 // Transferencia Entrada
					aTransf[nPosFunc,_TAtual,_TInc] := .T.  // Marca funcionario para que nao seja incluido
				ElseIf !(aTransf[nPosFunc,_TAtual,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp]) 
					dbSelectArea( cAliasSRA )
					dbSkip()
					Loop
				EndIf
			EndIf
		EndIf
	EndIf
    
	If Empty(cTpRtProv)
		//Ŀ
		// Verifica se esta afastado na data de referencia do calculo	 
		//
		cSitFolh := cTipAfas := ""
		fChkAfas((cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,dDataRef,,,@cTipAfas)
		cSitFolh := If( !Empty(cTipAfas) .And. cTipAfas # "F", "A", cSitFolh)
	Else
		If ( nTpMv <> 6 .And. nTpMv <> 0 )   // Trans.Entrada ou Demissao	
			dbSelectArea( cAliasSRA )
			dbSkip()
			Loop		
		Endif
	EndIf

	#IFDEF TOP 
	
		dbSelectArea( "TPR" )
	    RecLock( "TPR", .T. )
		TPR->PR_FILIAL  := (cAliasSRA)->RA_FILIAL
		TPR->PR_MAT     := (cAliasSRA)->RA_MAT
		TPR->PR_NOME    := (cAliasSRA)->RA_NOME
	
		If Empty(cCusto)
			TPR->PR_CC	:= (cAliasSRA)->RA_CC
		Else
			If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
				TPR->PR_CC	:= If(Empty(cCustoAtu), cCusto, cCustoAtu)  //Gravar c.custo atual
	  		Else
				TPR->PR_CC	:= cCusto     //Gravar c.custo da origem 
			EndIf
		EndIf
			
		If lItemClVl
			If Empty(cItem)
				TPR->PR_ITEM    := (cAliasSRA)->RA_ITEM
			Else
				If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
					TPR->PR_ITEM	:= If(Empty(cItemAtu), cItem, cItemAtu)  //Gravar item atual
		  		Else
					TPR->PR_ITEM	:= cItem     //Gravar item da origem 
				EndIf			
			EndIf  
			If Empty(cClvl)
				TPR->PR_CLVL    := (cAliasSRA)->RA_CLVL
			Else
				If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
					TPR->PR_CLVL	:= If(Empty(cClvlAtu), cClvl, cClvlAtu)  //Gravar classe atual
		  		Else
					TPR->PR_CLVL	:= cClvl     //Gravar classe da origem 
				EndIf				
			EndIf  
		EndIf
		TPR->PR_ADMISSA := (cAliasSRA)->RA_ADMISSA
		TPR->PR_DEMISSA := (cAliasSRA)->RA_DEMISSA
		TPR->PR_SITFOLH := cSitFolh
		TPR->PR_AFASFGT := cTipAfas
		TPR->PR_TPCONTR := (cAliasSRA)->RA_TPCONTR
		TPR->PR_HRSMES  := (cAliasSRA)->RA_HRSMES
		TPR->PR_PERICUL := (cAliasSRA)->RA_PERICUL
		TPR->PR_INSMIN	:= (cAliasSra)->RA_INSMIN
		TPR->PR_INSMED	:= (cAliasSra)->RA_INSMED
		TPR->PR_INSMAX	:= (cAliasSra)->RA_INSMAX
		TPR->PR_ADTPOSE	:= (cAliasSra)->RA_ADTPOSE
		TPR->PR_TIPMOVI := nTpMv  // Demitido, Transf. Saida ou Transf. Entrada
		If lSalInc
			TPR->PR_SALINCO := (cAliasSRA)->RA_SALINCO
		EndIf
		If !Empty(cTpRtProv) 
			TPR->PR_CCMVTO := (cAliasSRA)->RHT_CC
			If lItemClVl
				TPR->PR_ITMMVTO := (cAliasSRA)->RHT_ITEM
				TPR->PR_CLVMVTO := (cAliasSRA)->RHT_CLVL			
			EndIf
		EndIf	
		If lINSSAut
			TPR->PR_INSSAUT := (cAliasSRA)->RA_INSSAUT	
		EndIf
		MsUnlock()

	#ELSE
		If !Empty(cTpRtProv) 
			dbSelectArea( "TPR" )
			
			RHT->( dbSetOrder( RetOrdem( "RHT" , "RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV" ) ) )	
			If RHT->(dbSeek( (cAliasSra)->RA_FILIAL +(cAliasSra)->RA_MAT + DTOS(dDataRef)))

				cVerbaSRT := ""
				If cTpRtProv == 'RPF'
					cVerbaSRT	:= "("+cVerbaRPF+")"
				ElseIf cTpRtProv == 'RP13'
					cVerbaSRT	:= "("+cVerbaRP13+")"
				EndIf

				While RHT->(!Eof()) .And. RHT->RHT_FILIAL + RHT->RHT_MAT + DTOS(RHT->RHT_DTCALC) == (cAliasSra)->RA_FILIAL +(cAliasSra)->RA_MAT + DTOS(dDataRef)

					If RHT->RHT_VERBA $ cVerbaSRT

						If aScan(aVerbasTPR,{ |x| x[1]+x[2]+x[4]+x[5]+x[6]+x[7] ==(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT+(cAliasSRA)->RA_CC+RHT->RHT_ITEM+RHT->RHT_CLVL+RHT->RHT_CC } ) == 0

							aAdd(aVerbasTPR,{ (cAliasSRA)->RA_FILIAL,;
												(cAliasSRA)->RA_MAT,;
												(cAliasSRA)->RA_NOME,;
												(cAliasSRA)->RA_CC,;
												RHT->RHT_ITEM ,;
												RHT->RHT_CLVL,;
												RHT->RHT_CC,;
												(cAliasSRA)->RA_ADMISSA,;
												(cAliasSRA)->RA_DEMISSA,;
												cSitFolh,;
												cTipAfas,;
												(cAliasSRA)->RA_TPCONTR,;
												(cAliasSRA)->RA_HRSMES,;
												(cAliasSRA)->RA_PERICUL,;
												(cAliasSra)->RA_INSMIN,;
												(cAliasSra)->RA_INSMED,;
												(cAliasSra)->RA_INSMAX,;
												(cAliasSra)->RA_ADTPOSE,;
												nTpMv,;  // Demitido, Transf. Saida ou Transf. Entrada
												If(lSalInc,(cAliasSRA)->RA_SALINCO,0),;
												If(lINSSAut,(cAliasSRA)->RA_INSSAUT,0)})
                        Endif
                    Endif
					RHT->(dbSkip())
                Enddo    

				If Len(aVerbasTPR) > 0
												
					For nVB := 1 to Len(aVerbasTPR)
					
						dbSelectArea( "TPR" )
					    RecLock( "TPR", .T. )
						TPR->PR_FILIAL  := aVerbasTPR[ nVB , 1]
						TPR->PR_MAT     := aVerbasTPR[ nVB , 2]
						TPR->PR_NOME    := aVerbasTPR[ nVB , 3]
						TPR->PR_CC		:= aVerbasTPR[ nVB , 4]
						TPR->PR_ITEM    := aVerbasTPR[ nVB , 5]
						TPR->PR_CLVL    := aVerbasTPR[ nVB , 6]
						TPR->PR_CCMVTO	:= aVerbasTPR[ nVB , 7]
						TPR->PR_ADMISSA := aVerbasTPR[ nVB , 8]
						TPR->PR_DEMISSA := aVerbasTPR[ nVB , 9]
						TPR->PR_SITFOLH := aVerbasTPR[ nVB ,10]
						TPR->PR_AFASFGT := aVerbasTPR[ nVB ,11]
						TPR->PR_TPCONTR := aVerbasTPR[ nVB ,12]
						TPR->PR_HRSMES  := aVerbasTPR[ nVB ,13]
						TPR->PR_PERICUL := aVerbasTPR[ nVB ,14]
						TPR->PR_INSMIN	:= aVerbasTPR[ nVB ,15]
						TPR->PR_INSMED	:= aVerbasTPR[ nVB ,16]
						TPR->PR_INSMAX	:= aVerbasTPR[ nVB ,17]
						TPR->PR_ADTPOSE	:= aVerbasTPR[ nVB ,18]
						TPR->PR_TIPMOVI := aVerbasTPR[ nVB ,19]
						TPR->PR_SALINCO := aVerbasTPR[ nVB ,20]
						TPR->PR_INSSAUT := aVerbasTPR[ nVB ,21]
						TPR->PR_ITMMVTO	:= aVerbasTPR[ nVB , 5]
						TPR->PR_CLVMVTO	:= aVerbasTPR[ nVB , 6]
	
						MsUnlock()

	                Next
				Endif
			Endif
		Else

			dbSelectArea( "TPR" )
		    RecLock( "TPR", .T. )
			TPR->PR_FILIAL  := (cAliasSRA)->RA_FILIAL
			TPR->PR_MAT     := (cAliasSRA)->RA_MAT
			TPR->PR_NOME    := (cAliasSRA)->RA_NOME
		
			If Empty(cCusto)
				TPR->PR_CC	:= (cAliasSRA)->RA_CC
			Else
				If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
					TPR->PR_CC	:= If(Empty(cCustoAtu), cCusto, cCustoAtu)  //Gravar c.custo atual
		  		Else
					TPR->PR_CC	:= cCusto     //Gravar c.custo da origem 
				EndIf
			EndIf
				
			If lItemClVl
				If Empty(cItem)
					TPR->PR_ITEM    := (cAliasSRA)->RA_ITEM
				Else
					If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
						TPR->PR_ITEM	:= If(Empty(cItemAtu), cItem, cItemAtu)  //Gravar item atual
			  		Else
						TPR->PR_ITEM	:= cItem     //Gravar item da origem 
					EndIf			
				EndIf  
				If Empty(cClvl)
					TPR->PR_CLVL    := (cAliasSRA)->RA_CLVL
				Else
					If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
						TPR->PR_CLVL	:= If(Empty(cClvlAtu), cClvl, cClvlAtu)  //Gravar classe atual
			  		Else
						TPR->PR_CLVL	:= cClvl     //Gravar classe da origem 
					EndIf				
				EndIf  
			EndIf
			TPR->PR_ADMISSA := (cAliasSRA)->RA_ADMISSA
			TPR->PR_DEMISSA := (cAliasSRA)->RA_DEMISSA
			TPR->PR_SITFOLH := cSitFolh
			TPR->PR_AFASFGT := cTipAfas
			TPR->PR_TPCONTR := (cAliasSRA)->RA_TPCONTR
			TPR->PR_HRSMES  := (cAliasSRA)->RA_HRSMES
			TPR->PR_PERICUL := (cAliasSRA)->RA_PERICUL
			TPR->PR_INSMIN	:= (cAliasSra)->RA_INSMIN
			TPR->PR_INSMED	:= (cAliasSra)->RA_INSMED
			TPR->PR_INSMAX	:= (cAliasSra)->RA_INSMAX
			TPR->PR_ADTPOSE	:= (cAliasSra)->RA_ADTPOSE
			TPR->PR_TIPMOVI := nTpMv  // Demitido, Transf. Saida ou Transf. Entrada
			If lSalInc
				TPR->PR_SALINCO := (cAliasSRA)->RA_SALINCO
			EndIf
			If lINSSAut
				TPR->PR_INSSAUT := (cAliasSRA)->RA_INSSAUT
			EndIf
			MsUnlock()
		
        Endif
    #ENDIF

	dbSelectArea( cAliasSRA )
	dbSkip()
EndDo

//Ŀ
// Garante Ordem 1 Para Busca dos Funcionarios				   
//
dbSelectArea( "SRA" )
dbSetOrder(1)

//Ŀ
// Inclui os transferidos entre CC no arquivo de provisao
//
For nK1 := 1 To Len(aTransf)
	dbSelectArea( "SRA" )
	If ( dbSeek(aTransf[nK1,_TDest,_TFil] + aTransf[nK1,_TDest,_TMat] ) .And. ;
			 aTransf[nK1,_TDest,_TEmp] == FWGrpCompany("SRA") ) .OR. ;
			 ( dbSeek(aTransf[nK1,_TAtual,_TFil] + aTransf[nK1,_TAtual,_TMat] ) .And. ;
			 aTransf[nK1,_TAtual,_TEmp] == FWGrpCompany("SRA") )

		If (SRA->RA_SITFOLH == "D" .And. (MesAno(SRA->RA_DEMISSA) <= MesAno(dDataRef) .and.;
			MesAno(SRA->RA_DEMISSA) < aTransf[nK1,_TAtual,_TDta] ) .and. !(SRA->RA_AFASFGT $ "5*N" ) ) 
			Loop
		EndIf
		//Ŀ
		// Consiste Categoria e Demissao do Funcionario   			     
		//
		If !(SRA->RA_CATFUNC $ cCateg) .Or. ( SRA->RA_SITFOLH == "D" .And.;
		   MesAno(SRA->RA_DEMISSA) < MesAno(dDataRef) )
			Loop
		EndIf                
	
		For nK2 := 1 To 2
				
			nTrfProc := If(nK2 == 1, _TAnter, _TAtual)

			//Ŀ
			// Verificacao do elemento ANTERIOR do array aTransf            
			//
			If nK2 == 1
				//Ŀ
				// Se nao trata transferido, nao incluir transferencia ORIGEM   
				// efetuada no mes de processamento. Somente incluir posteriores
				//
				If !lTrataTrf .And. aTransf[nK1,_TAnter,_TDta] == MesAno(dDataRef)
					Loop
				EndIf   
				
				//Ŀ
				// Verifica se os elementos ANTERIOR e ATUAL sao iguais ou se a 
				// transferencia ANTERIOR para ATUAL foi entre filial.          
				//
				If ( ( lItemClVl .And. aTransf[nK1,_TAnter,_TFil]+aTransf[nK1,_TAnter,_TCC]+aTransf[nK1,_TAnter,_TMat]+aTransf[nK1,_TAnter,_TItm]+aTransf[nK1,_TAnter,_TClv] ==;
				    aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]+aTransf[nK1,_TAtual,_TItm]+aTransf[nK1,_TAtual,_TClv] ) ;
					.Or.;
					( !lItemClVl .And. aTransf[nK1,_TAnter,_TFil]+aTransf[nK1,_TAnter,_TCC]+aTransf[nK1,_TAnter,_TMat]==;
				    aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat] ) ) .or. ;
				    aTransf[nK1,_TAnter,_TInc] .or. ;
				    aTransf[nK1,_TAnter,_TEmp] <> FWGrpCompany("SRA") 
				    Loop
				EndIf
			Else
				//Ŀ
				// Verifica se ATUAL == DESTINO e ja inclui DESTINO ou  		 
				// se a empresa atual e diferente da empresa corrente       	 
				//
				If (;
					( lItemClVl .And. aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]+aTransf[nK1,_TAtual,_TItm]+aTransf[nK1,_TAtual,_TClv]==;
				     aTransf[nK1,_TDest,_TFil]+aTransf[nK1,_TDest,_TCC]+aTransf[nK1,_TDest,_TMat]+aTransf[nK1,_TDest,_TItm]+aTransf[nK1,_TDest,_TClv] .And. aTransf[nK1,_TDest,_TInc]) .Or. ;					 
					( !lItemClVl .And. aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]==;
				     aTransf[nK1,_TDest,_TFil]+aTransf[nK1,_TDest,_TCC]+aTransf[nK1,_TDest,_TMat] .And. aTransf[nK1,_TDest,_TInc]) ) .Or. ;
				     ( aTransf[nK1,_TAtual,_TEmp] <> FWGrpCompany("SRA") )
				    Loop
				EndIf
			EndIf

			//Ŀ
			// Consiste parametros selecionado pelo usuario				 
			//
			If 	(aTransf[nK1,nTrfProc,_TFil]  < cFilDe) .Or. (aTransf[nK1,nTrfProc,_TFil] > cFilAte ) .Or. ;
				(aTransf[nK1,nTrfProc,_TCC]  < cCcDe)	.Or. (aTransf[nK1,nTrfProc,_TCC]  > cCCAte)  .Or. ;
				(aTransf[nK1,nTrfProc,_TMat] < cMatDe)	.Or. (aTransf[nK1,nTrfProc,_TMat] > cMatAte) .Or. ;
				(SRA->RA_NOME < cNomeDe) .Or. (SRA->RA_NOME > cNomeAte)
				Loop
			EndIf

			//Ŀ
			// Consiste controle de acessos e filiais validas               
			//
			If !SRA->( Eval( bChkSRE ) )
				Loop
			EndIf

			//Ŀ
			// Verifica se funcionario ja foi incluido        			     
			//
		   	dbSelectArea( "TPR" )
			If !aTransf[nK1,nTrfProc,_TInc]

				nPR_TIPMOVI := 0
				//Ŀ
				// Se transferido no mes/ano da referencia, indica saida.
				//
				If nK2 == 1 .And. aTransf[nK1,_TAnter,_TDta] == MesAno(dDataRef)
					nPR_TIPMOVI := _Trfe_Sai
				ElseIf nK2 == 2 .And. aTransf[nK1,_TAtual,_TDta] == MesAno(dDataRef) .And.;
				  aTransf[nK1,_TAnter,_TEmp] + aTransf[nK1,_TAnter,_TFil] + aTransf[nK1,_TAnter,_TCC] + aTransf[nK1,_TAnter,_TMat] #;
				  aTransf[nK1,_TAtual,_TEmp] + aTransf[nK1,_TAtual,_TFil] + aTransf[nK1,_TAtual,_TCC] + aTransf[nK1,_TAtual,_TMat]
					nPR_TIPMOVI := _Trfe_Ent
				EndIf
				//Verifica a situacao folha e o tipo de afastamento na competencia de calculo
				cSitFolh := cTipAfas := ""
				fChkAfas( aTransf[nK1,nTrfProc,_TFil], aTransf[nK1,nTrfProc,_TMat], dDataRef, Nil, Nil, @cTipAfas)
				cSitFolh := If( !Empty(cTipAfas) .And. cTipAfas != "F", "A", cSitFolh)

				If !Empty(cTpRtProv) 
					If ( nPR_TIPMOVI == 0 .Or. nPR_TIPMOVI == 6 )
						nTamArray := Len(aSRASRT) 
						For nK3 := 1 To nTamArray
							If SRA->RA_FILIAL == aSRASRT[nK3,1] .AND. SRA->RA_MAT == aSRASRT[nK3,2] .OR.;
								(SRA->RA_FILIAL <> aSRASRT[nK3,1] .AND. aTransf[nK1,nTrfProc,_TFil] == aSRASRT[nK3,1] .AND.;
								aTransf[nK1,nTrfProc,_TMat] == aSRASRT[nK3,2])							
				    			RecLock( "TPR", .T. ) 
								TPR->PR_FILIAL  := aTransf[nK1,nTrfProc,_TFil] // Filial De
								TPR->PR_MAT     := aTransf[nK1,nTrfProc,_TMat] // Matricula De
								TPR->PR_CC      := aTransf[nK1,nTrfProc,_TCC]  // Centro de Custo De
								TPR->PR_NOME    := aSRASRT[nK3,4]//(cAliasSra)->RA_NOME
								TPR->PR_ADMISSA := aSRASRT[nK3,5]//(cAliasSra)->RA_ADMISSA
								TPR->PR_DEMISSA := aSRASRT[nK3,6]//(cAliasSra)->RA_DEMISSA
								TPR->PR_SITFOLH := cSitFolh
								TPR->PR_AFASFGT := cTipAfas
								TPR->PR_TPCONTR := aSRASRT[nK3,9]//(cAliasSra)->RA_TPCONTR
								TPR->PR_HRSMES  := aSRASRT[nK3,10]//(cAliasSra)->RA_HRSMES
								TPR->PR_PERICUL := aSRASRT[nK3,11]//(cAliasSra)->RA_PERICUL
								If lSalInc
									TPR->PR_SALINCO := aSRASRT[nK3,12]//(cAliasSra)->RA_SALINCO
								EndIf
								TPR->PR_CCMVTO 	:= aSRASRT[nK3,13]//(cAliasSra)->RT_CC
								If lItemClVl
									TPR->PR_ITMMVTO := aSRASRT[nK3,18]//(cAliasSra)->RT_ITEM
									TPR->PR_CLVMVTO := aSRASRT[nK3,19]//(cAliasSra)->RT_CLVL
								EndIf
								TPR->PR_TIPMOVI := nPR_TIPMOVI
								MsUnlock()							
							EndIf
						Next
					Endif
				Else					
			    	RecLock( "TPR", .T. )
					TPR->PR_FILIAL  := aTransf[nK1,nTrfProc,_TFil] // Filial De
					TPR->PR_MAT     := aTransf[nK1,nTrfProc,_TMat] // Matricula De
					TPR->PR_CC      := aTransf[nK1,nTrfProc,_TCC]  // Centro de Custo De
					TPR->PR_NOME    := SRA->RA_NOME
					TPR->PR_ADMISSA := SRA->RA_ADMISSA
					TPR->PR_DEMISSA := SRA->RA_DEMISSA
					TPR->PR_SITFOLH := cSitFolh
					TPR->PR_AFASFGT := cTipAfas
					TPR->PR_TPCONTR := SRA->RA_TPCONTR
					TPR->PR_HRSMES  := SRA->RA_HRSMES
					TPR->PR_PERICUL := SRA->RA_PERICUL
					TPR->PR_TIPMOVI := nPR_TIPMOVI
					If lSalInc
						TPR->PR_SALINCO := SRA->RA_SALINCO
					EndIf
					If lItemClVl
						TPR->PR_ITEM    := aTransf[nK1,nTrfProc,_TItm] // Item Contabil
						TPR->PR_CLVL    := aTransf[nK1,nTrfProc,_TClv] // Classe de valor
					EndIf
					MsUnlock()
				EndIf				
				aTransf[nK1,nTrfProc,_TInc] := .T.
			EndIf
		Next nK2
	EndIf
Next nK1


#IFDEF TOP
	(cAliasSRA)->(dbCloseArea())
#ENDIF
If !Empty(cTpRtProv)
	aSRASRT := {}
EndIf
Return

/*/


Ŀ
Funao	  Cria_TPR	 Autor  R.H. -				 Data  02.03.00 
Ĵ
Descriao  Cria  Arquivo de Trabalho para impressao da provisao       
Ĵ
Sintaxe	  CRIA_TPR(cTPRDbf,cTPRNtx,cIndCond)						  
Ĵ
Parametros cTPRDbf  - Nome do arquivo de dados			  			  
           cTPRNtx  - Nome do arquivo de indice						  
           cIndCond - Chave do indice condicional					  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
STATIC Function Cria_TPR(cTPRDbf,cTPRNtx,cIndCond)

Local aFields
Local aTamCC	:= TamSX3("RA_CC")
Local aTamItem 
Local aTamClVl 
Local aTamCCMvto 
Local nTry		:= 20
Local cMsgExc	:= ""

#IFDEF TOP
	If Type("lGrid") == "U"
		Private lGrid	:= .F.
	EndIf
#ENDIF

If lItemClVl
	aTamItem := TamSX3("RA_ITEM")
	aTamClVl := TamSX3("RA_CLVL")
Endif	

cTPRDBF := Subst(CriaTrab(NIL,.f.),1,7) + "B" // Evita criacao com mesmo nome
aFields := {}

AADD(aFields,{"PR_FILIAL" ,"C",FWGETTAMFILIAL,0})
AADD(aFields,{"PR_MAT"    ,"C",06,0})
AADD(aFields,{"PR_CC"     ,"C",aTamCC[1],0})
AADD(aFields,{"PR_NOME"   ,"C",30,0})
AADD(aFields,{"PR_ADMISSA","D",08,0})
AADD(aFields,{"PR_DEMISSA","D",08,0})
AADD(aFields,{"PR_SITFOLH","C",01,0})
AADD(aFields,{"PR_AFASFGT","C",01,0})
AADD(aFields,{"PR_TPCONTR","C",01,0})
AADD(aFields,{"PR_HRSMES" ,"N",06,2})
AADD(aFields,{"PR_SALINCO","N",12,2})
AADD(aFields,{"PR_PERICUL","N",06,2})
AADD(aFields,{"PR_INSMIN" ,"N",06,2})
AADD(aFields,{"PR_INSMED" ,"N",06,2})
AADD(aFields,{"PR_INSMAX" ,"N",06,2})
AADD(aFields,{"PR_ADTPOSE","C",06,0})
AADD(aFields,{"PR_TIPMOVI","N",01,0})
AADD(aFields,{"PR_INSSAUT","C",01,0})
//Se existir item e classe cria os campos na tabela temporaria
If lItemClVl
	AADD(aFields,{"PR_ITEM"   ,"C",aTamItem[1],0})
	AADD(aFields,{"PR_CLVL"   ,"C",aTamClVl[1],0})
Endif
If !Empty(cTpRtProv)
	aTamCCMvto	:= TamSX3("RT_CC") 
	AADD(aFields,{"PR_CCMVTO"     ,"C",aTamCCMvto[1],0})
	If lItemClVl
		AADD(aFields,{"PR_ITMMVTO"    ,"C",aTamItem[1],0})
		AADD(aFields,{"PR_CLVMVTO"    ,"C",aTamClVl[1],0})
	eNDiF
EndIf
	
DbCreate(cTPRDbf,aFields)

If ( Select("TPR") > 0 )
	dbSelectArea("TPR")
	USE
EndIf

USE (cTPRDbf) ALIAS TPR EXCLUSIVE NEW

// No Linux existe um time para liberacao da criacao do arquivo. Quando nao encontrar 
// o arquivo para abrir, dever aguardar um tempo. Esperar no maximo 20 segundos
While NetErr() .and. nTry > 0 
	nTry--
	sleep(1000)	//-- 1 segundo
	USE (cTPRDbf) ALIAS TPR EXCLUSIVE NEW
Enddo

If NetErr()
	cMsgExc := CRLF + OemToAnsi(STR0053)// "Falha na criacao do arquivo temporario (TPR)!"
	UserException( cMsgExc )
EndIf

// Cria nome para indice permanente 
cTPRNtx := Subst(CriaTrab(NIL,.f.),1,7) + "C"

// Cria indice permanente para a tabela
INDEX ON &(cIndCond) TO (cTPRNtx + OrdBagExt())

#IFDEF TOP
	If lGrid
		// Fecha a tabela 
		USE
		// E reabre em modo compartilhado, com o indice
		Open_TPR(cTPRDbf,cTPRNtx)
	EndIf
#ENDIF

Return Nil

/*


Ŀ
Funao	  fSeleTransf  Autor  Emerson R. de Souza Data  17.09.99 
Ĵ
Descrio  Seleciona Funcionarios Transferidos	no Mes			      
Ĵ
Sintaxe	  fSeleTransf(aTransf,dDataProvisao)						  
Ĵ
Parametros aTransf       = Array que contera os transferido do mes    
           dDataProvisao = Data Provisao P/ Selecao dos Transferidos  
Ĵ
 Uso	 	  Generico   												  
ٱ

*/
STATIC Function fSeleTransf(aTransf, dDataProvisao)

Local aArqSRE    	:= {}
Local aTrfAux    	:= {}
Local nPosTrf    	:= 0
Local nPosArq    	:= 0
Local cAlias     	:= ALIAS()
Local nTamRA_FILIAL := ""
Local cBusca     	:= ""
Local cAnoMesAux 	:= ""
Local nSeqFor

cAnoMesR := MesAno(dDataProvisao)

dbSelectArea( "SRE" )
cIndCond:= "RE_DATA"
cFor:='Left(DTOS(RE_DATA),6) >= "'+cAnoMesR+'"'
cArqNtx1  := Subs(CriaTrab(NIL,.F.),1,7)+"A"
IndRegua("SRE",cArqNtx1,cIndCond,,cFor,STR0014)		//"Selecionando Registros..."
DbGoTop()

nTamRA_FILIAL := GetSx3Cache("RA_FILIAL", "X3_TAMANHO") 

While ! Eof()
	cAnoMesAux := MesAno(SRE->RE_DATA)
	If SRE->RE_EMPD == FWGrpCompany("SRE") .OR. SRE->RE_EMPP == FWGrpCompany("SRE")	
		If lItemClVl
			aAdd( aArqSRE, { { SRE->RE_EMPD, Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL), SRE->RE_CCD, SRE->RE_MATD, cAnoMesAux, .F., SRE->RE_ITEMD, SRE->RE_CLVLD },;
					          {           "", 			   "",      "",           "", 	       "", .F., 	       "", 	       "" },;
	  						  { SRE->RE_EMPP, Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL), SRE->RE_CCP, SRE->RE_MATP, cAnoMesAux, .F., SRE->RE_ITEMP, SRE->RE_CLVLP } } )		
		Else
			Aadd( aArqSRE, { { SRE->RE_EMPD, Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL), SRE->RE_CCD, SRE->RE_MATD, cAnoMesAux, .F. },;
					          {           "", 			   "",      "",           "", 	       "", .F. },;
	  						  { SRE->RE_EMPP, Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL), SRE->RE_CCP, SRE->RE_MATP, cAnoMesAux, .F. } } )
		EndIf
	EndIf
	dbSkip()
EndDo
dbSelectArea("SRE")
dbSetOrder(1)
RetIndex("SRE")
dbClearFilter()
fErase( cArqNtx1 + OrdBagExt() )

For nSeqFor := 1 To Len(aArqSRE)

	If !Empty( aArqSRE[nSeqFor,_TAnter,_TEmp] )

		//Ŀ
		// Se a transferencia ocorreu no mes de calculo significa que o 
		// funcionario esta ATUALMENTE no Centro de Custo Destino, caso 
		// contrario, indica que foi processado no C. de Custo ORIGEM.  
		//
		Aadd( aTrfAux, { ACLONE(aArqSRE[nSeqFor,_TAnter]), If(aArqSRE[nSeqFor,_TAnter,_TDta] == cAnoMesR,;
					      ACLONE(aArqSRE[nSeqFor,_TDest]), ACLONE(aArqSRE[nSeqFor,_TAnter])), ACLONE(aArqSRE[nSeqFor,_TDest]) } )

		aArqSRE[nSeqFor,_TAnter] := { "", "", "", "", "", .F. } // Nao deve ser lido novamente
		nPosTrf ++
		While .T.
			cBusca  := aTrfAux[nPosTrf,_TDest,_TEmp]+aTrfAux[nPosTrf,_TDest,_TFil]+aTrfAux[nPosTrf,_TDest,_TCC]+aTrfAux[nPosTrf,_TDest,_TMat]
			nPosSre := Ascan( aArqSRE, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat] == cBusca } )
			If nPosSre > 0
				If aArqSRE[nPosSre,_TAnter,_TDta] == cAnoMesR
					aTrfAux[nPosTrf,_TAtual] := ACLONE(aArqSRE[nPosSre,_TDest])
				EndIf
				aTrfAux[nPosTrf,_TDest]  := ACLONE(aArqSRE[nPosSre,_TDest])
				aArqSRE[nPosSre,_TAnter] := { "", "", "", "", "", .F. } // Nao deve ser lido novamente
			Else
				//Ŀ
				// Se estiver fora do intervalo de impressao limpa matriz       
				//
				If ((( aTrfAux[nPosTrf,_TAnter,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TAnter,_TFil] > cFilAte  ) .Or.;  
				     ( aTrfAux[nPosTrf,_TAnter,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TAnter,_TCC]  > cCcAte  )  .Or.;
				     ( aTrfAux[nPosTrf,_TAnter,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TAnter,_TMat] > cMatAte ) ) .and. aTrfAux[nPosTrf,_TEmp,_TDta] > cAnoMesR ); 
				    .And.;
				    (( aTrfAux[nPosTrf,_TAtual,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TAtual,_TFil] > cFilAte  ) .Or.;
				    ( aTrfAux[nPosTrf,_TAtual,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TAtual,_TCC]  > cCcAte  )  .Or.;
				    ( aTrfAux[nPosTrf,_TAtual,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TAtual,_TMat] > cMatAte ));
				    .And.;
					(( aTrfAux[nPosTrf,_TDest,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TDest,_TFil] > cFilAte  ) .Or.;
				    ( aTrfAux[nPosTrf,_TDest,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TDest,_TCC]  > cCcAte  )  .Or.;
				    ( aTrfAux[nPosTrf,_TDest,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TDest,_TMat] > cMatAte ))
					 aTrfAux[nPosTrf,_TAnter] := { "", "", "", "", "", .F. }
				EndIf
				Exit
			EndIf
		EndDo
	EndIf
Next nSeqFor
Aeval(aTrfAux,{ |x| If(!Empty(x[_TAnter,_TMat]), Aadd( aTransf, { x[_TAnter], x[_TAtual], x[_TDest] } ), "") } )
dbSelectArea(cAlias)

Return Nil

/*


Ŀ
Funao	  fConvSRF  Autor  Emerson Rosa de Souza  Data  20.07.00 
Ĵ
Descriao  Monta o arquivo SRT com o saldo anterior do SRF   		  
Ĵ
Sintaxe	  fConvSRF()												  
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fConvSRF()
Local aVenc,aProp,a13Sl,aProv,n1TerVen,n1TerPro,k,x
Local dDataAnt,dDataProv,cCCOk,cAnoMesProv,nAvos13
Local cTprDbf,cTprNtx
Local cAlias  := Alias()
Local lSalInc := .F.
Local nOrdem  := 1
Local nPerc1T := 0
Local aSM0    := fGetSM0(.T.)
Local i       := 0
Local cCodFil 
Local aAreaSRD := SRD->(GetArea())

Private aRoteiro := {}
Private aCodFol  := {}
Private aVerba   := {}

If Aviso( STR0015, STR0018+STR0019, { STR0016, STR0017 } ) # 1
	lAbortPrint := .T.
	Return
EndIf

//Ŀ
// Verifica se existem todos os identificadores da empresa atual|
//
For i := 1 To Len(aSM0)
    
	cCodFil := aSM0[i][SM0_CODFIL]

	dbSelectArea("SRD")
	If !dbSeek(cCodFil)
    	dbskip()
		loop

	//Ŀ
	// Carrega aCodFol com os identificadores da folha				 
	//
	Elseif !Fp_CodFol(@aCodFol,cCodFil)
		dbSelectArea( cAlias )
		lAbortPrint := .T.
		Return
	EndIf

	//Ŀ
	// Carrega os identificadores da Provisao						 
	//
	fIdentProv(@aVerba,aCodFol)

	//Ŀ
	// Verifica a existencia dos identificadores da provisao ferias 
	//
	fChkIdent(aVerba,_FerVenc,{_Atual,_BxFer,_BxTrf},.T.)

	//Ŀ
	// Verifica a existencia dos identificadores da provisao 13 Sal 
	//
	fChkIdent(aVerba,_13Salar,{_Atual,_Bx13o,_BxTrf},.T.)

	//Ŀ
	// Verifica a existencia dos identificadores da provisao Mes	 
	//
	If lGeraPMes
		fChkIdent(aVerba,_FerVMes,{_Atual},.T.)
		fChkIdent(aVerba,_13SVMes,{_Atual},.T.)
	Endif

	//Ŀ
	// Se gerou Ocorrencias aborta para apresentacao do LOG		 
	//
	If fAdicLog(aIdProvis,cCodFil)
		dbSelectArea( cAlias )
		lAbortPrint := .T.
		Return
	EndIf
	
Next i

//Ŀ
// Variaveis utilizadas para montagem do arquivo temporario   |
//
cNomeDe   := Space(30)
cNomeAte  := Replicate("z", 30)
cMatDe    := Space(6)
cMatAte   := Replicate("z", 06)
cCcDe     := Space(9)
cCCAte    := Replicate("z", 09)
cFilDe    := Space(FWGETTAMFILIAL)
cFilAte   := Replicate("z", FWGETTAMFILIAL)
cCateg	  := "ACDEGHIJMPST"

//Ŀ
// Monta o arquivo temporario "TPR" a partir do SRA e SRE     |
//
Processa({|| fMonta_TPR(@cTPRDbf,@cTPRNtx,nOrdem,dDataBase,@lSalInc,,,,,.T.)},STR0001) // "Importacao do saldo anterior"

//Ŀ
// Carrega regua de processamento							   
//
dbSelectArea( "TPR" )
dbGoTop()
ProcRegua(RecCount())

//Ŀ
// Ano e Mes a ser utilizado caso nao encontre uma data valida
//
dDataAnt := dDataBase - Day(dDataBase)

cFilialAnt := Replicate("!", FWGETTAMFILIAL)
While !Eof()

	//Ŀ
	// Se o funcionario nao existir no cadatro busca o proximo      |
	//
	dbSelectArea( "SRA" )
	If !dbSeek( TPR->PR_FILIAL + TPR->PR_MAT )
		dbSelectArea( "TPR" )
		dbSkip()
		Loop
	EndIf
	
	//Ŀ
	// Se o funcionario nao existir na provisao busca o proximo     |
	//
	dbSelectArea( "SRF" )
	If !dbSeek( TPR->PR_FILIAL + TPR->PR_MAT ) .Or.;
	   ( Empty(SRF->RF_DATAA13) .And. Empty(SRF->RF_DATAATU) )
		dbSelectArea( "TPR" )
		dbSkip()
		Loop
	EndIf
	
	dbSelectArea( "TPR" )

	//Ŀ
	// Apresenta o Funcionario que esta sendo processado			 
	//
    IncProc(TPR->PR_FILIAL+" - "+TPR->PR_MAT+" - "+TPR->PR_NOME)
                     
	//Ŀ
	// Quebra filial para buscar as tabelas						 
	//
	If TPR->PR_FILIAL # cFilialAnt
		Fp_CodFol(@aCodFol,TPR->PR_FILIAL)
		dbSelectArea( "TPR" )
		cFilialAnt := TPR->PR_FILIAL
		PosSrv(aCodFol[77,1],TPR->PR_FILIAL)
		nPerc1T := SRV->RV_PERC
	Endif
		
	//Ŀ
	// Carrega array com os campos que serao gravados no SRT        |
	//
	n1TerVen := NoRound((SRF->RF_VPROVAT + SRF->RF_VADPVAT) * If(nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
	n1TerPro := NoRound((SRF->RF_VPROAAT + SRF->RF_VADPAAT) * If(nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
	aVenc := { { SRF->RF_VPROVAT, aCodFol[130,1] },;   // Provisao
			    { SRF->RF_VADPVAT, aCodFol[254,1] },;   // Adicionais
			    { n1TerVen,         aCodFol[255,1] },;   // Um Terco
			    { SRF->RF_VIAPVAT, aCodFol[131,1] },;   // INSS
   			    { SRF->RF_VFGTVAT, aCodFol[132,1] } }   // FGTS
	aProp := { { SRF->RF_VPROAAT, aCodFol[130,1] },;   // Provisao
			    { SRF->RF_VADPAAT, aCodFol[254,1] },;   // Adicionais
			    { n1TerPro,         aCodFol[255,1] },;  //  Um Terco
			    { SRF->RF_VIAPAAT, aCodFol[131,1] },;   // INSS
   			    { SRF->RF_VFGTAAT, aCodFol[132,1] } }   // FGTS
	a13Sl := { { SRF->RF_VPRDTAT, aCodFol[136,1] },;   // Provisao
			    { SRF->RF_TADDTAT, aCodFol[267,1] },;   // Adicionais
			    { SRF->RF_PAR13AT, aCodFol[268,1] },;   // Adiantamento da 1a Parcela
			    { SRF->RF_VINDTAT, aCodFol[137,1] },;   // INSS
			    { SRF->RF_VFGDTAT, aCodFol[138,1] } }   // FGTS
			    
	//Ŀ
	// Calcula Salario Incorporado 								 
	//
    nSalario := nSalMes  := nSalHora := nSalDia := 0
	fSalInc(@nSalario,@nSalMes,@nSalHora,@nSalDia,.T.)
	nSalMes := If(lSalInc .And. SRA->RA_SALINCO > 0, SRA->RA_SALINCO, nSalMes)
	
	//Ŀ
	// Calcula os Avos de 13 do Funcionario						 
	//
	nAvos13 := 0
	fAvos13(@nAvos13,SRF->RF_DATAA13,0)

	cAnoMesProv := "!!!!!!"	
	dbSelectArea( "SRT" )
	For k := 1 To 3
		aProv := If(k == 1, aVenc, If(k == 2, aProp, a13Sl))
		aProv := aSort(aProv,,,{|x,y| x[2] < y[2] })
		dDataProv := If(k==3,SRF->RF_DATAA13,SRF->RF_DATAATU)
		If !Empty(dDataProv)
			For x := 1 To Len(aProv)
				If aProv[x,1] > 0
					RecLock( "SRT", .T. )
					SRT->RT_FILIAL  := TPR->PR_FILIAL
					SRT->RT_MAT     := TPR->PR_MAT
					SRT->RT_CC      := TPR->PR_CC
					SRT->RT_DATACAL :=	dDataProv
					SRT->RT_TIPPROV := Str(k,1)        // 1-Venc  2-Prop  3-13 Sal
					SRT->RT_VALOR   := aProv[x,1]
					SRT->RT_VERBA   := aProv[x,2]
					If MesAno(dDataProv) # cAnoMesProv
		  				SRT->RT_DATABAS := SRF->RF_DATABAS
	  					SRT->RT_DFERVEN := SRF->RF_DFERVAT
	  					SRT->RT_DFERPRO := SRF->RF_DFERAAT
	  					SRT->RT_DFERANT := SRF->RF_DFERANT
	  					SRT->RT_DFALVEN :=	SRF->RF_DFALVAT
						SRT->RT_DFALPRO :=	SRF->RF_DFALAAT
	  					SRT->RT_SALARIO := nSalMes
		  				SRT->RT_AVOS13S := nAvos13
	  					SRT->RT_TIPMOVI := TPR->PR_TIPMOVI  // (Congelado-Transferido-Demitido)
	  					cAnoMesProv      := MesAno(dDataProv)
					EndIf
					MsUnlock()
				EndIf
			Next x
		EndIf
	Next k
	dbSelectArea( "TPR" )
	dbSkip()
EndDo
dbSelectArea( cAlias )
TPR->(dbCloseArea())
fErase(cTPRNtx + OrdBagExt())
fErase(cTPRDbf + ".DBF")

RestArea(aAreaSRD)

Return

/*


Ŀ
Funao	 fGpeProvis Autor  Emerson Rosa de Souza  Data  10.08.00 
Ĵ
Descriao  Cria constantes p/ utilizacao em GPEA070,GPER070 e GPEM070.
Ĵ
Sintaxe	  GpeProvisao(uPar1,uPar2,uPar3,nPar4,uPar5)				  
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function GpeProvisao(uPar1,uPar2,uPar3,uPar4,uPar5,aPar,cTpRtPr)

uPar5 := If(uPar5 == Nil, 1, uPar5)

//Ŀ
//| Indica o tipo de provisao (sera gravado no campo RT_TIPPROV) |
//
Private _FerVenc  := 1  // Ferias Vencidas
Private _FerProp  := 2  // Ferias Proporcionais
Private _13Salar  := 3  // 13 Salario
Private _14Salar  := 4  // 14 Salario
Private _FerVMes  := 5	// Ferias Provisao Mes
Private _13SVMes  := 6  // 13 Provisao Mes

//Ŀ
//| Indica a linha na ordem em que sera apresentada no relatorio |
//
Private _Anter    := 01  // Mes Anterior
Private _Corre    := 02  // Correcao
Private _NoMes    := 03  // No Mes
Private _Atual    := 04  // Mes Atual
Private _BxTrf    := 05  // Baixa de Transferencia
Private _BxFer    := 06  // Baixa de Ferias
Private _Bx13o    := 06  // Baixa de 13o Salario
Private _Bx14o    := 06  // Baixa de 14o Salario
Private _BxRes    := 07  // Baixa de Rescisao
Private _TrfEnt   := 08  // Transferencia de Entrada
Private _TrfSai   := 09  // Transferencia de Saida
Private _BxTot    := 10  // Baixa Total

//Ŀ
//| Indica a coluna na ordem em que sera apresentada no relatorio|
//
Private _Dias     := 1  // Dias de Ferias
Private _Avos     := 1  // Avos de 13 Salario
Private _Prov     := 2  // Valor da Provisao de Ferias ou Decimo Terceiro Salario
Private _Adic     := 3  // Adicionais
Private _1Ter     := 4  // Um Terco de Ferias
Private _1Par     := 4  // 1 Parcela do 13 Salario
Private _INSS     := 5  // INSS
Private _FGTS     := 6  // FGTS
Private _SalV	  := 7  // Media Salario Vac
Private _PIS      := 8  // PIS
//Ŀ
// Constantes que definem o numero de linhas e colunas do array |
//
Private _Linhas   := 10  // Quantidade de Linhas ou Elementos
Private _Colunas  := 08  // Quantidade de colunas para cada Linha ou Elemento

//Ŀ
// Indica a posicao das informacoes de cabecalho em "aCabProv"  |   
//
Private _DatCalc  :=  1  // Data do calculo
Private _CentroC  :=  2  // Data do calculo
Private _DBsProv  :=  3  // Data base de ferias
Private _DFerVen  :=  4  // Dias de ferias vencidas
Private _DFerPro  :=  5  // Dias de ferias proporcionais
Private _DFerAnt  :=  6  // Dias de ferias antecipadas
Private _DFalVen  :=  7  // Dias de faltas vencidas
Private _DFalPro  :=  8  // Dias de faltas proporcionais
Private _MovProv  :=  9  // Movimentacao no mes
Private _SalProv  := 10  // Salario da provisao no mes
Private _Avos13S  := 11  // Avos de 13 salario 
Private _PStatus  := 12  // Status (Ativo/Excluido)
Private _CItem	  := 13  // Item Contabil
Private _Clvl	  := 14  // Classe de Valor

//Ŀ
// Indica os tipos de movimentacao do funcionario no mes        |
//
Private _Demitido := 1  // Demitido
Private _Cong_Fer := 2  // Congelado Ferias
Private _Cong_13s := 3  // Congelado 13 Salario
Private _Cong_F13 := 4  // Congelado Ferias e 13 Salario
Private _Trfe_Sai := 5  // Transferencia Saida 
Private _Trfe_Ent := 6  // Transferencia Entrada

//Ŀ
// Indica as posicoes dentro do array aTransf                   |
//
Private _TAnter   := 1  // Centro de Custo Anterior
Private _TAtual   := 2  // Centro de Custo Atual
Private _TDest    := 3  // Centro de Custo Destino
Private _TEmp     := 1  // Empresa
Private _TFil     := 2  // Filial
Private _TCC      := 3  // Centro de Custo
Private _TMat     := 4  // Matricula
Private _TDta     := 5  // Data da Transferencia
Private _TInc     := 6  // Funcionario ja incluido no arquivo temporario
Private _TItm     := 7  // Item Contabil
Private _TClv     := 8  // Classe de valor
Private cTpRtProv
Private lGeraPMes := .F.

If SuperGetMv("MV_RATPROV",,"N") == "S"
	lGeraPMes	  := fChkRHQBase()	// Verifica a existencia da tabela RHQ
Endif

If ValType(cTpRtPr) == "U" 
	cTpRtProv	:= Nil 
Else
	cTpRtProv	:= cTpRtPr
EndIf

If uPar5 == 1 		// Cadastro
	gp070Atu(uPar1,uPar2,uPar3)
ElseIf uPar5 == 2  // Relatorio de Ferias
	RptStatus({|lEnd| GP070Imp(@lEnd,uPar1,uPar2)},uPar3)
ElseIf uPar5 == 3  // Relatorio de 13 Salario
	RptStatus({|lEnd| GP090Imp(@lEnd,uPar1,uPar2)},uPar3)
ElseIf uPar5 == 4  // Calculo
	// Em GRID havera uma Barra de processamento da LIB //
	If lGrid
		MsAguarde( {|lEnd| GPM070Processa(aPar)}, OemToAnsi(STR0051), OemToAnsi(STR0052) ) //"Aguarde..."###"Preparando Informaes para o GRID..."
	Else
		Processa({|| GPM070Processa(aPar)},uPar1,,.T.)
	EndIf
ElseIf uPar5 == 5  // Importacao do arquivo SRF para o novo SRT
    Processa({|| fConvSRF()},uPar1)
ElseIf uPar5 == 6  // Geracao de lancamentos contabeis da provisao no arquivo SRZ
    Processa({|| fGeraProvSRZ(uPar2)},uPar1)
ElseIf uPar5 == 7  // Processa a diferencas do calculo de provisa
	Processa({|| fProvProc()},uPar1)
EndIf

Return

/*


Ŀ
Funao	 fChkDemit  Autor  Emerson Rosa de Souza  Data  29.08.00 
Ĵ
Descriao  Se nao existir identif. de rescisao,acerta posicao no array
Ĵ
Sintaxe	  fChkDemit(aProvisao,aVerba,nTipoProv,nGravar,nZerar)       
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Function fChkDemit(aProvisao,aVerba,nTipoProv,nGravar,nZerar)
Local aElem     := { _Prov, _Adic, _1Ter, _INSS, _FGTS, _PIS },nCnt
Local nProvBus  := If(nTipoProv == _FerProp,_FerVenc,nTipoProv)

If !fChkIdent(aVerba,nProvBus,{_BxRes},.F.)
   For nCnt := 1 To Len(aElem)
      aProvisao[nGravar,aElem[nCnt]] += aProvisao[nZerar,aElem[nCnt]]
      aProvisao[nZerar,aElem[nCnt]]  := 0
   Next nCnt
EndIf

Return Nil

/*


Ŀ
Funo    fChkProv() Autor  Equipe R.H.            Data  18/12/02 
Ĵ
Descrio  Encontra diferencas entre dois meses na provisao			  
Ĵ
 Uso       Esta funcao nao  utilizada no Protheus, mas  de uso      
 	      externo para conferncias.								  
ٱ
*/
Function fChkProv()

nOrdem      := 2
cFilDe      := Space(FWGETTAMFILIAL)
cFilAte     := Replicate("z",FWGETTAMFILIAL)
cCcDe       := Space(9)
cCcAte      := Replicate("z",09)
cMatDe      := Space(6)
cMatAte     := Replicate("z",06)
cNomeDe     := Space(30)
cNomeAte    := Replicate("z",30)
cCateg      := "ACDEGHIJMPST"

Private aCodFol   := {}
Private aLogFile  := {}
Private aLogTitle := {}

nTipProv  := 1
dDtRefIni := CTOD("")
dDtRefFim := CTOD("")

If fSeleProv(@nTipProv,@dDtRefIni,@dDtRefFim) == 0 .Or. Empty(dDtRefIni) .Or. Empty(dDtRefFim)
	Return
EndIf

//Ŀ
// Carrega variaveis privates comuns a GPEA070,GPER070 e GPEM070|
//
GPEProvisao("PROCESSANDO DIFERENCAS - MESES " + Substr(DTOC(dDtRefIni),4,7)+;
            " E " + Substr(DTOC(dDtRefFim),4,7),,,,7)

Return

/*


Ŀ
Funo    fProvProc  Autor  Equipe R.H.            Data  18/12/02 
Ĵ
Descrio  Processa as diferencas entre dois meses na provisao		  
Ĵ
 Uso                                                                  
ٱ
*/
Static Function fProvProc()
Local cDbfIni := cNtxIni := cDbfFim := cNtxFim := ""
Local lSalInc     := .F.
Local lTrataTrf   := .F.
Local aTransf     := {}
Local aProvAux    := {}
Local aFer13o     := {}
Local lAchou,lProvOk,nCnt,nValProv,nValTot,cTitulo,cIndCond

//Ŀ
// Monta o arquivo temporario "TPRINI"  do mes inicial		   |
//
If !File("TPRINI.DBF")
	Processa({ || fMonta_TPR(@cDbfIni,@cNtxIni,nOrdem,dDtRefIni,@lSalInc,@lTrataTrf,@aTransf,)},"GERANDO ARQUIVO DA PROVISAO - MES " + Substr(DTOC(dDtRefIni),4,7))
	dbSelectArea( "TPR" )
	dbCloseArea()
	DbUseArea(.T.,,cDbfIni,"TPRINI",.F.)
	dbSetIndex(cNtxIni+OrdBagExt())
Else
	DbUseArea(.T.,,"TPRINI","TPRINI",.F.)
	cIndCond := "PR_FILIAL + PR_CC + PR_MAT"
	cNtxIni  := Subst(CriaTrab(NIL,.f.),1,7)+"C"
	IndRegua("TPRINI",cNtxIni,cIndCond,,, "Selecionando Registros...")
EndIf

//Ŀ
// Monta o arquivo temporario "TPRFIM"  do mes Final		   |
//
If !File("TPRFIM.DBF")
	Processa({ || fMonta_TPR(@cDbfFim,@cNtxFim,nOrdem,dDtRefFim,@lSalInc,@lTrataTrf,@aTransf,)},"GERANDO ARQUIVO DA PROVISAO - MES " + Substr(DTOC(dDtRefFim),4,7))
	dbSelectArea( "TPR" )
	dbCloseArea()
	DbUseArea(.T.,,cDbfFim,"TPRFIM",.F.)
	dbSetIndex(cNtxFim+OrdBagExt())
Else
	DbUseArea(.T.,,"TPRFIM","TPRFIM",.F.)
	cIndCond := "PR_FILIAL + PR_CC + PR_MAT"
	cNtxFim  := Subst(CriaTrab(NIL,.f.),1,7)+"C"
	IndRegua("TPRFIM",cNtxFim,cIndCond,,, "Selecionando Registros...")
EndIf

cFilialAnt := Replicate("!", FWGETTAMFILIAL)

dbSelectArea( "SRT" )
dbSetOrder(2)

dbSelectArea( "TPRINI" )
dbGoTop()

//Ŀ
// Carrega Regua de Processamento						  
//
ProcRegua(RecCount())
While !Eof()

	//Ŀ
	// Movimenta Regua de Processamento							 
	//
	IncProc("Filial: " + TPRINI->PR_FILIAL+" - C.Custo: "+AllTrim(TPRINI->PR_CC)+" - Mat: "+TPRINI->PR_MAT)

	If TPRINI->PR_FILIAL # cFilialAnt
		If !Fp_CodFol(@aCodFol,TPRINI->PR_FILIAL)
			Exit
		Endif
		cFilialAnt := TPRINI->PR_FILIAL

		//Ŀ
		// Monta array com o tipo de provisao a processar     		   |
		//
		aFer13o := {}
		If nTipProv == 1 .Or. nTipProv == 3
			aAdd( aFer13o, { "1", aCodFol[130,1] } )
		EndIf
		If nTipProv == 2 .Or. nTipProv == 3
			aAdd( aFer13o, { "3", aCodFol[136,1] } )
		EndIf

	EndIf

	For nCnt := 1 To Len(aFer13o)
		lProvOk   := .F.
		nValProv  := 0
		If aFer13o[nCnt,1] == "1"
			//Provisao de Ferias Vencidas
			If SRT->( dbSeek( TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"1"+aFer13o[nCnt,2] ) )
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
			//Provisao de Ferias Proporcionais
			If SRT->( dbSeek( TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"2"+aFer13o[nCnt,2] ) )
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
		Else 			                // Provisao de 13o Salario
			If SRT->( dbSeek( TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"3"+aFer13o[nCnt,2] ) )
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
		EndIf
		If lProvOk
			lAchou  := .T.
			If !TPRFIM->( dbSeek( TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT ) )
				If !(MesAno(TPRINI->PR_ADMISSA) == MesAno(dDtRefFim)) .Or.;
				   !(MesAno(TPRINI->PR_DEMISSA) == MesAno(dDtRefIni))
				   	lAchou := .F.
				EndIf
			Else
				If aFer13o[nCnt,1] == "1"
					//Provisao de Ferias Vencidas/Proporcionais
					If !(SRT->( dbSeek( TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"1" ) )) .And.;
					   !(SRT->( dbSeek( TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"2" ) ))
						lAchou := .F.
					EndIf
				Else
					//Provisao de 13o. Salario
					If !(SRT->( dbSeek( TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"3" ) ))
						lAchou := .F.
					EndIf
				EndIf
			EndIf
			If !lAchou
				aAdd(aProvAux, { aFer13o[nCnt,1], nValProv,;
								 "Filial: "        + TPRINI->PR_FILIAL +;
							     " - C.Custo: "    + TPRINI->PR_CC +;
						         " - Mat: "        + TPRINI->PR_MAT+;
						         " - Admissao: "   + DTOC(TPRINI->PR_ADMISSA)+;
							     " - Demissao: "   + DTOC(TPRINI->PR_DEMISSA)+;
		   					     " - Valor: "      + Transform(nValProv,"@E 9,999,999.99") })
			EndIf
		EndIf
	Next nCnt
	dbSelectArea( "TPRINI" )
	dbSkip()
EndDo

aLogTitle := { "LOG DE OCORRENCIAS DO CALCULO DE PROVISOES - Entre os meses "+;
				Substr(DTOC(dDtRefIni),4,7) + " e " + Substr(DTOC(dDtRefFim),4,7) }
//Ŀ
// Monta LOG da provisao de ferias 							 
//
If nTipProv == 1 .Or. nTipProv == 3
	nValTot := 0
	Aeval( aProvAux, { |X| If(X[1] == "1", nValTot += X[2], "") })
	cTitulo := "PROVISAO DE FERIAS - VALOR DA DIFERENCA: " + LTRIM(Transform(nValTot,"@E 9,999,999.99"))
	aAdd(aLogFile, cTitulo)
	aAdd(aLogFile, Replicate("-", Len(cTitulo)))
	Aeval( aProvAux, { |X| If(X[1] == "1", aAdd( aLogFile, X[3]), "") })
	aAdd(aLogFile, "")
EndIf
//Ŀ
// Monta LOG da provisao de 13o Salario						 
//
If nTipProv == 2 .Or. nTipProv == 3
	nValTot := 0
	Aeval( aProvAux, { |X| If(X[1] == "3", nValTot += X[2], "") })
	cTitulo := "PROVISAO DE 13o. SALARIO - VALOR DA DIFERENCA: " + LTRIM(Transform(nValTot,"@E 9,999,999.99"))
	aAdd(aLogFile, cTitulo)
	aAdd(aLogFile, Replicate("-", Len(cTitulo)))
	Aeval( aProvAux, { |X| If(X[1] == "3", aAdd( aLogFile, X[3]), "") })
	aAdd(aLogFile, "")
EndIf

//Ŀ
// Verifica os registros perdidos do SRT               	   |
//
Processa({|| fProcSRT()},"PROCURANDO REGISTROS PERDIDOS NO SRT...")

//Ŀ
// Apresenta Tela com Log de erros								 
//
fMakeLog( {aLogFile}, aLogTitle,, .T.)

//Ŀ
// Deleta arquivos temporarios								   |
//
dbSelectArea( "TPRINI" )
dbCloseArea()
fErase(cNtxIni + OrdBagExt())
fErase(cDbfIni + ".DBF")
dbSelectArea( "TPRFIM" )
dbCloseArea()
fErase(cNtxFim + OrdBagExt())
fErase(cDbfFim + ".DBF")

dbSelectArea( "SRT" )
dbSetOrder(1)

Return Nil

/*


Ŀ
Funo     fProcSRT  Autor  Equipe R.H.            Data  26/10/01 
Ĵ
Descrio  Verifica os registros perdidos no SRT                      
Ĵ
 Uso                                                                  
ٱ
*/
Static Function fProcSRT()
Local cAlias   := ALIAS()
Local cTitPerd,cChavePerd

cTitPerd := "REGISTRO PERDIDOS ENCONTRADOS NO SRT - VERIFICAR CADA CASO"
aAdd(aLogFile, cTitPerd)
aAdd(aLogFile, Replicate("-", Len(cTitPerd)))

dbSelectArea( "SRT" )
dbSetOrder(1)

dbSelectArea( "TPRFIM" )
dbGoTop()

//Ŀ
// Carrega Regua de Processamento						  
//
ProcRegua(RecCount())

While !Eof()
	//Ŀ
	// Movimenta Regua de Processamento							 
	//
	IncProc("Filial: " + TPRFIM->PR_FILIAL+" - C.Custo: "+AllTrim(TPRFIM->PR_CC)+" - Mat: "+TPRFIM->PR_MAT)

	//Ŀ
	// Busca funcionarios transferencia entrada no mes anterior, se 
	// encontrados, deverao ser excluidos.                          
	//
	If TPRFIM->PR_TIPMOVI == 6 // Transferencia Entrada
		cChavePerd := TPRFIM->PR_FILIAL+TPRFIM->PR_MAT+TPRFIM->PR_CC+Left(DTOS(dDtRefIni),6)
		dbSelectArea( "SRT" )
		If dbSeek( cChavePerd )
			While SRT->RT_FILIAL+SRT->RT_MAT+SRT->RT_CC+Left(DTOS(RT_DATACAL),6)==cChavePerd
				aAdd(aLogFile, 	 "Filial: "             + SRT->RT_FILIAL +;
							     " - C.Custo: "         + SRT->RT_CC +;
						         " - Mat: "             + SRT->RT_MAT+;
						         " - Dt.Calculo: "      + DTOC(SRT->RT_DATACAL)+;
	   						     " - Registro do SRT: " + Transform(RECNO(),"@E 9,999,999")+;
	   						     " - Provisao: "        + If(SRT->RT_TIPPROV $ "1*2", "FERIAS", "13.SAL")+;
   	   						     " - Verba: "           + Transform(SRT->RT_VERBA,"999")+;
   	   						     " - Valor: "           + Transform(SRT->RT_VALOR,"@E 9,999,999.99"))
		 		dbSkip()
			EndDo
		EndIf
	EndIf
	dbSelectArea( "TPRFIM" )
	dbSkip()
EndDo
dbSelectArea(cAlias)

Return Nil

/*


Ŀ
Funo    fSeleProv  Autor  Equipe R.H.            Data  26/10/01 
Ĵ
Descrio  Monta dialogo para selecao com botoes de radio             
Ĵ
 Uso       Usada somente pela funo fChkProv                         
ٱ
*/
Static Function fSeleProv(nOpcRadio,dDatIni,dDatFim)
Local nOpcAux
Local oRadio
Local oDlg
Local oGroup
Local oFont
Local aRetcoords := {}

nOpcAux   := nOpcRadio
nOpcRadio := 0

aRetcoords := RetCoords(8,5,10,18,2,25)

DEFINE FONT oFont1  NAME "Arial" SIZE 0,-12 BOLD
DEFINE FONT oFont2  NAME "Arial" SIZE 0,-13

DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0067) From 094,001 TO 280,461 PIXEL //"Processar diferencas na provisao"
                                                                                                                        
	@ aRetcoords[1][1],aRetcoords[1][2] GROUP oGroup TO (aRetcoords[32][1])+5,80 LABEL OemToAnsi(STR0068) OF oDlg PIXEL COLOR CLR_BLUE  //"Provisao"
	oGroup:SetFont(oFont1)
	
	@ aRetcoords[5][1],aRetcoords[5][2] GROUP oGroup TO (aRetcoords[32][1])+5,220 LABEL OemToAnsi(STR0069) OF oDlg PIXEL COLOR CLR_BLUE //"Data do calculo"
	oGroup:SetFont(oFont1)
	
	@ aRetcoords[10][1],aRetcoords[10][2] RADIO oRadio VAR nOpcAux ITEMS OemToAnsi(STR0064), OemToAnsi(STR0065),;   //Ferias ## 13.salario
			  OemToAnsi(STR0070) SIZE 60,010 OF oDlg PIXEL //"Ambas"
	
	@ aRetcoords[14][1],aRetcoords[14][2] SAY OemtoAnsi(STR0071) 								SIZE 50,10 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE  //"Data Inicial:"
	@ aRetcoords[15][1],aRetcoords[15][2] MSGET oDtCalIni VAR dDatIni VALID !Empty(dDatIni)	SIZE 60,10 OF oDlg PIXEL HASBUTTON
	@ aRetcoords[22][1],aRetcoords[22][2] SAY OemtoAnsi(STR0072)   							SIZE 50,10 OF oDlg   PIXEL FONT oFont2 COLOR CLR_BLUE //"Data Final:"
	@ aRetcoords[23][1],aRetcoords[23][2] MSGET oDtCalFim VAR dDatFim VALID !Empty(dDatFim)  	SIZE 60,10 OF oDlg PIXEL HASBUTTON

	bSet15	:= {||(nOpcRadio := nOpcAux, oDlg:End())}
	bSet24	:= {||(nOpcRadio := 0,       oDlg:End())}

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , )  CENTERED

Return nOpcRadio

/*


Ŀ
Funao	  fAdicLog  Autor  Emerson Rosa de Souza  Data  03.05.02 
Ĵ
Descriao  Adiciona as ocorrencias do array aIdProvis no aLogFile	  
Ĵ
Sintaxe	  fAdicLog(aIdProvis,cFilProc)                               
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fAdicLog(aIdProvis,cFilProc)
Local lRet := .F.
Local nCnt,lPriVez
Local aIdObr,aIdNObr,cCondProv

//-- Testa a existencia do parametro MV_TRFAMES
//-- Esta situacao ocorre somente na importacao do saldo anterior.
If Type( "lTrfAMES" ) == "U"
	dDataRef	 := If( Type( "dDataRef" ) == "U" , dDataBase , dDataRef )
	cTrfAMES     := ( SuperGetMv( "MV_TRFAMES",, Space(6) ) ) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
	lTrfAMES     := ( !Empty(cTrfAMES) .And. MesAno( dDataRef ) >= cTrfAMES )
EndIf

//Ŀ
// Verificar se existe ao menos um identificador nao cadastrado 
//
If Ascan( aIdProvis, { |X| Empty(X[1]) }) > 0
	//Ŀ
	// Adiciona aviso informando a filial cancelada.                
	//
	Aadd(aLogFile, { STR0020 + " [ " + cFilProc + " ] " + STR0021, "" } ) //"CALCULO DA FILIAL [ XX ] CANCELADO !!!"

	//Ŀ
	// Definicao dos Identificadores Obrigatorios                   
	//
   If cPaisLoc == "BRA"
		aIdObr  := { { _FerVenc, _Atual }, { _13Salar, _Atual }, { _14Salar, _Atual },;
			         { _FerVenc, _Corre }, { _13Salar, _Corre }, { _14Salar, _Corre },;
	   	     	     { _FerVenc, _BxFer }}
		If lTrfAMES
			AADD( aIdObr, { 0, _BxTrf } )
		EndIf
	Else
		aIdObr  := { { _FerVenc, _Atual }, { _13Salar, _Atual },{ _FerVenc, _Corre },;
					  { _13Salar, _Corre }, { _FerVenc, _BxFer }}
	Endif   	 	     

	//Ŀ
	// Definicao dos Identificadores Nao Obrigatorios. O Zero indica
	// que a baixa de transf. devera ser avaliada para Ferias/13o.  
	//
	If cPaisLoc == "BRA"
		aIdNObr := { { 0, _BxTrf }, { _13Salar, _Bx13o }, { _14Salar, _Bx14o } }
	Else
		aIdNObr := { { 0, _BxTrf }, { _13Salar, _Bx13o }}
	Endif	

	//Ŀ
	// Adiciona Identificadores Obrigatorios no LOG de ocorrencias  
	//
	lPriVez  := .T.
	For nCnt := 1 To Len(aIdObr)
		If Ascan( aIdProvis, { |X| If(aIdObr[nCnt,1]==0,.T.,X[3]==aIdObr[nCnt,1]) .And. X[4]==aIdObr[nCnt,2] .And. Empty(X[1])}) > 0
			If lPriVez
				Aadd(aLogFile[1], "" )
				Aadd(aLogFile[1], STR0022 )          //"Cadastrar a verba correspondente para cada um dos identificadores relacionados abaixo"
				Aadd(aLogFile[1], "" )
				If lTrfAMES
					Aadd(aLogFile[1], STR0026 )       //"Os identificadores de transferencia devem obrigatoriamente ser criados pois o parametro MV_TRFAMES esta habilitado"
					Aadd(aLogFile[1], "" )
				EndIf
				Aadd(aLogFile[1], "    " + STR0025 ) // "Verba   Ident   Descricao do Identificador"
				Aadd(aLogFile[1], "    -----   -----   --------------------------------------------------" )
				lPriVez  := .F.
			EndIf
			Aeval( aIdProvis, { |X| If( If(aIdObr[nCnt,1]==0,.T.,X[3]==aIdObr[nCnt,1]) .And. X[4]==aIdObr[nCnt,2] .And. Empty(X[1]),;
   				   Aadd( aLogFile[1],Space(4)+X[1]+Space(5)+X[2]+Space(5)+fDesc("SX5","35"+X[2],"X5DESCRI()",50)), "")})
		EndIf
	Next nCnt
	//Ŀ
	// Identificadores nao obrigatorios, o usuario devera cadastrar 
	// todos ou excluir todos, nao pode haver meio termo.      	 
	//
	lPriVez  := .T.
	For nCnt := 1 To Len(aIdNObr)
		If Ascan( aIdProvis, { |X| If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2] .And.  Empty(X[1])}) > 0 .And.;
		   Ascan( aIdProvis, { |X| If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2] .And. !Empty(X[1])}) > 0
			If lPriVez
				Aadd(aLogFile[1], "" )
				Aadd(aLogFile[1], STR0023 )          //"Para que seja efetuado o tratamento das baixas de transferencia, cadastre a verba correspondente para"
				Aadd(aLogFile[1], STR0024 )          //"cada identificador. Para que nao seja efetuado tratamento das baixas, exclua as verbas ja cadastradas."
				Aadd(aLogFile[1], "" )
				Aadd(aLogFile[1], "    " + STR0025 ) // "Verba   Ident   Descricao do Identificador"
				Aadd(aLogFile[1], "    -----   -----   --------------------------------------------------" )
				lPriVez := .F.
			EndIf
			Aeval( aIdProvis, { |X| If( If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2],;
				   Aadd( aLogFile[1],Space(4)+X[1]+Space(5)+X[2]+Space(5)+fDesc("SX5","35"+X[2],"X5DESCRI()",50)), "")})
		EndIf
	Next nCnt
	//Ŀ
	// Os dois primeiros elementos se referem ao subtitulo.         
	//
	If Len(aLogFile[1]) > 2
		// Se for GRID adiciona o log e aborta o calculo
		If lGrid
			MsgLogGrid( aClone(aLogFile[1]), .T. )
		EndIf
		
		lRet := .T.
	Else
		aLogFile := {}
	EndIf
EndIf

Return lRet

/*


Ŀ
Funao	  fQrySRD   Autor  Ricardo Duarte Costa   Data  01.02.07 
Ĵ
Descriao  Executa query filtrando verbas de salario e adicionais.    
Ĵ
Sintaxe	  vide abaixo                                                
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fQrySRD( cFilProc , cMatProc , cMesAnoProc )

Local nReg	:= 0

//-- Monta a query para selecao dos dados
If lFechouMes
	aStruSRD := SRD->(dbStruct())
	cWhere   := "SRD.RD_FILIAL = '"+cFilProc+"' AND SRD.RD_MAT = '"+cMatProc+"' AND "+;
				"( SRD.RD_PD = '"+aCodFol[318,1]+"' OR SRD.RD_PD = '"+aCodFol[671,1]+"' OR "+;
				"SRD.RD_PD = '"+aCodFol[672,1]+"' OR SRD.RD_PD = '"+aCodFol[673,1]+"' ) AND "+;
				"SRD.RD_DATARQ = '"+cMesAnoProc+"'"
	cWhere   := "%"+cWhere+"%"
	
	BeginSql alias cAliasPROC
		SELECT SRD.RD_FILIAL, SRD.RD_MAT, SRD.RD_PD, SRD.RD_DATARQ, SUM(SRD.RD_VALOR) AS RD_VALOR 
		FROM %table:SRD% SRD
		WHERE %exp:cWhere% AND SRD.%notDel% 
		GROUP BY RD_FILIAL, RD_MAT, RD_DATARQ, RD_PD
		ORDER BY RD_FILIAL, RD_MAT, RD_DATARQ, RD_PD
	EndSql
	
	//-- Ajusta a estrutura dos campos
	For nReg := 1 To Len(aStruSRD)
		If ( aStruSRD[nReg][2] <> "C" )
			TcSetField(cAliasPROC,aStruSRD[nReg][1],aStruSRD[nReg][2],aStruSRD[nReg][3],aStruSRD[nReg][4])
		EndIf
	Next nReg
Else	
	aStruSRC := SRC->(dbStruct())
	cWhere   := "SRC.RC_FILIAL = '"+cFilProc+"' AND SRC.RC_MAT = '"+cMatProc+"' AND "+;
				"( SRC.RC_PD = '"+aCodFol[318,1]+"' OR SRC.RC_PD = '"+aCodFol[671,1]+"' OR "+;
				"SRC.RC_PD = '"+aCodFol[672,1]+"' OR SRC.RC_PD = '"+aCodFol[673,1]+"' )"
	cWhere   := "%"+cWhere+"%"
	
	BeginSql alias cAliasPROC
		SELECT SRC.RC_FILIAL, SRC.RC_MAT, SRC.RC_PD, SUM(SRC.RC_VALOR) AS RC_VALOR 
		FROM %table:SRC% SRC
		WHERE %exp:cWhere% AND SRC.%notDel% 
		GROUP BY RC_FILIAL, RC_MAT, RC_PD
		ORDER BY RC_FILIAL, RC_MAT, RC_PD
	EndSql
	
	//-- Ajusta a estrutura dos campos
	For nReg := 1 To Len(aStruSRC)
		If ( aStruSRC[nReg][2] <> "C" )
			TcSetField(cAliasPROC,aStruSRC[nReg][1],aStruSRC[nReg][2],aStruSRC[nReg][3],aStruSRC[nReg][4])
		EndIf
	Next nReg
Endif	

return


/*


Ŀ
Funao	  fCarAdics Autor  Ricardo Duarte Costa   Data  04.04.07 
Ĵ
Descriao  Inicializa as variaveis de Adic.Tpo.Servico e Insalubridade
Ĵ
Sintaxe	  vide abaixo                                                
Ĵ
 Uso	 	  Generico 												  
ٱ

*/
Static Function fCarAdics()

Local cAdtPoSer	:= SRA->RA_ADTPOSER
Local cCod		:= Space(3)
Local nx		:= 0

//-- Tratamento do Adicional de Tempo de Servico
cAdtPoSer	:= alltrim(cAdtPoSer)
cAdtPoSer	:= strtran(cAdtPoSer,"*","")
For nx := 1 to len(cAdtPoSer)
   If Substr(cAdtPoSer,nx,1) == "A"
		cCodAdt := aCodfol[1,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "B"
		cCodAdt := aCodfol[2,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "T"
		cCodAdt := aCodfol[3,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "D"
		cCodAdt := aCodfol[4,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "Q"
		cCodAdt := aCodfol[5,1]
	EndIf
Next nx

//-- Tratamento da Insalubridade
// Insal. Minima
If SRA->RA_INSMIN > 0
	cCod   := aCodfol[37,1]
EndIf
// Insal. Media
If SRA->RA_INSMED > 0
	cCod   := aCodfol[38,1]
EndIf
// Insal. Maxima
If SRA->RA_INSMAX > 0
	cCod   := aCodfol[39,1]
EndIf
// Define o codigo da insalubridade utilizada pelo funcionario
If cCod # Space(3)
	cCodIns := cCod
Endif

Return

/*


ͻ
Programa   CalcGrid Autor  Jonatas A. T. Alves  Data   18/08/08   
͹
Desc.     Inclusao do Calculo Atraves de GRID - Multiprocessamento    
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	Static Function CalcGrid(aCall,aParametros,aArqTPR,aAreaSRA)

	Local aParAmb			:= {}
	Local lRet 				:= .T.
	Local cMsgGrid 			:= ''	// Variavel para retorno de Log
	Local nI, nT, nX, nZ
	Local nTimeFim
	Local nQtde
	Local nIni
	Local nTam
	
	Local lNewGrid			:= FindFunction("GridCliVersion")
	Local aProcessoTit  	:= {}
	Local aProcessoLog  	:= {}
	Local aGpem070TitLog	:= {}
	Local aGpem070Log		:= {}
	Local aLogErro 			:= {}
	Local nLoop
	/*
	Ŀ
	 No novo build do GRID, o terceiro elemento do array aInfoProc
	 eh um identificador do agente utilizado e o quarto elemento, 
	 caso exista, eh o valor correspondente ao retorno do processo
	*/
	Local nGridLog		:= If( lNewGrid, 4, 3 ) // Se for GRID antigo o log fica na posicao 3, senao fica na posicao 4
	
	Private oGrid
	
	/*/
	Ŀ
	Adiciona Informacoes no Log de Processamento para GRID					
	*/
	aAdd( aProcessoTit , STR0056 ) // "Informacoes do Processo de Calculo com GRID"
	aAdd( aProcessoLog , STR0057 + " " + SecsToTime( nTimeIni ) + " " + STR0046 + " " + Dtoc( MsDate() ) ) // "Inicio do Processo de Calculo:" ## "de"
	
	/*
	Ŀ
	 Array de Log:											       
	  1-Erros na rotina de preparacao do GRID					   
	  2-Erros Fatais do GRID - Metodo aErrorProc				   
	  3-Erro em um lote do GRID - Metodo aSendProc				   
	  4-Erros no Lote do GRID - Tratamento feito na funcao 	   
		 GPM070GRD	- Retorno pelo Metodo aInfoProc		  		   
	*/
	aAdd( aLogErro, { STR0058, {} } ) // "Erros na preparacao do GRID"
	aAdd( aLogErro, { STR0059, {} } ) // "Erros fatais no processamento do GRID"
	aAdd( aLogErro, { STR0060, {} } ) // "Requisies no processadas"
	aAdd( aLogErro, { STR0061, {} } ) // "Log dos registros processados"
	
	/*
	Ŀ
	 Criacao do Objeto GRID e Processamento				       
	*/
	dbSelectArea("TPR")
	oGrid := GridClient():New()
	If ValType(oGrid) == "U"
		aAdd( aLogErro[1,2], OemToAnsi(STR0038) ) // "Falha na criacao do Objeto GridClient. Impossivel executar processo em GRID."
		lRet := .F.
	EndIf
	
	aTransf := {} // Limpa array aTransf, pois ser carregado via tabela temporaria associada
	
	If lRet
	
		aParAmb	:=	{	FWGrpCompany("SRA"),;
						FwCodFil(),;
						dDataBase,;
						aEmpresas,;
						cUsuario,;																	// Parametros Public do Sistema
				  		{aParametros,lFechouMes,lItemClVl,Nil,nFec131,cFilialAnt,;
				  		cNameFile,cDbfLog,cChaveLog,aIdProvis,lGrid,cFileTrf,cTrfDbf,nTamTrf},; 								// Parametros Privates de GPEM070
				  		{aTabFer,cTAfaFer,cTpBxFer,cTpCongAf,cTrfAMES,lTrfAMES,cAbatAfas,;
				  		cPgSalMat,lDif13Neg,aTransf,lSalInc,lTrataTrf,c__Roteiro,cPerFeAc,;
				  		lProvResc,cAfastProv,cCalcSalInc,lCalcSalInc,cNomeDe,cNomeAte,aArqTPR,;
				  		aInssEmp,aCodFol,aInfo,aGPSPer,aVerba,nPerc1T,nPercPis,lTrfSld,dDataDem1,lGeraPMes,cTpRtProv,lSabDom,cOneFol,cAnoMes},;
				  		If(cPaisLoc == "URU",{nCSocial,nBseFixo,nBPSFunc,nFRLFunc,Val_SalMin,;
				  		nFonasFunc,nFonasDep,nFonasSM,nSomaPerc,nTpDesc,lPagFerSe,nFonasSDep},;
				  		If(cPaisLoc == "ARG",{aObraSoc,aJubila,aLey},{}));							// Parametros Privates de Gpm070Processa
				  	}

		// Chama a execucao em Grid. Caso ela retorne .F., ou o grid nao pode ser iniciado, 
		// ou algum processo deu erro, ou um ou mais itens nao foram processados.	
		lRet := oGrid:BatchExec("GPM070AMB",aParAmb,"GPM070GRD",aCall,"GPM070END")

		// Fecha a area 'TPR' e exclui os arquivos temporarios de indice e de dados a ela
		// associados
		TPR->(dbCloseArea())
		fErase(aArqTPR[2] + OrdBagExt())		// Indice TPR
		fErase(aArqTPR[1] + GetDbExtension())	// Tabela TPR
		
		// Efetua drop table da tabela temporaria do aTransf
		( cTrfDbf )->( dbCloseArea() )
		If TCCanOpen( cFileTrf )
			MsErase( cFileTrf )
		EndIf
		
		If !lRet 
			If !Empty(oGrid:cErrorMsg)
				aAdd( aLogErro[1,2], oGrid:cErrorMsg ) // Carrega mensagens geradas pelo GRID
			EndIf
			If !Empty(oGrid:aGridThreads)
				aAdd( aLogErro[1,2], OemToAnsi(STR0039) ) // "Nenhum Agente do GRID disponivel no Momento."
			EndIf
		EndIf
	
		// Erro no processamento do GRID - Erros Fatais //
		If !Empty(oGrid:aErrorProc)
			// [1] : Numero sequencial da instrucao enviada que nao foi processada
			// [2] : Parametro enviado para processamento 
			// [3] : String contendo informacoes do ERRO
			nT := len(oGrid:aErrorProc)
			For nI := 1 to nT
	
				aAdd( aLogErro[2,2], OemToAnsi(STR0040) + " " + Str(oGrid:aErrorProc[nI,1],5)) // "Requisicao: "
	
				cMsgGrid := oGrid:aErrorProc[nI][3]
				nTamanho := Len(cMsgGrid)
				If nTamanho > 225
		            nTam := nTamanho / 225
	                nQtde 	:= Int(nTam) + If( (nTam - Int(nTam)) > 0, 1, 0)
	                nIni 	:= 1
					For nX := 1 To nQtde
						aAdd( aLogErro[2,2], Substr(oGrid:aErrorProc[nI][3],nIni,225))
						nIni := nIni + 225
					Next nX
				Else
					aAdd( aLogErro[2,2], oGrid:aErrorProc[nI][3] )
				EndIf
			Next nI
		Endif
	
		// Requisicoes que nao foram processadas //
		If !Empty(oGrid:aSendProc)
			// [1] : Numero sequencial da instrucao enviada que nao foi processada
			// [2] : Parametro enviado para processamento 
			// [3] : Retorno da execuao 
			nT := len(oGrid:aSendProc)
			For nI := 1 to nT
				aAdd( aLogErro[3,2], OemToAnsi(STR0040) + " " + Str(oGrid:aSendProc[nI,1],5)) // "Requisio: "
				aAdd( aLogErro[3,2], Space(10) + OemToAnsi(STR0041) + " " +; // "Parametros De/Ate:"
				  					  OemToAnsi(STR0033) + " " + oGrid:aSendProc[nI,2,1,2] + " " + OemToAnsi(STR0042) + " " + oGrid:aSendProc[nI,2,Len(oGrid:aSendProc[nI,2]),2] + "   "+; // "Filial" ## "a"
				  					  OemToAnsi(STR0034) + " " + oGrid:aSendProc[nI,2,1,3] + " " + OemToAnsi(STR0042) + " " + oGrid:aSendProc[nI,2,Len(oGrid:aSendProc[nI,2]),3]) // "Matrcula" ## "a"
			Next nI
		EndIf
	
		// Recupera retornos das chamadas - Mensagens de Log do Calculo (Retorno diferente de NIL da funcao GPM070GRD
		If !Empty(oGrid:aInfoProc)
			// [1] : Numero sequencial da instrucao enviada que nao foi processada
			// [2] : Parametro enviado para processamento 
			// [3] : Retorno da execuao 
			nT := Len(oGrid:aInfoProc)
			For nI := 1 To nT
				aAdd( aLogErro[4,2], oGrid:aInfoProc[nI][nGridLog][1][1] )	// Gravacao do cabecalho - Funcionario 
				For nZ := 1 To Len(oGrid:aInfoProc[nI][nGridLog][1][2])
					aAdd( aLogErro[4,2], oGrid:aInfoProc[nI][nGridLog][1][2][nZ][1] ) // Log do Erro
				Next nZ
			Next nI
		Endif
	EndIf

	/*
	Ŀ
	 Excluir os Processos que Terminaram com Sucesso.              
	*/
	cQuery := " DELETE FROM "
	cQuery += " "+ cNameFile +" "
	CQuery += " WHERE CHAVE = '" + cChaveLog + "'"
	TcSqlExec( cQuery )
	
	nTimeFim := Seconds()

	aAdd( aProcessoLog , STR0045 + " " + SecsToTime(nTimeFim) + " " + STR0046 + " "  + Dtoc( MsDate() ) ) // "Final do Processo de Calculo:" ## "de"
	aAdd( aProcessoLog , STR0047 + " " + SecsToTime(nTimeFim - nTimeIni)  ) // "Duracao do Processo de Calculo:"
	aAdd( aProcessoLog , "" )
	aAdd( aProcessoLog , STR0048 + " " + Str(oGrid:nSendSeq,5) ) // "Nro de Requisies Enviadas para Processamento:"
	aAdd( aProcessoLog , STR0049 + " " + Str(oGrid:nSendSeq-Len(oGrid:aSendProc),5) ) // "Nro de Requisies Processadas:"
	aAdd( aProcessoLog , STR0050 + " " + Str(Len(oGrid:aSendProc),5) ) // "Nro de Requisies Nao Processadas:"
	
	/*/
	Ŀ
	Adiciona Informacoes do Processamento no Log Geral           			
	*/
	aAdd( aGpem070TitLog	, aProcessoTit[1] )
	aAdd( aGpem070Log		, aClone( aProcessoLog ) )
	
	/*/
	Ŀ
	Carregando Informacoes para o Log                                      
	*/
	For nLoop := 1 To Len( aLogErro )
		If Len(aLogErro[nLoop,2]) > 0
	   		aAdd( aGpem070TitLog	, aLogErro[ nLoop , 1 ] )
	   		aAdd( aGpem070Log		, aClone( aLogErro[ nLoop , 2 ] ) )
		EndIf
	Next nLoop
		
	/*/
	Ŀ
	Mostrar o Log                                                          
	*/
	fMakeLog( aGpem070Log, aGpem070TitLog, NIL, NIL, FunName(), STR0062, NIL, NIL, NIL, .F. )
	
	RestArea(aAreaSRA)
	
	Return
#ENDIF

/*


ͻ
Programa  GPM070AMB Autor  Jonatas A. T. Alves  Data   18/08/08   
͹
Desc.     Preparacao do ambiente para GRID - Multiprocessamento       
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	Function GPM070AMB(aParms)
	Local cEmpParm  	:= aParms[1]	// Empresa conectada 	--> cEmpAnt
	Local cFilParm  	:= aParms[2]	// Filial conectada 	--> cFilAnt
	Local dDataParm 	:= aParms[3]	// Data Base			--> dDataBase
	Local aEmpParm		:= aParms[4]	// Array com empresas 	--> aEmpresas
	Local cUsuaParm 	:= aParms[5]	// Usuario conectado	--> cUsuario
	
	Local aMnemonicos 	:= {}
	Local lRet 			:= .T.
	Local lShowErr		:= .F.
	Local lSetDef
	Local nMnemo
	Local nMnemos
	Local uVar

	/*
	Ŀ
	 Preparacao de novo ambiente - Tabelas e Variaveis.           
	*/
	RpcSetType(3)
	PREPARE ENVIRONMENT EMPRESA (cEmpParm) FILIAL (cFilParm) MODULO "GPE" FUNNAME "GPEM070"
	
	/*
	Ŀ
	 Setar os mnemonicos para nao declarar a cada requisicao as   
	 PRIVATES e tardar o tempo de processo.                       
	*/
	If (lRet := fMontaMnemo( cFilParm , @aMnemonicos ))
		If (nMnemos:= Len(aMnemonicos)) > 0
			For nMnemo := 1 to nMnemos
				lSetDef := .F.
	
				/*
				Ŀ
				Inicializa e carrega os valores Padroes declarando como       
				Privates na Funcao que Chamou( 1 nivel acima )				   
				*/
				IF !Empty( uVar := AllTrim( aMnemonicos[ nMnemo , 03 ] ) )
					IF ( aMnemonicos[ nMnemo , 04 ] == "D" .and. ( "/" $ uVar ) )
						IF CheckExecForm( { || uVar := Ctod( uVar ) },lShowErr )
							IF ( ( cType := ValType( uVar ) ) == aMnemonicos[ nMnemo , 04 ] )
								_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
							Else
								lSetDef := .T.
							EndIF
						Else
							lSetDef := .T.
						EndIF
					ElseIF CheckExecForm( @uVar , lShowErr ) 
						_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
					Else
						lSetDef := .T.
					EndIF
				Else
					lSetDef := .T.
				EndIF

				If lSetDef
					_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], GetValType( aMnemonicos[ nMnemo , 04 ] ) )
				EndIf
	
			Next nMnemo
		Endif
	
		/*
		Ŀ
		Variaveis publicas do Sistema            
		*/
		aEmpresas := aClone(aEmpParm)
		dDataBase := dDataParm
		cUsuario  := cUsuaParm
	EndIf
	
	/*
	Ŀ
	| Declaracao das variaveis Private utilizadas na preparacao do |
	| ambiente para processamento em GRID.                         |
	*/
	
	//Ŀ
	//| Carregando parametros MV_PAR da rotina.                      |
	//
	_SetOwnerPrvt( 'lFerias'	, aParms[6,1,1 ] )	//  Tipo de Provisao 1 - Ferias 2 - 13  3 - Ambas
	_SetOwnerPrvt( 'l13oSal'	, aParms[6,1,2 ] )	//  Tipo de Provisao 1 - Ferias 2 - 13  3 - Ambas
	_SetOwnerPrvt( 'dDataRef'	, aParms[6,1,3 ] )	//  Data de Referencia para Calculo
	_SetOwnerPrvt( 'nOrdem'		, aParms[6,1,4 ] )	//  Ordem de Calculo 1 - Matricula  2 - Centro de Custo
	_SetOwnerPrvt( 'cFilDe'		, aParms[6,1,5 ] )	//	Filial De
	_SetOwnerPrvt( 'cFilAte'	, aParms[6,1,6 ] )	//	Filial Ate
	_SetOwnerPrvt( 'cCcDe'		, aParms[6,1,7 ] )	//	Centro de Custo De
	_SetOwnerPrvt( 'cCcAte'		, aParms[6,1,8 ] )	//	Centro de Custo Ate
	_SetOwnerPrvt( 'cMatDe'		, aParms[6,1,9 ] )	//	Matricula De
	_SetOwnerPrvt( 'cMatAte'	, aParms[6,1,10] )	//	Matricula Ate
	_SetOwnerPrvt( 'nCorrecao'	, aParms[6,1,11] )	//	Indice de Correcao
	_SetOwnerPrvt( 'lDesc1parc'	, aParms[6,1,12] )	//	Indice de Correcao
	_SetOwnerPrvt( 'lIncluiDem'	, aParms[6,1,13] )	//  Incluir Demit. 13
	_SetOwnerPrvt( 'n14Salario'	, aParms[6,1,14] )	//  Indice de 14 Sal.
	_SetOwnerPrvt( 'cCateg'		, aParms[6,1,15] )	//	Categorias
	_SetOwnerPrvt( 'nVerFatFin'	, aParms[6,1,16] )	//	Verifica integracao
	
	//Ŀ
	//| Carregando variaveis Private genericas                       |
	//		
	_SetOwnerPrvt( 'lFechouMes'	, aParms[6,2 ] )	//	Verifica se esta calculando provisao com mes fechado
	_SetOwnerPrvt( 'lItemClVl'	, aParms[6,3 ] )	//	Verifica se utiliza item contabil
	
	// Posicao 4 livre para utilizacao de outra variavel - controle de item e classe em uma unica variavel
//	_SetOwnerPrvt( 'lTemClVl'	, aParms[6,4 ] )	//	Verifica se utiliza classe de valor
	_SetOwnerPrvt( 'nFec131'	, aParms[6,5 ] )	//	Mes de pagamento da 1a. parcela do 13o. salario
	_SetOwnerPrvt( 'cFilialAnt'	, aParms[6,6 ] )	//	
	_SetOwnerPrvt( 'aIdProvis'	, aParms[6,10] )	//	
	
	//Ŀ
	//| Indica o tipo de provisao (sera gravado no campo RT_TIPPROV) |
	//
	_SetOwnerPrvt( '_FerVenc'	, 1  ) // Ferias Vencidas
	_SetOwnerPrvt( '_FerProp'	, 2  ) // Ferias Proporcionais
	_SetOwnerPrvt( '_13Salar'	, 3  ) // 13 Salario
	_SetOwnerPrvt( '_14Salar'	, 4  ) // 14 Salario  
	_SetOwnerPrvt( '_FerVMes'   , 5	 ) // Ferias Provisao Mes
	_SetOwnerPrvt( '_13SVMes'   , 6  ) // 13 Provisao Mes
	
	//Ŀ
	//| Indica a linha na ordem em que sera apresentada no relatorio |
	//
	_SetOwnerPrvt( '_Anter'		, 01 ) // Mes Anterior
	_SetOwnerPrvt( '_Corre'		, 02 ) // Correcao
	_SetOwnerPrvt( '_NoMes'		, 03 ) // No Mes
	_SetOwnerPrvt( '_Atual'		, 04 ) // Mes Atual
	_SetOwnerPrvt( '_BxTrf'		, 05 ) // Baixa de Transferencia
	_SetOwnerPrvt( '_BxFer'		, 06 ) // Baixa de Ferias
	_SetOwnerPrvt( '_Bx13o'		, 06 ) // Baixa de 13o Salario
	_SetOwnerPrvt( '_Bx14o'		, 06 ) // Baixa de 14o Salario
	_SetOwnerPrvt( '_BxRes'		, 07 ) // Baixa de Rescisao
	_SetOwnerPrvt( '_TrfEnt'	, 08 ) // Transferencia de Entrada
	_SetOwnerPrvt( '_TrfSai'	, 09 ) // Transferencia de Saida
	_SetOwnerPrvt( '_BxTot'		, 10 ) // Baixa Total
	
	//Ŀ
	//| Indica a coluna na ordem em que sera apresentada no relatorio|
	//
	_SetOwnerPrvt( '_Dias'		, 1  ) // Dias de Ferias
	_SetOwnerPrvt( '_Avos'		, 1  ) // Avos de 13 Salario
	_SetOwnerPrvt( '_Prov'		, 2  ) // Valor da Provisao de Ferias ou Decimo Terceiro Salario
	_SetOwnerPrvt( '_Adic'		, 3  ) // Adicionais
	_SetOwnerPrvt( '_1Ter'		, 4  ) // Um Terco de Ferias
	_SetOwnerPrvt( '_1Par'		, 4  ) // 1 Parcela do 13 Salario
	_SetOwnerPrvt( '_INSS'		, 5  ) // INSS
	_SetOwnerPrvt( '_FGTS'		, 6  ) // FGTS
	_SetOwnerPrvt( '_SalV'		, 7  ) // Media Salario Vac
	_SetOwnerPrvt( '_PIS'		, 8  ) // PIS
	
	//Ŀ
	// Constantes que definem o numero de linhas e colunas do array |
	//
	_SetOwnerPrvt( '_Linhas'	, 10 ) // Quantidade de Linhas ou Elementos
	_SetOwnerPrvt( '_Colunas'	, 08 ) // Quantidade de colunas para cada Linha ou Elemento
	
	//Ŀ
	// Indica a posicao das informacoes de cabecalho em "aCabProv"  |   
	//
	_SetOwnerPrvt( '_DatCalc'	,  1 ) // Data do calculo
	_SetOwnerPrvt( '_CentroC'	,  2 ) // Data do calculo
	_SetOwnerPrvt( '_DBsProv'	,  3 ) // Data base de ferias
	_SetOwnerPrvt( '_DFerVen'	,  4 ) // Dias de ferias vencidas
	_SetOwnerPrvt( '_DFerPro'	,  5 ) // Dias de ferias proporcionais
	_SetOwnerPrvt( '_DFerAnt'	,  6 ) // Dias de ferias antecipadas
	_SetOwnerPrvt( '_DFalVen'	,  7 ) // Dias de faltas vencidas
	_SetOwnerPrvt( '_DFalPro'	,  8 ) // Dias de faltas proporcionais
	_SetOwnerPrvt( '_MovProv'	,  9 ) // Movimentacao no mes
	_SetOwnerPrvt( '_SalProv'	, 10 ) // Salario da provisao no mes
	_SetOwnerPrvt( '_Avos13S'	, 11 ) // Avos de 13 salario 
	_SetOwnerPrvt( '_PStatus'	, 12 ) // Status (Ativo/Excluido)
	_SetOwnerPrvt( '_CItem'		, 13 ) // Item Contabil
	_SetOwnerPrvt( '_Clvl'		, 14 ) // Classe de Valor
	
	//Ŀ
	// Indica os tipos de movimentacao do funcionario no mes        |
	//
	_SetOwnerPrvt( '_Demitido'	, 1  ) // Demitido
	_SetOwnerPrvt( '_Cong_Fer'	, 2  ) // Congelado Ferias
	_SetOwnerPrvt( '_Cong_13s'	, 3  ) // Congelado 13 Salario
	_SetOwnerPrvt( '_Cong_F13'	, 4  ) // Congelado Ferias e 13 Salario
	_SetOwnerPrvt( '_Trfe_Sai'	, 5  ) // Transferencia Saida 
	_SetOwnerPrvt( '_Trfe_Ent'	, 6  ) // Transferencia Entrada
	
	//Ŀ
	// Indica as posicoes dentro do array aTransf                   |
	//
	_SetOwnerPrvt( '_TAnter'	, 1  ) // Centro de Custo Anterior
	_SetOwnerPrvt( '_TAtual'	, 2  ) // Centro de Custo Atual
	_SetOwnerPrvt( '_TDest'		, 3  ) // Centro de Custo Destino
	_SetOwnerPrvt( '_TEmp'		, 1  ) // Empresa
	_SetOwnerPrvt( '_TFil'		, 2  ) // Filial
	_SetOwnerPrvt( '_TCC'		, 3  ) // Centro de Custo
	_SetOwnerPrvt( '_TMat'		, 4  ) // Matricula
	_SetOwnerPrvt( '_TDta'		, 5  ) // Data da Transferencia
	_SetOwnerPrvt( '_TInc'		, 6  ) // Funcionario ja incluido no arquivo temporario  
	_SetOwnerPrvt( '_TItm'		, 7  ) // Item Contabil 
	_SetOwnerPrvt( '_TClv'		, 8  ) // Classe de valor  
	
	//Ŀ
	// Variaveis para criacao dos arquivos temporarios LOG/TRP/TPR  |
	//
	_SetOwnerPrvt( 'lGrid'		, aParms[6,11])	//	Mes de pagamento da 1a. parcela do 13o. salario
	_SetOwnerPrvt( 'aLogFile'	, {}          )		// Nome do Arquivo de Log de identif. - fAdicLog()
	_SetOwnerPrvt( 'cNameFile'	, aParms[6,7] )		// Nome do Arquivo de Log
	_SetOwnerPrvt( 'cDbfLog'	, aParms[6,8] )		// Alias do Arquivo de Log
	_SetOwnerPrvt( 'cChaveLog'	, aParms[6,9] )		// Chave do Arquivo de Log
	_SetOwnerPrvt( 'cFileTrf'	, aParms[6,12])		// Tabela temporaria de transferencias
	_SetOwnerPrvt( 'cTrfDbf'	, aParms[6,13])		// Alias de transferencia
	_SetOwnerPrvt( 'nTamTrf'	, aParms[6,14])		// No. de elementos total de aTransf
	_SetOwnerPrvt( 'cArqDbf'	, "" ) 				// Arquivo DBF para Medias
	_SetOwnerPrvt( 'cArqNtx'	, "" ) 				// Arquivo temporario de indice para Medias
	_SetOwnerPrvt( 'cTPRDbf'	, aParms[7,21,1] ) // Arquivo DBF para Medias
	_SetOwnerPrvt( 'cTPRNtx'	, aParms[7,21,2] ) // Arquivo temporario de indice para Medias
	
	//Ŀ
	// Variaveis Private de Gpm070Processa                          |
	//	
	_SetOwnerPrvt( 'aTabFer'	, aParms[7, 1] ) // Tabela para calculo dos dias de ferias
	_SetOwnerPrvt( 'cTAfaFer'	, aParms[7, 2] ) // Trata Perda de Periodo Para Afastados
	_SetOwnerPrvt( 'cTpBxFer'	, aParms[7, 3] ) // Baixa Ferias Total ou Mes e Mes Seguinte
	_SetOwnerPrvt( 'cTpCongAf'	, aParms[7, 4] ) // Trata congelamento por periodo Aquisitivo ou Por afastamento
	_SetOwnerPrvt( 'cTrfAMES'	, aParms[7, 5] ) // Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
	_SetOwnerPrvt( 'lTrfAMES'	, aParms[7, 6] ) // Indica se utilizara se utilizara demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
	_SetOwnerPrvt( 'cAbatAfas'	, aParms[7, 7] ) // Indica se abate avos por Afast. no 13 Salario
	_SetOwnerPrvt( 'cPgSalMat'	, aParms[7, 8] ) // Abater Afastamento Auxilio Maternidade no 13
	_SetOwnerPrvt( 'lDif13Neg'	, aParms[7, 9] ) // Gerar diferenca de 13o. negativa S/N
	_SetOwnerPrvt( 'aTransf'  	, aParms[7,10] ) // Array com as transferencias do funcionario
	_SetOwnerPrvt( 'lSalInc'	, aParms[7,11] ) // Utiliza salario incorporado         
	_SetOwnerPrvt( 'lTrataTrf'	, aParms[7,12] ) // Utiliza conceito de transferencia de saldo demonstrando saida e entrada
	_SetOwnerPrvt( 'c__Roteiro'	, aParms[7,13] ) // Roteiro de calculo a ser processado
	_SetOwnerPrvt( 'cPerFeAc'	, aParms[7,14] ) // Usada na Funcao FCalcFimAq-(GpexMed).
	_SetOwnerPrvt( 'lProvResc'	, aParms[7,15] ) // Indica se devera provisionar no mes da rescisao
	_SetOwnerPrvt( 'cAfastProv'	, aParms[7,16] ) // Afastamentos tratados pela provisao
	_SetOwnerPrvt( 'cCalcSalInc', aParms[7,17] ) // Ano/Mes para inicio da busca dos salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
	_SetOwnerPrvt( 'lCalcSalInc', aParms[7,18] ) // Define se busca os salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
	_SetOwnerPrvt( 'cNomeDe'	, aParms[7,19] ) // Nome inicial para filtro na montagem do arquivo TPR
	_SetOwnerPrvt( 'cNomeAte'	, aParms[7,20] ) // Nome final para filtro na montagem do arquivo TPR
	_SetOwnerPrvt( 'aInssEmp'	, aParms[7,22] ) // Array com os percentuais e informacoes dos encargos da empresa
	_SetOwnerPrvt( 'aCodFol'	, aParms[7,23] ) // Array com os codigos de verbas que possuem identificador de calculo
	_SetOwnerPrvt( 'aInfo'		, aParms[7,24] ) // Arary com informacoes da empresa
	_SetOwnerPrvt( 'aGPSPer'	, aParms[7,25] ) // 
	_SetOwnerPrvt( 'aVerba'		, aParms[7,26] ) // 
	_SetOwnerPrvt( 'nPerc1T'	, aParms[7,27] ) // 
	_SetOwnerPrvt( 'nPercPis'	, aParms[7,28] ) // 
	_SetOwnerPrvt( 'lTrfSld'	, aParms[7,29] ) // Indica se eh demissao com transferencia e MV_PROVRES = N
	_SetOwnerPrvt( 'dDataDem1'	, aParms[7,30] ) // Data de demissao considerando MV_SABDOM
	_SetOwnerPrvt( 'lGeraPmes'	, aParms[7,31] ) // Gera rateio mensal
	_SetOwnerPrvt( 'cTpRtProv'	, aParms[7,32] ) // Determina Tipo de rateio / Alias a ser utilziado ( "SRT*RHT")
	_SetOwnerPrvt( 'lSabDom'	, aParms[7,33] ) // Se pagara o sab e domingo qdo demissao na sexta
	_SetOwnerPrvt( 'cOneFol'	, aParms[7,34] ) // Usada nas Funcoes fPercEmp, fEncargEmp e fProv13o
	_SetOwnerPrvt( 'cAnoMes'	, aParms[7,35] ) // Usada nas Funcoes fPercEmp, fEncargEmp e fProv13o
		
	//Ŀ
	// Variaveis Private de Gpm070Processa carregadas por IniVarGrd |
	//	
	_SetOwnerPrvt( 'aFerVenc'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'aFerProp'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'aRecVenc'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'aRecProp'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'nV_DFalFer'	, 0		) // 
	_SetOwnerPrvt( 'nP_DFalFer'	, 0		) // 
	_SetOwnerPrvt( 'nTFaltaV'	, 0		) // 
	_SetOwnerPrvt( 'nTFaltaP'	, 0		) // 
	_SetOwnerPrvt( 'nDFerAnt'	, 0		) // 
	_SetOwnerPrvt( 'cCodFer'	, ""	) // 
	_SetOwnerPrvt( 'cCodAdFer'	, ""	) // 
	_SetOwnerPrvt( 'cCodUmTer'	, ""	) // 
	_SetOwnerPrvt( 'cCodFerMs'	, ""	) // 
	_SetOwnerPrvt( 'cCodAdicMs'	, ""	) // 
	_SetOwnerPrvt( 'cCodUmTerMs', ""	) // 
	_SetOwnerPrvt( 'cCodAbono'	, ""	) // 
	_SetOwnerPrvt( 'cCodAboMs'	, ""	) // 
	_SetOwnerPrvt( 'cCodSalV'	, ""	) // 
	_SetOwnerPrvt( 'cCodSalVMs'	, ""	) // 
	_SetOwnerPrvt( 'dDtBasFer'	, CTOD("")	) // 
	_SetOwnerPrvt( 'a13Salar'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'a14Salar'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'aRec13Sl'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'aRec14Sl'	, Array(_Linhas,_Colunas)	) // 
	_SetOwnerPrvt( 'cCod13o'	, ""	) // 
	_SetOwnerPrvt( 'cCodAd13o'	, ""	) // 
	_SetOwnerPrvt( 'cInss13o'	, ""	) // 
	_SetOwnerPrvt( 'lBx13Pgt'	, .F.	) // 
	_SetOwnerPrvt( 'lDesAtiv'	, .F.	) // 
	_SetOwnerPrvt( 'nAvosAnt'	, 0		) // 
	_SetOwnerPrvt( 'nPercAnt'	, 0		) // 
	_SetOwnerPrvt( 'nSalario'	, 0		) // 
	_SetOwnerPrvt( 'nSalMes'	, 0		) // 
	_SetOwnerPrvt( 'nSalDia'	, 0		) // 
	_SetOwnerPrvt( 'nSalHora'	, 0		) // 
	_SetOwnerPrvt( 'nPerEmp13'	, 0		) // 
	_SetOwnerPrvt( 'nPercEmp'	, 0		) // 
	_SetOwnerPrvt( 'nPercTer'	, 0		) // 
	_SetOwnerPrvt( 'nPercAcTrab', 0		) // 
	_SetOwnerPrvt( 'nPercFgts'	, 0		) // 
	_SetOwnerPrvt( 'lDemitido'	, .F.	) // 
	_SetOwnerPrvt( 'lTransfSai'	, .F.	) // 
	_SetOwnerPrvt( 'aRoteiro'	, {}	) // 
	_SetOwnerPrvt( 'nAdtServ'	, 0.00	) // Valor do Adicional por Tempo de Servico
	_SetOwnerPrvt( 'nPeric'		, 0.00	) // Valor do Adicional de Periculosidade
	_SetOwnerPrvt( 'nInsal'		, 0.00	) // Valor do Adicional de Insalubridade
	_SetOwnerPrvt( 'cCodAdt'	, Space(3)	) // 
	_SetOwnerPrvt( 'cCodIns'	, Space(3)	) // 
	_SetOwnerPrvt( 'nSalMin'	, 0		) // 
	_SetOwnerPrvt( 'cRecFatEmp'	, ""	) // X14_RECFAT
	_SetOwnerPrvt( 'lDissidio'	, .F. 	) //
	_SetOwnerPrvt( 'lINSSAut'	, .F. 	) //
		
	If cPaisLoc == "URU"
		_SetOwnerPrvt( 'nCSocial'	, aParms[8,1 ] ) // 
		_SetOwnerPrvt( 'nBseFixo'	, aParms[8,2 ] ) // 
		_SetOwnerPrvt( 'nBPSFunc'	, aParms[8,3 ] ) // 
		_SetOwnerPrvt( 'nFRLFunc'	, aParms[8,4 ] ) // 
		_SetOwnerPrvt( 'Val_SalMin'	, aParms[8,5 ] ) // 
		_SetOwnerPrvt( 'nFonasFunc'	, aParms[8,6 ] ) // 
		_SetOwnerPrvt( 'nFonasDep'	, aParms[8,7 ] ) // 
		_SetOwnerPrvt( 'nFonasSM'	, aParms[8,8 ] ) // 
		_SetOwnerPrvt( 'nSomaPerc'	, aParms[8,9 ] ) // 
		_SetOwnerPrvt( 'nTpDesc'	, aParms[8,10] ) //
		_SetOwnerPrvt( 'nFonasSDep'	, aParms[8,12] ) //	 
		_SetOwnerPrvt( 'lProvUru'	, .T.	) // 
		_SetOwnerPrvt( 'cSemana'	, "01"	) // 
		_SetOwnerPrvt( 'nAliqBse'	, 0		) // 
		_SetOwnerPrvt( 'cApolice'	, " "	) // 
		_SetOwnerPrvt( 'lPagFerSe'	, aParms[8,11] ) // O pagamento das Ferias deve ser separado da Folha de Pag.
	ElseIf cPaisLoc == "ARG"
		_SetOwnerPrvt( 'aObraSoc'	, aParms[8,1 ] ) // 
		_SetOwnerPrvt( 'aJubila'	, aParms[8,2 ] ) // 
		_SetOwnerPrvt( 'aLey'		, aParms[8,3 ] ) // 
	EndIf
	
	//Ŀ
	//| Cria Arquivo de Medias Temporario						   |
	//
	Cria_TRP(@cArqDbf,@cArqNtx)

	Return(lRet)
#ENDIF

/*


ͻ
Programa  GPM070END Autor  Jonatas A. T. Alves  Data   18/08/08   
͹
Desc.     Finalizacao da Thread na provisao                           
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	Function GPM070END()
	
	// Exclusao dos arquivos temporarios criados para Media
	TRP->(dbCloseArea())
	fErase(cArqNtx + OrdBagExt())
	fErase(cArqDbf + GetDbExtension())
	
	Return(.T.)
#ENDIF

/*


ͻ
Programa  GPM070GRD Autor  Mauricio Takakura    Data   31/01/07   
͹
Desc.     Funcao para Encapsulamento de Multiprocessamento            
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	Function GPM070GRD(aCall)

	Local aLog 		:= {} 	// Log por Lote enviado
	Local aSvLog	:= {}

	Local cFilCalc 			// Filial 
	Local cMatrCalc			// Matricula
	Local cCCCalc			// C.Custo
	Local cChave
	Local cCond		:= If( nOrdem == 1, 'TPR->( PR_FILIAL + PR_MAT )', 'TPR->( PR_FILIAL + PR_CC + PR_MAT )' )
	Local cRequis
	Local cQuery
	Local cMsgLog

	Local lRet		:= .T.
	
	Local nX
	Local nY
	Local nT
	Local nTotReg
	Local nTpMvCalc			// Tipo do movimento
	Local nTrf
	Local nEleTrf

	Local uRetCalc
	
	/*
	Ŀ
	Tratamento para Arquivo de Log           
	*/
	If !(lRet := MsOpenDbf( .T. , "TOPCONN", cNameFile , cDbfLog , .T. , .F. , .F. , .F. ))
		cMsgLog := CRLF + OemToAnsi(STR0043) // "Nao foi possivel abrir o Arquivo de Log de Registros"
		UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
	EndIf

	IF !( lRet := ( Select( cDbfLog ) > 0 ) )
		cMsgLog := CRLF + OemToAnsi(STR0043) // "Nao foi possivel abrir o Arquivo de Log de Registros"
		UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
	EndIF

	If !( Select("TPR") > 0 ) //So abre o alias no primeiro calculo da Thread
		Open_TPR(cTPRDbf,cTPRNtx)
	EndIf
	
	If !( Select( cTrfDbf ) > 0 ) //So abre o alias no primeiro calculo da Thread
		If !(lRet := MsOpenDbf( .T. , "TOPCONN", cFileTrf , cTrfDbf , .T. , .F. , .F. , .F. ))
			cMsgLog := CRLF + OemToAnsi(STR0063) // "Nao foi possivel abrir o Arquivo de Log de Registros"
			UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
		EndIf
	EndIf

	/*
	Ŀ
	 Preparacao do array aTransf a partir da tabela temporaria	   
	*/
	If Empty( aTransf )
		aTransf := Array( nTamTrf, 3, 6 )
		
		dbSelectArea( cTrfDbf )
		While !( cTrfDbf )->( Eof() )
			
			nTrf 	:= ( cTrfDbf )->TRFPOS	 // Posicao no aTransf original
			nEleTrf := ( cTrfDbf )->TRFELE	 // Posicao no aTransf original
	
			aTransf[ nTrf, nEleTrf, 1 ] := ( cTrfDbf )->TRFEMPP
			aTransf[ nTrf, nEleTrf, 2 ] := ( cTrfDbf )->TRFFILIALP
			aTransf[ nTrf, nEleTrf, 3 ] := ( cTrfDbf )->TRFCCP
			aTransf[ nTrf, nEleTrf, 4 ] := ( cTrfDbf )->TRFMATP
			aTransf[ nTrf, nEleTrf, 5 ] := ( cTrfDbf )->TRFDATE
			aTransf[ nTrf, nEleTrf, 6 ] := ( cTrfDbf )->TRFNLIDO
			
			( cTrfDbf )->( dbSkip() )
		EndDo
	EndIf
	
	/*
	Ŀ
	 Incluir o Registro da Requisicao no LOG			           
	*/
	DbSelectArea( cDbfLog )
	cRequis := StrZero( aCall[1,1] , 8)
	RecLock( cDbfLog , .T., .T. )
	(cDbfLog)->CHAVE 	:= cChaveLog
	(cDbfLog)->REQUIS 	:= cRequis 
	(cDbfLog)->( MsUnLock() )
	
	nTotReg := Len(aCall)
	For nX := 1 to nTotReg
		cFilCalc 	:= aCall[nX,2]	// Filial 
		cMatrCalc	:= aCall[nX,3]	// Matricula
		cCCCalc		:= aCall[nX,4]	// C.Custo
		nTpMvCalc	:= aCall[nX,5]	// Tipo do movimento

		/*
		Ŀ
		 Garante selecao das areas utilizadas   			           
		*/	
		dbSelectArea( "SRT" )
		SRT->( dbGoTop() )
		
		dbSelectArea( "SRC" )
		dbSetOrder(1)
		SRC->( dbGoTop() )
		
		dbSelectArea( "SRA" )
		dbSetOrder( 1 )
		SRA->( dbGoTop() )
		dbSeek( cFilCalc + cMatrCalc, .F. )

		dbSelectArea( "TPR" )
		dbSetOrder( 1 )
		TPR->( dbGoTop() )
		
		// O TPR pode estar nas ordens 1 ou 2 no calculo da provisao
		If nOrdem == 1
			cChave := cFilCalc + cMatrCalc
			dbSeek( cFilCalc + cMatrCalc, .F. )
		Else
			cChave := cFilCalc + cCCCalc + cMatrCalc
			dbSeek( cFilCalc + cCCCalc + cMatrCalc, .F. )
		EndIf

		/*
		Ŀ
		 Pode haver mais de um registro do funcionario no TPR, com    
		 c.custo e/ou tipo de movimentacao diferentes.				   
		*/
		While !TPR->(Eof()) .And. &(cCond) == cChave
			If	TPR->(	PR_CC		== cCCCalc		.And.;
						PR_TIPMOVI	== nTpMvCalc	;
					  )
				
				Exit
			Else
				TPR->(dbSkip())
				Loop
			EndIf
		EndDo
		
		/*
		Ŀ
		 Executa o Calculo da Provisao						           
		*/
		uRetCalc := GPM070CALG()

		// Verifica se existe mensagem para envio ao final do processamento //
		aSvLog 		:= GetMsgLogGrid()		// Retorna o Log de Erros
		lBreakCalc 	:= AbortCalc()			// Verifica se foi solicitado o cancelamento do calculo no LOG
		
		//Verifica ocorrencia de mensagens de log de retorno da GPM070CALG()
		If ( ValType(uRetCalc) == "L" .And. !uRetCalc ) .Or. lBreakCalc
			
			nX := nTotReg
			cMsgLog := CRLF + CRLF 
		
			For nT := 1 To Len( aSvLog )
				For nY := 1 To Len( aSvLog[nT] )
					cMsgLog += aSvLog[nT,nY] + CRLF
				Next nY
			Next nT
		
			If !lBreakCalc
				cMsgLog += CRLF + "Aborted by UserException" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
			Else
				cMsgLog += CRLF + "Calculate Process Aborted with UserException by" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
			EndIf

			UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
		EndIf
		
		// Ocorrencias de log que nao abortaram o calculo
		If !Empty(aSvLog)
			aAdd( aLog, { SRA->RA_FILIAL + "  " + SRA->RA_MAT + "  " + SRA->RA_NOME, aClone( aSvLog ) } )
			RstMsgLogGrid()
		EndIf
		
		/*
		Ŀ
		 Atualizar o LOG com o ultimo funcion. processado da Requisicao
		*/
		cQuery := " UPDATE "
		cQuery += " "+ cNameFile +" "
		cQuery += " SET   CONTROL = '1',  "
		cQuery += " FILIAL = '" + SRA->RA_FILIAL + "', "
		cQuery += " MAT = '" + SRA->RA_MAT + "', "
		cQuery += " DT_GRAVA = '" + DTOC(MsDate()) + "', "
	    cQuery += " HR_GRAVA = '" + Time() + "' "
	    cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
	    cQuery += "   AND REQUIS = '" + cRequis + "'"
		TcSqlExec( cQuery )
		
	Next nX
	
	If Empty(aLog)
		aLog := NIL
	EndIf
	
	/*
	Ŀ
	 Atualizar o LOG com o Tipo 3-Finalizado com Sucesso   	   
	*/
	cQuery := " UPDATE "
	cQuery += " "+ cNameFile +" "
	cQuery += " SET   CONTROL = '3' "
	cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
	cQuery += "   AND REQUIS = '" + cRequis + "'"
	TcSqlExec( cQuery )
	
	( cDbfLog )->( DbCloseArea() )
	TPR->( DbCloseArea() )
	
	Return( aLog )	
#ENDIF

/*


ͻ
Programa  GPM070CALGAutor  Jonatas A. T. Alves  Data   18/08/08   
͹
Desc.     Funcao para calculo da provisao utilizando GRID             
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	STATIC Function GPM070CALG()
	
	//Ŀ
	// Variaveis Locais - PROVISAO DE FERIAS 						 
	//
	Local cCongAci		:= GetMv( "MV_PFCALAC" ) // Indica se congela por Afast. Acidente 
	Local cCongDoe		:= GetMv( "MV_PFCALAD" ) // Indica se congela por Afast. Doenca
	
	//Ŀ
	// Variaveis Locais - PROVISAO DE 13 SALARIO					 
	//
	Local cAbatAci	    := GetMv( "MV_PDCALAC" )            // Indica se abate avos por Afast. Acidente
	Local cAbatAdo	    := SuperGetMv("MV_PDCADOC",, "N")   // Indica se abate avos por Afast. Adocao
	Local cAbatDoe      := GetMv( "MV_PDCALAD" )            // Indica se abate avos por Afast. Doenca
	Local cArqBxa13,cFilBxa13,cMatBxa13,cDatBxa13,cPdBxa13,cValBxa13
	
	//Ŀ
	// Variaveis Locais - PROVISAO DE FERIAS E 13 SALARIO	  |
	//
	Local nTipoMovMes  := 0
	Local nPercFgC     := 0
	Local aCabProv     := {}
	Local cNomeCpo,cArqBxaPr,cFilBxaPr,cMatBxaPr,cDatBxaPr,cPdBxaPr,cSeqBxaPr,cValBxaPr,cHrsBxaPr
	Local lTemCab		:= .F.  
	Local dRefMed		:= dDataRef
	Local aTabBPC       := {}
	Local nValBpc       := 0
	Local lDepen        := .F.

	//Ŀ
	// Variaveis utilizadas para baixa de ferias e de rescisao nas|
	// provisoes de ferias e de 13o Salario (SRC ou SRD).         |
	//
	cArqBxaPr := "SRC"
	cNomeCpo  := "SRC->RC_"
	cDatBxaPr := &( "{ || MesAno(dDataRef) }" )
	If lFechouMes
		cNomeCpo  := "SRD->RD_"
		cArqBxaPr := "SRD"
		cDatBxaPr := &( "{ || " + cNomeCpo + "DATARQ }" )
	EndIf
	cFilBxaPr := &( "{ || " + cNomeCpo + "FILIAL }" )
	cMatBxaPr := &( "{ || " + cNomeCpo + "MAT }"    )
	cPdBxaPr  := &( "{ || " + cNomeCpo + "PD }"     )
	cSeqBxaPr := &( "{ || " + cNomeCpo + "SEQ }"    )
	cValBxaPr := &( "{ || " + cNomeCpo + "VALOR }"  )
	cHrsBxaPr := &( "{ || " + cNomeCpo + "HORAS }"  )
	
	//Ŀ
	// Variaveis utilizadas para baixa de 13o Salario (SRI ou SRD)|
	//
	If l13oSal
		cArqBxa13 := "SRI"
		cNomeCpo  := "SRI->RI_"
		cDatBxa13 := &( "{ || Strzero(Year(SRI->RI_DATA),4) }" )
		If lFechouMes
			cNomeCpo  := "SRD->RD_"
			cArqBxa13 := "SRD"
			cDatBxa13 := &( "{ || " + cNomeCpo + "DATARQ }" )
		EndIf
		cFilBxa13 := &( "{ || " + cNomeCpo + "FILIAL }" )
		cMatBxa13 := &( "{ || " + cNomeCpo + "MAT }"    )
		cPdBxa13  := &( "{ || " + cNomeCpo + "PD }"     )
		cValBxa13 := &( "{ || " + cNomeCpo + "VALOR }"  )
	EndIf

	IniVarGrd() // Inicializa variaveis Private com conteudos padroes.

	//Ŀ
	// Inicializa a gravacao dos lancamentos do SIGAPCO        
	//
	PcoIniLan("000091")        
	
	//Ŀ
	// Quebra filial para buscar as tabelas						 
	//
	If TPR->PR_FILIAL # cFilialAnt
		If !Fp_CodFol(@aCodFol,TPR->PR_FILIAL)		 .Or.;
		   !fInfo(@aInfo,TPR->PR_FILIAL)
           	Return(.F.)
		Endif
		
		If !fInssEmp(TPR->PR_FILIAL,@aInssEmp,.F.,MesAno(dDataRef))
			MsgLogGrid(Ap5GetHelp("GR240SEMP"),.F.)
			Return(.F.)
		EndIf

		//Ŀ
		// Resgata os percentuais de terceiros armazenados no parametro 15			
		//	
		fGPSVal(TPR->PR_FILIAL,"999999",@aGPSPer,"1")

		//Ŀ
		// Limpa array de identificadores utilizados na cadastrados	 
		//
		aIdProvis := {}

		//Ŀ
		// Carrega Codigos de Ferias/13o Salario Para Baixa da Provisao 
		//
		fBusCodBx()

		//Ŀ
		// Carrega os identificadores da Provisao						 
		//
		fIdentProv(@aVerba,aCodFol)

		//Ŀ
		// Verifica a existencia dos identificadores da provisao		 
		//
		fChkIdent(aVerba,_FerVenc,{_Atual,_BxFer,_BxTrf},.T.)
		fChkIdent(aVerba,_13Salar,{_Atual,_BxTrf},.T.)

		//Ŀ
		// Verifica a existencia dos identificadores da provisao Mes	 
		//
		If lGeraPMes
			fChkIdent(aVerba,_FerVMes,{_Atual},.T.)
			fChkIdent(aVerba,_13SVMes,{_Atual},.T.)
		Endif

		//Ŀ
		// Verifica a existencia dos identificadores de baixa de 13o.	 
		//
		lBx13Pgt := fChkIdent(aVerba,_13Salar,{_Bx13o},.T.)

		//Ŀ
		// Verifica a existencia dos identificadores de correcao        
		//
		If nCorrecao > 0
			fChkIdent(aVerba,_FerVenc,{_Corre},.T.)
			fChkIdent(aVerba,_13Salar,{_Corre},.T.)
		EndIf

		//Ŀ
		// Verifica a existencia dos identificadores da provisao 14 Sal 
		//
		If n14Salario > 0
			fChkIdent(aVerba,_14Salar,{_Atual},.T.)
		EndIf

		//Ŀ
		// Busca percentual do identificador de 1/3 de ferias           
		//
		dbSelectArea( "TPR" )
		cFilialAnt := TPR->PR_FILIAL
		nPerc1T := PosSrv(aCodFol[77,1],TPR->PR_FILIAL,"RV_PERC")

		//Ŀ
		// Busca o percentual do identificador do PIS 								
		//	
		nPercPis := PosSrv( aCodFol[229,1],TPR->PR_FILIAL,"RV_PERC") / 100

		//Ŀ
		// Se gerou Ocorrencias aborta para apresentacao do LOG		 
		//
		If fAdicLog(aIdProvis,TPR->PR_FILIAL)
			Return(.F.)
		EndIf

		If cPaisLoc == "URU"
			If !Loc_Bse(@nCSocial, @nBseFixo,,MesAno(dDataRef))   	
				Return(.F.) // Retornar string da funcao Help)
			Endif	     
			//Ŀ
			// Carregando Variaveis com as Aliquotas do Imposto BPS	     
			//
			If !LOC_BPS(,@nBPSFunc,,MesAno(dDataRef))
				Return(.F.)
			EndIf
		   	//Ŀ
			// Carregando Variaveis com as Aliquotas do Imposto FRL	     
			//
			If !LOC_FRL(,@nFRLFunc,MesAno(dDataRef))
				Return(.F.)
			EndIf
			//Ŀ
			// CARREGA SALARIO MINIMO                                     
			//
			Sal_Min(@Val_SalMin,MesAno(dDataBase))			
			//Ŀ
			// Carregando Variaveis com as Aliquotas do Imposto DISSE	     
			//
			If !LOC_FONASA(,,@nFonasFunc,MesAno(dDataRef),,@nFonasDep,@nFonasSM,@nFonasSDep)
				Return(.F.)
			EndIf
			
			//
			// Carrega o valor do BPC |
			//
			fCarrTab( @aTabBPC   , "S003", Nil)
			// Valor do Bpc
			IF Len(aTabBPC) > 0
				nValBpc   := fTabela("S003", 1 , 4 )
			Endif
				
			//Ŀ
			// Define a aliquota DISSE conforme o Salario e dependentes     
			//			                     
			dbSelectArea( "SRA" )
			
			If SRA->RA_SALARIO > (nValBpc * 2.5)
				dbSelectArea( "SRB" )
				dbSeek(SRA->RA_FILIAL + SRA->RA_MAT)

				//Verificar se existe dependentes
				While !Eof() .And. SRB->RB_FILIAL + SRB->RB_MAT == SRA->RA_FILIAL + SRA->RA_MAT
					If (SRB->RB_GRAUPAR == "F")
						If DateDiffYear(SRB->RB_DTNASC,dDataBase) < 18 .Or. DateDiffYear(SRB->RB_DTNASC,dDataBase) > 18 .And. (SRB->RB_TIPIR == "1")
 							nTpDesc := nFonasDep //Se apenas um atender a condicao o valor sera aplicado
 							lDepen  := .T.
 							Exit
				 		Endif
					Endif
					
					dbSkip()
				Enddo	
			Else
				nTpDesc	:= nFonasSM  //Sem dependentes e menor de 2.5 Salarios Minimos
			Endif
			
			//Ŀ
			// Tratamento Aliquota Fonasa com dependentes ou sem dependentes 
			//
			IF lDepen
				nTpDesc += nFonasDep
			ELSE
				nTpDesc += nFonasSDep 
			ENDIF			
			
			nSomaPerc := (nBpsFunc+nFrlFunc+nTpDesc) / 100	
		Endif
		
		If cPaisLoc == "ARG"
			If !LOC_ProvArg(@aObraSoc,@aJubila,@aLey)
				Return(.F.)
			Endif			
		Endif
	Endif
	
	If cPaisLoc == "URU"
		DbSelectArea("CTT")
		If dbSeek(SRA->RA_FILIAL+SRA->RA_CC)
			cApolice := CTT->CTT_POLIZA
		Endif	
		If !Empty(cApolice)	
			If !Loc_Bse2(cApolice,@nAliqBse)
				Return(.F.)
			Endif
		Endif
	Endif
	
	//Ŀ
	//| Carrega tabela para apuracao dos dias de ferias - aTabFer    |
	//| 1-Meses Periodo    2-Nro Periodos   3-Dias do Mes    4-Fator |
	//
	fTab_Fer(@aTabFer)

	//Ŀ
	// Carrega variaveis para calculo dos encargos           		 
	//
	fEncargEmp(@nPercEmp, @nPercTer, @nPercAcTrab, @nPercFgts, nPercFgC, @cRecFatEmp, @nPerEmp13)

	nDFerAnt  := 0								  // Dias de ferias antecipadas
	dDtBasFer := TPR->PR_ADMISSA			      // Data Base Ferias Funcionario
	dbSelectArea( "SRF" )
	
	If !dbSeek( TPR->PR_FILIAL + TPR->PR_MAT )	  // Se nao achou Registro
		RecLock("SRF",.T.)                       // Gera automatico
		SRF->RF_FILIAL := TPR->PR_FILIAL
		SRF->RF_MAT    := TPR->PR_MAT
		SRF->RF_DATABAS:= TPR->PR_ADMISSA
		MsUnlock()
	Else
		dDtBasFer := If(SRF->RF_DATABAS # CtoD(""),SRF->RF_DATABAS,dDtBasFer)
		nDFerAnt  := SRF->RF_DFERANT
	Endif
	dbSelectArea( "TPR" )

	//Ŀ
	// Verifica o tipo de movimentacao do funcionario 				 
	//
	nTipoMovMes := TPR->PR_TIPMOVI
	lTransfSai  := ( nTipoMovMes == _Trfe_Sai )
	lDemitido   := ( nTipoMovMes == _Demitido )

	//Ŀ
	// 1 ELEMENTO DO ARRAY - A N T E R I O R 			 			 
	//
//	fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.F.,lFerias,l13oSal,If( nTipoMovMes == 0 .Or. nTipoMovMes == 6,.T.,.F.)) 
	fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.F.,lFerias,l13oSal) 
	//Ŀ
	// 2 ELEMENTO DO ARRAY - C O R R E C A O 						 
	//
	If nCorrecao > 0
		If lFerias
			fGrvArrPrv(aFerVenc, _Corre, _Anter, nCorrecao, { _Dias } )
			fGrvArrPrv(aFerProp, _Corre, _Anter, nCorrecao, { _Dias } )
		EndIf
		If l13oSal
			fGrvArrPrv(a13Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par } )
			If n14Salario > 0
				fGrvArrPrv(a14Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par } )
			EndIf
		Endif
	Endif

	//Ŀ
	// Zera variaveis para uma nova busca de salario e ferias		 
	//
    nV_DFalFer := nP_DFalFer := nTFaltaV := nTFaltaP := 0
    nSalario   := nSalMes    := nSalDia  := nSalHora := 0
    nAdtServ   := nPeric     := nInsal   := 0.00

	//Ŀ
	// Se mes estiver fechado, calcular com valores do SRT	         
	//
	If lFechouMes .And. fBusCabSRT(dDataRef,@aCabProv)
		dDtBasFer  := aCabProv[_DBsProv]
		nDFerAnt   := aCabProv[_DFerAnt]
	    nSalario   := aCabProv[_SalProv]
	    nSalMes    := aCabProv[_SalProv]
	    nSalDia    := aCabProv[_SalProv] / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
	    nSalHora   := aCabProv[_SalProv] / TPR->PR_HRSMES
	    lTemCab	:= .T.
	EndIf

	//Ŀ
	// 6 ELEMENTO DO ARRAY - B A I X A  D E  F E R I A S / 1 3 o   
	//
	If ( !lDemitido .Or. lProvResc ) .And. !lTransfSai	//?-
		If lFerias
			fBxaFerProv(@dDtBasFer,@nDFerAnt,cArqBxaPr,cFilBxaPr,cMatBxaPr,cDatBxaPr,cPdBxaPr,cSeqBxaPr,cValBxaPr,cHrsBxaPr,lTemCab)
		EndIf
		If l13oSal .And. lBx13Pgt .And. (Month(dDataRef) == 12 .Or. If(cPaisLoc $ "ARG|URU|PAR",Month(dDataRef) == nFec131 ,.F.))
			fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13,cDatBxa13,cPdBxa13,cValBxa13)
		EndIf
	EndIf

	//Ŀ
	// 4 ELEMENTO DO ARRAY - A T U A L 							 
	//
	If lTransfSai
		If nSalMes == 0
			//Ŀ
			// Calcula Salario Mes , Dia , Hora do Funcionario              |
			//
			fSalario(@nSalario,@nSalHora,@nSalDia,@nSalMes,"A")
		EndIf	
	Else
		//Ŀ
		// Calcula Salario Incorporado Mes , Dia , Hora do Funcionario  
		//
		If !lCalcSalInc
			cAliasPROC	:= "QPROC"
			fQrySRD( TPR->PR_FILIAL , TPR->PR_MAT , MesAno(dDataRef) )
			//-- Busca o salario mes, adic.tpo.servico, insalubridade e periculosidade
			While !(cAliasPROC)->(eof())
				If lFechouMes
					If !lTemCab .And. (cAliasPROC)->RD_PD == aCodFol[318,1]
						nSalMes += (cAliasPROC)->RD_VALOR
					ElseIf (cAliasPROC)->RD_PD == aCodFol[671,1]
						nAdtServ += (cAliasPROC)->RD_VALOR
					ElseIf (cAliasPROC)->RD_PD == aCodFol[672,1]
						nInsal += (cAliasPROC)->RD_VALOR
					ElseIf (cAliasPROC)->RD_PD == aCodFol[673,1]
						nPeric += (cAliasPROC)->RD_VALOR
					Endif
				Else
					If !lTemCab .And. (cAliasPROC)->RC_PD == aCodFol[318,1]
						nSalMes += (cAliasPROC)->RC_VALOR
					ElseIf (cAliasPROC)->RC_PD == aCodFol[671,1]
						nAdtServ += (cAliasPROC)->RC_VALOR
					ElseIf (cAliasPROC)->RC_PD == aCodFol[672,1]
						nInsal += (cAliasPROC)->RC_VALOR
					ElseIf (cAliasPROC)->RC_PD == aCodFol[673,1]
						nPeric += (cAliasPROC)->RC_VALOR
					Endif
				Endif
				(cAliasPROC)->(dbskip())
			Enddo
			(cAliasPROC)->(dbCloseArea())

			If !lTemCab
				nSalario:= nSalMes
				nSalDia	:= nSalMes / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
				nSalHora:= nSalMes / TPR->PR_HRSMES
			Endif
			//-- Carrega os codigos dos adicionais de tempo de servico que serao utilizados
			//-- nos calculos de provisoes de ferias e 13o salario.
			fCarAdics()
		Endif

		If nSalMes == 0 .Or. !lTemCab
			If lCalcSalInc .Or. nSalMes == 0
				fSalInc(@nSalario,@nSalMes,@nSalHora,@nSalDia,.T.)
			Endif
			//Ŀ
			//| Utiliza o Sal.Incorp. do Cadastro							 |
			//
			If lSalInc .And. TPR->PR_SALINCO > 0
				nSalMes  := TPR->PR_SALINCO
				nSalDia  := TPR->PR_SALINCO / If(cPaisLoc=="URU" .And. SRA->RA_CATFUNC=="H",25,30)
				nSalHora := TPR->PR_SALINCO / TPR->PR_HRSMES
			Endif
		Else
			//Ŀ
			// Chama funcao para carregar adicionais - AdtServ/Peric/Insal  
			//
			If lCalcSalInc
				fSalInc(,,,,.T.)
			Endif
    	EndIf
    	
		If lProvResc .And. lDemitido
			/*
			Ŀ
			 Verifica Demissao e Sexta Feira ou Sabado e Cons. Parametro
			 Para Pagar Sabado e Domingo.                               
			*/
			dDataDem1	:= TPR->PR_DEMISSA
			dDataDem1	:= fDtSabDom()
		EndIf

		//Ŀ
		// Carregando Arquivo TRP com Monta Media						 
		//
		If ( !lDemitido .Or. lProvResc )
			dbSelectArea("TRP")
			Zap                                                                   
			dRefMed	:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
			GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,(!lFechouMes),,,,.F.)
		Endif
		
		dbSelectArea( "TPR" )

		//Ŀ
		// Calcula ferias vencidas e proporcionais						 
		//
		If lFerias
			fProvFer(cCongAci,cCongDoe,@nTipoMovMes,@dDtBasFer)
		EndIf
		
		//Ŀ
		// Calcula o 13 Salario 										 
		//
		If l13oSal .And. ( !lDemitido .Or. lProvResc )
			fProv13o(cAbatAci,cAbatDoe,@nTipoMovMes,cAbatAdo)
		EndIf

	EndIf
	
	//Ŀ
	// 5 ELEMENTO DO ARRAY - B A I X A  T R A N S F E R E N C I A	 |
	// 7 ELEMENTO DO ARRAY - B A I X A  R E S C I S A O			 |
	//
	If lTransfSai .Or. lDemitido
		If lFerias
			If lTransfSai
				fGrvArrPrv(@aFerVenc, _BxTrf, _Anter, 1, {} )
				fGrvArrPrv(@aFerProp, _BxTrf, _Anter, 1, {} )
			Else
				fGrvArrPrv(@aFerVenc, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
				fGrvArrPrv(@aFerProp, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
			EndIf
		EndIf
		If l13oSal
			If lTransfSai
				fGrvArrPrv(@a13Salar, _BxTrf, _Anter, 1, {} )
				fGrvArrPrv(@a14Salar, _BxTrf, _Anter, 1, {} )
			Else
				fGrvArrPrv(@a13Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
				fGrvArrPrv(@a14Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
			EndIf
		EndIf
	EndIf

	//Ŀ
	// Atualiza o arquivo de cabecalho - SRF                     	 |
	//
	If ( !lDemitido .Or. lProvResc ) .And. !lTransfSai
		dbSelectArea( "SRF" )
		RecLock("SRF",.F.)
		If lFerias
			nDiasFv := aFerVenc[_Atual,_Dias] + nV_DFalFer
			nDiasFv += If(aFerVenc[_Atual,_Dias] > 0, nDFerAnt, 0)
			nDiasFv -= SRF->RF_DVENPEN
			If nDiasFv = 0 .And. nDFerAnt > 0
				nDiasFv := nDFerAnt * (-1)
			Endif
			aFerVenc[_Atual,_Dias] := If (nDiasFv < 0 .Or. lTrfSld, 0 , nDiasFv) + SRF->RF_DVENPEN
			//Ŀ
			// Soma os dias de faltas aos dias de proporcionais.        	 |
			//
			aFerProp[_Atual,_Dias] += nP_DFalFer
			SRF->RF_DFERVAT := If(nDiasFv < 0,0,nDiasFv)   // Dias de Ferias Vencidas
			SRF->RF_DFALVAT := If(nDiasFv # 0,Int(nTFaltaV),0)  // Dias de Faltas Vencidas
			SRF->RF_DFERAAT := aFerProp[_Atual,_Dias]		 // Dias de Ferias Proporcionais
			SRF->RF_DFALAAT := nTFaltaP				     // Dias de Faltas Proporcionais
		EndIf
		If l13oSal
			SRF->RF_PAR13AT := a13Salar[_Atual,_1Par]      // 1 Parcela do 13 Salario
		EndIf
		MsUnlock()
    EndIf
    
   	//Ŀ
	// Para o novo calculo de rateio, chama novamente a funcao que  |
	// apura os valores mensais para posterior geracao na tab. SRT  |		
	//	   	    
   	If lGeraPMes 
    
		#IFDEF TOP
			fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.T.,lFerias,l13oSal,.T.) 
		#ELSE
			If lFerias
				fBusDetSRT(@aFerVenc,@aRecVenc,aVerba,aTransf,dDataRef,_FerVenc,lTrataTrf,.T.,.T.)
				fBusDetSRT(@aFerProp,@aRecProp,aVerba,aTransf,dDataRef,_FerProp,lTrataTrf,.T.,.T.)
			EndIf	
			If l13oSal
				fBusDetSRT(@a13Salar,@aRec13Sl,aVerba,aTransf,dDataRef,_13Salar,lTrataTrf,.T.,.T.)
				fBusDetSRT(@a14Salar,@aRec14Sl,aVerba,aTransf,dDataRef,_14Salar,lTrataTrf,.T.,.T.)
			EndIf
		#ENDIF
    	
    Endif 
    
	//Ŀ
	// Grava as ferias vencidas e proporcinais no arquivo detalhe.  |
	//
	If lFerias
		fGeraSRT(@aFerVenc,aRecVenc,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerVenc)
		fGeraSRT(@aFerProp,aRecProp,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerProp)
	EndIf
                                              
	//Ŀ
	// Grava o 13 e 14 Salario no arquivo detalhe.		         |
	//
	If l13oSal
		fGeraSRT(@a13Salar,aRec13Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_13Salar)
		fGeraSRT(@a14Salar,aRec14Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_14Salar)
	EndIf

	//Ŀ
	// Se for recalculo, deletar o registro de "OK", indicando que  |
	//| devera ser gerado um novo SRZ no momento da contabilizacao.  |
	//
	fDelRegSRZ(3,"1",dDataRef)

	//Ŀ
	// Finaliza a gravacao dos lancamentos do SIGAPCO          
	//
	PcoFinLan("000091")
	
	Return(.T.)
	
#ENDIF

/*


ͻ
Programa  Open_TPR  Autor  Jonatas A. T. Alves  Data   26/08/08   
͹
Desc.     Funcao para abertura do arquivo TPR (exclusivo ou compart.).
͹
Uso        Gpem070                                                    
ͼ

*/
STATIC Function Open_TPR(cDbfProv,cNtxProv)

Local nTry		:= 20
Local cMsgExc	:= ""

// Reabre TPR em modo compartilhado 
USE (cDbfProv) ALIAS TPR SHARED NEW

// No Linux existe um time para liberacao da criacao do arquivo. Quando nao encontrar 
// o arquivo para abrir, dever aguardar um tempo. Esperar no maximo 20 segundos
While NetErr() .and. nTry > 0 
	nTry--
	sleep(1000)	//-- 1 segundo

	// Reabre TPR em modo compartilhado 
	USE (cDbfProv) ALIAS TPR SHARED NEW
Enddo

If NetErr()
	cMsgExc := CRLF + OemToAnsi(STR0055)// "Falha na abertura do arquivo temporario (TPR) em modo compartilhado!"
	UserException( cMsgExc )
EndIf

dbSetIndex(cNtxProv + OrdBagExt())
dbSetOrder(1)

Return

/*


ͻ
Programa  IniVarGrd Autor  Jonatas A. T. Alves  Data   27/08/08   
͹
Desc.     Funcao para inicializar variaveis Private da provisao.      
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	STATIC Function IniVarGrd()
	
	aFerVenc     := Array(_Linhas,_Colunas)
	aFerProp     := Array(_Linhas,_Colunas)
	aRecVenc     := Array(_Linhas,_Colunas)
	aRecProp     := Array(_Linhas,_Colunas)
	nV_DFalFer   := 0
	nP_DFalFer   := 0
	nTFaltaV   	 := 0
	nTFaltaP	 := 0
	nDFerAnt     := 0
	dDtBasFer    := CTOD("")
	
	//Ŀ
	// Variaveis Private - PROVISAO DE 13 SALARIO					 
	//
	a13Salar     := Array(_Linhas,_Colunas)
	a14Salar     := Array(_Linhas,_Colunas)
	aRec13Sl     := Array(_Linhas,_Colunas)
	aRec14Sl     := Array(_Linhas,_Colunas)
	
	//Ŀ
	// Variaveis Private - PROVISAO DE FERIAS E 13 SALARIO  |
	//
	nSalario	 := nSalMes  := nSalDia     := nSalHora  := 0
	nPercEmp	 := nPercTer := nPercAcTrab := nPercFgts := 0
	nPerEmp13	 := nAvosAnt := nPercAnt    := 0
	lDemitido    := .F.
	lDesAtiv     := .F.
	lTransfSai   := .F.
	c__Roteiro   := "   "

	//Ŀ
	// Variaveis Para Funcao fSalInc    						     
	//
	aRoteiro 	:= {}
	nAdtServ 	:= nPeric	:= nInsal := 0.00	  // Valores dos Adicionais
	cCodAdt  	:= cCodIns  := Space(3) 		  // Codigos que Foram Gerados
	nSalMin  	:= 0
	
	//Ŀ
	// Variaveis utilizadas na funcao fMonta_TPR()                
	//
	If cPaisLoc == "URU"
		lProvUru  := .T.
		cSemana   := "01"
		nAliqBse  := 0
		cApolice  := " "
	Endif
	
	//Ŀ
	// Ao passar pela fSalInc() o aPd deve ser zerado             
	//
	If Type("aPd") == "A"
		aPd := {}
	EndIf
	
	Return
#ENDIF

/*


ͻ
Programa  fQryFerBx Autor  Jonatas A. T. Alves  Data   08/09/08   
͹
Desc.     Query para geracao das baixas de Ferias (SRC ou SRD).       
͹
Uso        Gpem070                                                    
ͼ

*/
STATIC Function fQryFerBx(cArqBxaPr,cDataBusca,lExeQry)

Local nCntArq		:= 0
Local nReg			:= 0

Local lAs400		:= ExeInAS400()

Local cCposQuery	:= ""
Local cQuery		:= ""
Local cFrom			:= ""
Local cWhere		:= ""
Local cOrder		:= ""

Local aStruArq		:= {}

//Ŀ
// Query para filtrar informacoes do funcionario processado     
//
#IFDEF TOP
	If !lAs400

		lExeQry		:= .T.
		aStruArq 	:= (cArqBxaPr)->(dbStruct())
		
		For nCntArq := 1 To Len(aStruArq)
			If nCntArq < Len(aStruArq)
				cCposQuery	+= aStruArq[nCntArq,1] + ", "
			Else
				cCposQuery	+= aStruArq[nCntArq,1] + " "
			EndIf
		Next nCntArq
	
		cFrom	:= "FROM " + RetSqlName(cArqBxaPr) + " "
		
		If cArqBxaPr == "SRC"
			cWhere	:= "WHERE RC_FILIAL = '" + TPR->PR_FILIAL + "' AND "
			cWhere	+= "RC_MAT = '" + TPR->PR_MAT + "' AND "
		Else
			cWhere	:= "WHERE RD_FILIAL = '" + TPR->PR_FILIAL + "' AND "
			cWhere	+= "RD_MAT = '" + TPR->PR_MAT + "' AND "
			cWhere	+= "RD_DATARQ = '" + cDataBusca + "' AND "
		EndIf
		
		If TcSrvType() == "AS/400"
			cWhere	+= "@DELETED@ = ' ' "
		Else
			cWhere	+= "D_E_L_E_T_ = ' ' "
        EndIf
		
		cOrder	:= "ORDER BY " + SqlOrder( (cArqBxaPr)->( IndexKey(1) ) )
		
		cQuery 	:= "SELECT " + cCposQuery + cFrom + cWhere + cOrder
		cQuery	:= ChangeQuery(cQuery)

		cArqBxaPr	:= GetNextAlias()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cArqBxaPr)
		
		//-- Ajusta a estrutura dos campos
		For nReg := 1 To Len(aStruArq)
			If ( aStruArq[nReg][2] <> "C" )
				TcSetField(cArqBxaPr,aStruArq[nReg][1],aStruArq[nReg][2],aStruArq[nReg][3],aStruArq[nReg][4])
			EndIf
		Next nReg
		
		(cArqBxaPr)->(dbGoTop())
	EndIf
#ENDIF

Return

/*


ͻ
Programa  fQry13oBx Autor  Jonatas A. T. Alves  Data   08/09/08   
͹
Desc.     Query para geracao das baixas de 13o (SRI ou SRD).          
͹
Uso        Gpem070                                                    
ͼ

*/
STATIC Function fQry13oBx(cArqBxa13,dDataRef,cDataBusca,lBusDtRef,lExeQry)

Local nCntArq		:= 0
Local nReg			:= 0

Local cCposQuery	:= ""
Local cQuery		:= ""
Local cFrom			:= ""
Local cWhere		:= ""
Local cOrder		:= ""

Local lAs400		:= ExeInAS400()

Local aStruArq		:= {}

DEFAULT lBusDtRef	:= .F.

//Ŀ
// Query para filtrar informacoes do funcionario processado     
//
#IFDEF TOP
	If !lAs400
		
		lExeQry		:= .T.
		aStruArq 	:= (cArqBxa13)->(dbStruct())
		
		For nCntArq := 1 To Len(aStruArq)
			If nCntArq < Len(aStruArq)
				cCposQuery	+= aStruArq[nCntArq,1] + ", "
			Else
				cCposQuery	+= aStruArq[nCntArq,1] + " "
			EndIf
		Next nCntArq
	
		cFrom	:= "FROM " + RetSqlName(cArqBxa13) + " "
		
		If cArqBxa13 == "SRI" // 13o. Salario
			cWhere	:= "WHERE RI_FILIAL = '" + TPR->PR_FILIAL + "' AND "
			cWhere	+= "RI_MAT = '" + TPR->PR_MAT + "' AND "
		ElseIf cArqBxa13 == "SRC" // Movimento Mensal
			cWhere	:= "WHERE RC_FILIAL = '" + TPR->PR_FILIAL + "' AND "
			cWhere	+= "RC_MAT = '" + TPR->PR_MAT + "' AND "
			cWhere	+= "RC_PD IN('" + aCodFol[028,1] + "','" + aCodFol[348,1] + "') AND "
		Else // Acumulados Anuais (SRD)
			cWhere	:= "WHERE RD_FILIAL = '" + TPR->PR_FILIAL + "' AND "
			cWhere	+= "RD_MAT = '" + TPR->PR_MAT + "' AND "
		
			If lBusDtRef
				cWhere	+= "RD_DATARQ = '" + MesAno(dDataRef) + "' AND "
				cWhere	+= "RD_PD IN('" + aCodFol[028,1] + "','" + aCodFol[348,1] + "') AND "
			Else
				cWhere	+= "RD_DATARQ = '" + cDataBusca + "' AND "	
			EndIf
		EndIf
		
		If TcSrvType() == "AS/400"
			cWhere	+= "@DELETED@ = ' ' "
		Else
			cWhere	+= "D_E_L_E_T_ = ' ' "
        EndIf
		
		cOrder	:= "ORDER BY " + SqlOrder( (cArqBxa13)->( IndexKey(1) ) )
		
		cQuery 	:= "SELECT " + cCposQuery + cFrom + cWhere + cOrder
	
		cQuery	:= ChangeQuery(cQuery)
		cArqBxa13 := GetNextAlias()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cArqBxa13)
		
		//-- Ajusta a estrutura dos campos
		For nReg := 1 To Len(aStruArq)
			If ( aStruArq[nReg][2] <> "C" )
				TcSetField(cArqBxa13,aStruArq[nReg][1],aStruArq[nReg][2],aStruArq[nReg][3],aStruArq[nReg][4])
			EndIf
		Next nReg
		
		(cArqBxa13)->(dbGoTop())
	EndIf
#ENDIF

Return

/*


ͻ
Programa  fChgAlias Autor  Jonatas A. T. Alves  Data   08/09/08   
͹
Desc.     Modifica alias para arquivo temporario da Query.            
͹
Uso        Gpem070                                                    
ͼ

*/
STATIC Function fChgAlias(lChgFer,cNewAlias,cArq,cDatBxa,cFilBxa,cMatBxa,cPdBxa,cValBxa,cSeqBxa,cHrsBxa)

Local cNomeCpo	:= ""

DEFAULT lChgFer := .T.

If cArq == "SRC"
	cNomeCpo:= cNewAlias + "->RC_"
ElseIf cArq == "SRI"
	cNomeCpo:= cNewAlias + "->RI_"
Else
	cNomeCpo:= cNewAlias + "->RD_"
EndIf

cFilBxa := &( "{ || " + cNomeCpo + "FILIAL }" )
cMatBxa := &( "{ || " + cNomeCpo + "MAT }"    )
cPdBxa  := &( "{ || " + cNomeCpo + "PD }"     )
cValBxa := &( "{ || " + cNomeCpo + "VALOR }"  )

If lChgFer
	//Ŀ
	// Variaveis utilizadas para baixa de ferias e de rescisao nas|
	// provisoes de ferias e de 13o Salario (SRC ou SRD).         |
	//
	cDatBxa := &( "{ || MesAno(dDataRef) }" )
	cSeqBxa := &( "{ || " + cNomeCpo + "SEQ }"    )
	cHrsBxa := &( "{ || " + cNomeCpo + "HORAS }"  )
	
	If cArq == "SRD"
		cDatBxa := &( "{ || " + cNomeCpo + "DATARQ }" )
	EndIf
Else
	//Ŀ
	// Variaveis utilizadas para baixa de 13o Salario (SRI ou SRD)|
	//
	cDatBxa := &( "{ || Strzero(Year(" + cNewAlias + "->RI_DATA),4) }" )
	
	If cArq == "SRD"
		cDatBxa := &( "{ || " + cNomeCpo + "DATARQ }" )
	EndIf
EndIf

Return      

/*


ͻ
Programa  fGeraBaixaMes() Autor  Christiane Vieira  Data  04/09/12
͹
Desc.      Gravao das baixas no arquivo de proviso mensal - RHT    
͹
Uso        Gpem070                                                    
ͼ

*/
STATIC Function fGeraBaixaMes() 
	Local cAlias := Alias()
	                          
	DbSelectArea ("RHT")
	RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )	
	If !RHT->(dbSeek(SRT->RT_FILIAL+SRT->RT_MAT+SRT->RT_CC+SRT->RT_ITEM+SRT->RT_CLVL+DTOS(SRT->RT_DATACAL)+SRT->RT_TIPPROV+SRT->RT_VERBA))
		RecLock( "RHT", .T. )
		RHT->RHT_FILIAL  := SRT->RT_FILIAL
		RHT->RHT_MAT     := SRT->RT_MAT
		RHT->RHT_CC      := SRT->RT_CC
		If lItemClVl
			RHT->RHT_ITEM := SRT->RT_ITEM
			RHT->RHT_CLVL := SRT->RT_CLVL
		EndIf
		RHT->RHT_TPPROV  := SRT->RT_TIPPROV
		RHT->RHT_VERBA   := SRT->RT_VERBA
	Else
		RecLock( "RHT", .F. )
	Endif
	RHT->RHT_SALAR  := nSalMes
	RHT->RHT_DTCALC := SRT->RT_DATACAL
	RHT->RHT_VALOR  := SRT->RT_VALOR
	RHT->RHT_PERC	:= 100
	
	MsUnlock()	
	
    DbSelectArea ( cAlias )
Return

/*


ͻ
Programa  CriaTransfAutor  Jonatas A. T. Alves  Data   10/03/09   
͹
Desc.     Cria tabela com replica das informacoes do array aTransf.   
͹
Uso        Gpem070                                                    
ͼ

*/
#IFDEF TOP
	STATIC Function CriaTransf()
	
	Local lRet			:= .T.
	Local aFields		:= {}
	Local cRdd			:= "TOPCONN"
	Local cQuery		:= ""
	Local nTamPos		:= Len( Alltrim( Str( nTamTrf ) ) )

	Begin Sequence
		IF ( !MsFile( cFileTrf , NIL , cRdd ) )	

			AADD(aFields,{"TRFPOS"		,"N",nTamPos				,0})
			AADD(aFields,{"TRFELE"		,"N",01						,0})
			AADD(aFields,{"TRFEMPP"		,"C",02						,0})
			AADD(aFields,{"TRFFILIALP"	,"C",FWGETTAMFILIAL  		,0})
			AADD(aFields,{"TRFCCP"		,"C",TamSX3("RA_CC")[1]		,0})
			AADD(aFields,{"TRFMATP"		,"C",TamSX3("RA_MAT")[1]	,0})
			AADD(aFields,{"TRFDATE"		,"C",06						,0})
			AADD(aFields,{"TRFNLIDO"	,"L",01						,0})

			IF !( lRet := MsCreate( cFileTrf , aFields , cRdd ) )
				Break
			EndIF
		Else
			cQuery := "DELETE FROM " + cFileTrf
			TcSqlExec( cQuery )
		Endif

		IF !( lRet := MsOpenDbf( .T. , cRdd, cFileTrf , cTrfDbf , .T. , .F. , .F. , .F. ) )
			Break
		EndIF

		IF !( lRet := ( Select( cTrfDbf ) > 0 ) )
			Break
		EndIF
	End Sequence
	
	Return (lRet)
#ENDIF


/*


ͻ
Programa  fChkRHQBaseAutor  Aldo Marini          Data   07/11/11  
͹
Desc.     Verifica a existencia da tabela RHQ-Programacao de Rateio   
          para poder gerar os lancamentos rateados no SRT/Contabilizar
͹
Uso        GPEM110/GPEM070                                            
ͼ


*/
Function fChkRHQBase()
Local lRet 		:= .F.
Local aArea		:= GetArea()
Local aSM0Area	:= SM0->(GetArea())    
Local nOrdem		

SX2->(dbSetOrder(1))
If SX2->( dbSeek( "RHQ" ) )
	dbSelectArea("RHQ")
	If RHQ->(FieldPos( "RHQ_MAT" ) ) > 0
		lRet := .T.
	Endif
Endif

//Ŀ
// Caso tenha sido executada a opcao do compatibilizador que  |
// cria rateio por mes das provisoes, verifica a existencia de|
// verba associada aos novos ids. Caso exista pelo menos um   |
// dos identificadores abaixo associado, consideramos o rateio|
// 960 - Frias, 966 - 13o., 968 - 1a parcela do 13o.		   |
//

IF lRet	
	lRet:= .F.	
	//-- Verifica a amarracao SRV x Id de Provisao por rateio
	//-- Se o acodfol ja tenha sido carregado, utiliza-o.
	IF Type("acodfol") <> "U"
	   IF   ( ;
			   	!Empty( aCodFol[960] ) .or.  	;
				!Empty( aCodFol[961] ) .or.  	;
				!Empty( aCodFol[962] ) 	.or.	;
			  	!Empty( aCodFol[963] ) .or.  	;				
			  	!Empty( aCodFol[964] ) .or.  	;			  	
			  	!Empty( aCodFol[965] ) .or.  	;			  	
			  	!Empty( aCodFol[966] ) .or.  	;
				!Empty( aCodFol[967] ) .or.  	;				  				  					  	
				!Empty( aCodFol[968] ) .or.  	;				  					
				!Empty( aCodFol[969] ) .or.  	;				  					
				!Empty( aCodFol[970] ) .or.  	;				  													
			  	!Empty( aCodFol[971] ) 		 	;			  	
			)
			lRet:= .T.
		Endif	
   
	Else
		//-- Corre todas as filiais em busca de verba associada a algum identificador de rateio 
		//-- Na existencia de pelo menos uma das associacoes, o rateio est efetivado
		//-- Paliativamente consideramos que se pelo menos uma filial atende a codicao de efetivacao
		//-- as demais obrigatoriamente estarao configuradas para tal.
		SM0->(dbGoTop()) 
		nOrdem	:= RetOrdem("SRV","RV_FILIAL+RV_CODFOL")
		While SM0->(!Eof())
		     IF 	(;
						( !Empty( PosSrv("0960",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0961",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0962",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0963",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0964",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0965",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0966",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0967",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0968",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;
						  !Empty( PosSrv("0969",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;						  
						  !Empty( PosSrv("0970",  FWCodFil(), "RV_COD",nOrdem, .F. ) ) .or. ;						  						  
						  !Empty( PosSrv("0971",  FWCodFil(), "RV_COD",nOrdem, .F. ) )  	 ; 
						 );
					)
					lRet:= .T.	
					Exit
			Endif
			SM0->(dbSkip())
		EndDo
	Endif
Endif

RestArea(aSM0Area)
RestArea(aArea)

Return lRet

/*
ͻ
					CONCEITOS UTILIZADOS NA PROVISAO					  
ͺ
Transferencia - Conceito 1:											  
Efetua a transferencia sem baixar o saldo origem, provisionando o destino
a partir do saldo anterior.											  
																		  
Transferencia - Conceito 2:											  
Efetua a transferencia baixando o saldo do C.Custo origem e provisionando
integralmente no C.Custo destino.										  
																		  
ͼ*/

/*


Ŀ
Funao	 fPercEmp   Autor  Allyson M				 Data  29.11.12 
Ĵ
Descriao  Carrega variaveis para calculo dos encargos				  
Ĵ
Sintaxe	  fPercEmp(cRecFatEmp, nPercEmp, nPerEmp13)				  
Ĵ
Parametros cRecFatEmp 	 - Empresa Mista ou Exclusiva s/ faturamento  
           nPercEmp 	 - Percentual da Empresa                      
           nPerEmp13 	 - Percentual da Empresa p/ 13o. Salario      
Ĵ
 Uso	 	  GPEM070	 												  
ٱ
 */
Static Function fPercEmp(cRecFatEmp, nPercEmp, nPerEmp13)

Local aTabOner	:= {}
Local aTabS033	:= {}
Local cAnoMes	:= AnoMes( dDataRef )
Local cDesFol	:= SuperGetMv( "MV_DESFOL",,"" )
Local cLimRef	:= Str( Val( SubStr( cAnoMes, 1, 4 ) ) - 1, 4 ) + "12"
Local cRefAux	:= cAnoMes
Local lContinua	:= .T.
Local nPosOnera	:= 0
Local nFatDes	:= 0
Local nFatFol	:= 0
Local nFatTot	:= 0

If cAnoMes < cDesFol
	lDesAtiv	:= .F.
	nPercEmp	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	nPerEmp13	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
Else
	//Se o ano de referencia for maior do que o ano do MV_DESFOL ou se o mes de inicio da desoneracao 
	//for '01' (janeiro), nao e' necessario fazer a  proporcionalizacao do INSS
	If ( ( SubStr( cAnoMes, 1, 4 ) > SubStr( cDesFol, 1, 4 ) ) ) .Or. SubStr( cDesFol, 5, 2 ) == "01"
		lDesAtiv	:= .F.
	Else
		lDesAtiv	:= .T.	
		nAvosAnt    := Val( SubStr( cDesFol, 5, 2 ) ) - 1
		nPercAnt	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	EndIf
	If cAnoMes > cOnefol .And. !Empty(cOneFol) .And. SubStr(cOneFol,1,4) == SubStr(cAnoMes,1,4)
		lOneAtiv	:= .T.	
		lDesAtiv	:= .F.
		nAvosAnt    := Val( SubStr( cOneFol, 5, 2 ) )
		//Carrega a tabela S033 com a data do parametro MV_FDESFOL para encontrar o cRecFatEmp da epoca.
		fCarrTab( @aTabOner, "S033", , cOneFol )
		nPosOnera := Ascan(aTabOner, { |X| X[6] == "2" })
		If nPosOnera > 0
			cRecFatEmp := "oM"
		Else
			cRecFatEmp := "oS"
		Endif			
	Else
		lOneAtiv := .F.
	Endif
	If cRecFatEmp $ "S|oS"
		If cRecFatEmp == "oS"
			nPercEmp := If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
			nPerEmp13	:= If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
		Else
			nParcEmp := 0.00
			nPerEmp13	:= 0.00
		Endif
	Else
		//Ferias utiliza o faturamento do mes de calculo da provisao
		If lFerias
			//Chama fCarrTab para recarregar tabela auxiliar S033
			fCarrTab( @aTabS033, "S033", , cAnoMes )
	    	nPercEmp := fPerFatEmp( cRecFatEmp, 0, aInssEmp[01, 1], aTabS033 )[1]
	  	EndIf
	  	//13o. Salario utiliza o faturamento acumulado de dezembro/ano anterior ate o mes de calculo da provisao
	  	//se a desoneracao comecou no mesmo ano do calculo efetuado na provisao
	  	If l13oSal
			//Primeiro tenta encontrar a referencia aaaa13 na tabela S033 e se nao encontrar,
	        //faz os processos para encontrar o percentual de 13o.
			If Month( dDataRef ) == 12
				aTabS033 := {}
				//Chama fCarrTab para recarregar tabela auxiliar S033
		        fCarrTab( @aTabS033, "S033", , Str( Year( dDataRef ), 4 ) + "13" )
				//Se encontrou lancamentos
				If !Empty( aTabS033 )
					//Apura a receita bruta total da empresa
					aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[10] } )
					//Deduz as exclusoes da receita bruta total da empresa
					aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[11] } )
					//Apura a receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes += aTabS033[10], ) } )
					//Deduz as exclusoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[11], ) } )
					//Apura a receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol += aTabS033[10], ) } )	        
					//Deduz as exclusoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[11], ) } )					
					lContinua := .F.
	            Else
					cRefAux := SubMesAno( cRefAux )	
				EndIf
            EndIf
            If lContinua
            	If nVerFatFin != 1
		        	fAtuS033( cRefAux, cLimRef )
		        EndIf
		  		//Enquanto nao atingir a ano/mes limite para busca do faturamento faz a soma do faturamento
		  		//obtido na comeptencia verificada
		  		While cRefAux >= cLimRef
					aTabS033 := {}
					//Chama fCarrTab para recarregar tabela auxiliar S033
					fCarrTab( @aTabS033, "S033", , cRefAux )
					//Apura a receita bruta total da empresa
					aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[10] } )
					//Deduz as exclusoes da receita bruta total da empresa
					aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[11] } )
					//Apura a receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes += aTabS033[10], ) } )
					//Deduz as exclusoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[11], ) } )
					//Apura a receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol += aTabS033[10], ) } )					
					//Deduz as exclusoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
					aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[11], ) } )
					//Subtrai um mes da variaval que controla a competencia
		  			cRefAux := SubMesAno( cRefAux )	
		  		End While
			EndIf
			//Calcula a razao entre o faturamento de atividades diversas sobre o faturamento total
			nPerEmp13 	:= ( nFatFol / nFatTot )		
			//Calcula o novo percentual de acordo com a razao encontrada e o percentual de recolhimento antigo

			//Receita nao Desonerada IGUAL/MAIOR que 95% do Total - Aplicacao da aliquota padrao
			If cRecFatEmp $ "M|oM" .And. nPerEmp13 >= 0.95
				nPerEmp13 := If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] )
			//Receita nao Desonerada MAIOR que 5% e MENOR que 95% do Total - Aplicacao da aliquota reduzida
			ElseIf cRecFatEmp $ "M|oM" .And. ( nPerEmp13 > 0.05 .And. nPerEmp13 < 0.95 )
				nPerEmp13 := ( ( nPerEmp13 * If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] ) ) )
			//Receita nao Desonerada MAIOR que 5% - Aplicacao da aliquota reduzida
			ElseIf cRecFatEmp == "C" .And. nPerEmp13 > 0.05
				nPerEmp13 := ( ( nPerEmp13 * If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] ) ) )
			Else
			    //A aliquota sera zerada
			    If aInssEmp[27, 1] $ "S*M"
			       nPerEmp13:=0
			    Else   
				   nPerEmp13 := If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] )
				Endif
			EndIf
			If lOneAtiv
				nPercAnt := nPerEmp13
				nPerEmp13 := If (TPR->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] )
			Endif
	  	EndIf
	EndIf
EndIf

Return

/*


Ŀ
Funao	 fAtuS033   Autor  Allyson M				 Data  29.11.12 
Ĵ
Descriao  Alimenta tabela S033										  
Ĵ
Sintaxe	  fAtuS033( cAnoMes, cLimRef )				  				  
Ĵ
Parametros cRefAux	 - Ano/Mes inici  								  
           cLimRef 	 - Ano/Mes limite para busca da receita           
Ĵ
 Uso	 	  GPEM070													  
ٱ
 */
Static Function fAtuS033( cRefAux, cLimRef )

Local aArea			:= GetArea()
Local aAreaSM0	 	:= SM0->( GetArea() )
Local aFilProc		:= {}
Local aTabS033		:= {}
Local cCodEmp	 	:= SM0->M0_CODIGO
Local cSvFilAnt		:= ""
Local nAliq	 		:= 0
Local nContr		:= 0
Local nFatTot	 	:= 0
Local nFatTotDev	:= 0
Local nFatTotExp	:= 0
Local nFatTotLiq	:= 0
Local nFatRec 		:= 0
Local nFatExc 		:= 0
Local nFatExp 		:= 0
Local nFatDExp 		:= 0
Local nFatBas		:= 0
Local nFilial		:= 0
Local nTotCLiq		:= 0
Local nTotCont 		:= 0 
Local nTotDev 		:= 0 
Local nTotExp 		:= 0 
Local nVlAux		:= 0
Local aCargFil	:= {}

//Monta o array das filiais a processar.

aCargFil := FwLoadSm0()

aEval(aCargFil,{|aCargFil| If(aCargFil[1] == cCodEmp, Aadd(aFilProc,{ aCargFil[2] }),Nil )} )

While cRefAux >= cLimRef
	//Reinicializa variaveis
	nAliq	 	:= 0
	nContr		:= 0
	nFatTot	 	:= 0
	nFatTotDev	:= 0
	nFatTotExp	:= 0
	nFatTotLiq	:= 0
	nFatRec 	:= 0
	nFatExc 	:= 0
	nFatExp 	:= 0
	nFatDExp 	:= 0
	nFatBas		:= 0
	nTotCont 	:= 0 
	nTotDev 	:= 0 
	nTotExp 	:= 0 
	nTotCLiq 	:= 0 
	nVlAux	 	:= 0 
	aTabS033	:= {}
	//Chama fCarrTab para recarregar tabela auxiliar S033
	fCarrTab( @aTabS033, "S033", , cRefAux )	
	//Verifica todas as filiais que foram selecionadas no processamento, 
	//para validar se possuem registro na tabela auxiliar S033
	For nFilial := 1 To Len( aFilProc )
		//Se nao encontrar registros para a filial, verificar as funcoes das integracoes
		If ( aScan( aTabS033, {|x| x[2] == aFilProc[nFilial, 1] } ) == 0 )
		   	//Se somente verifica Financeiro
		   	If nVerFatFin == 3
				//Entra na funcao do Financeiro para buscar os valores dos titulos de acordo
				//com a filial logada. A funcao nao permite passar a filial como parametro
				//entao a variavel cFilAnt sera alterada de acordo com a filial em processamento.
				//A funcao retorna o valor das receitas financeiras.					
				cSvFilAnt := cFilAnt
				cFilAnt	  := aFilProc[nFilial, 1]
				nFatTot   := FTotF100( Val( SubStr( cRefAux, 5, 2 ) ), Val( SubStr( cRefAux, 1, 4 ) ) )
				cFilAnt	  := cSvFilAnt
		        //Grava o registro da receito de tipo 2
				If nFatTot > 0
					fGravaS033( aFilProc[nFilial, 1], cRefAux, Nil, "2", nFatTot, 0.00, 0.00, nFatTot, 0.00, 0.00, aTabS033 )					
				EndIf	            	
		   	//Se verifica Faturamento e/ou Financeiro
		   	Else
				//Entra na funcao do Faturamento para buscar os valores das notas fiscais de saida
				//na tabela SD2 para verificar o faturamento da filial na competencia. A funcao
				//do faturamento retorna os dados gravados em um alias temporario
				cSvFilAnt := cFilAnt
				cFilAnt	  := aFilProc[nFilial, 1]
				cAliasFat := RhInssPat( SubStr( cRefAux, 5, 2 ) +  SubStr( cRefAux, 1, 4 ), aFilProc[nFilial, 1] )
				cFilAnt	  := cSvFilAnt
				If !Empty( cAliasFat )
					dbSelectArea( cAliasFat )
					(cAliasFat)->( dbGoTop() )
					While (cAliasFat)->( !EoF() )
				        cCodAti		:= (cAliasFat)->CODATV
				        cTipFat 	:= "1"
				        nAliq		:= SpedPCCG1( cCodAti, dDataRef )
				        nFatTot 	:= (cAliasFat)->TOTAL 		// Total
		                nFatTotLiq 	:= (cAliasFat)->TOTALLIQ	// Total
				        nFatTotDev 	:= (cAliasFat)->TOTLIQDEV 	// Total devolucao
				        nFatTotExp 	:= (cAliasFat)->TOTLIQEXP  	// Total exportacao
				        nFatRec		:= (cAliasFat)->TOTCODAT	// Total do codigo de atividade
				        nFatExc		:= (cAliasFat)->TCATVDEV	// Total devolucoes do codigo de atividade
				        nFatExp		:= (cAliasFat)->TCATVEXP	// Total exportacoes do codigo de atividade
				        nFatDExp	:= (cAliasFat)->TCATVDVEX	// Total devolucoes de exportacoes do codigo de atividade
				        nFatBas 	:= (cAliasFat)->TCDEVEXP 	// Total codigo de atividade - devolucoes - exportacoes (base calculo)
			            //Calcula a contribuicao com base na aliquota encontrada
				        If nAliq > 0
					        nContr	:= ( nFatBas * ( nAliq/100 ) )
					  	EndIf
				        //Grava a informacao do recolhimento devido na tabela auxiliar S033.
						If nFatBas > 0
							fGravaS033( aFilProc[nFilial, 1], cRefAux, cCodAti, cTipFat, nFatBas, nAliq, nContr, nFatRec, nFatExc, nFatExp, aTabS033 )
							//Chama fCarrTab para recarregar tabela auxiliar S033
							aTabS033 := {}
							fCarrTab( @aTabS033, "S033", , cRefAux ) 
						Else
							 //Senao tiver faturamento com produtos com cod atividade, mas tiver algum faturamento gravar tabela S033, com tipo 2 (produtos nao desonerados)
							If nFatTot > 0 
								If Empty(cCodAti) 
									cTipFat 	:= "2"
								Else
									cTipFat 	:= "1"
								EndIf
								fGravaS033( aFilProc[nFilial, 1], cRefAux, cCodAti, cTipFat, nFatBas, nAliq, nContr, nFatRec, nFatExc, nFatExp, aTabS033 )
								//Chama fCarrTab para recarregar tabela auxiliar S033
								aTabS033 := {}
								fCarrTab( @aTabS033, "S033", , cRefAux )   
							EndIf
						EndIf
						(cAliasFat)->( dbSkip() )
					End While
				EndIf
						
				//Faz a totalizacao da faturamento da filial gravadas na tabela S033
				aEval(aTabS033, {|aTabS033| If( aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotCont += aTabS033[10], Nil ) } )
				aEval(aTabS033, {|aTabS033| If( aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotCLiq += aTabS033[7], Nil ) } )
				aEval(aTabS033, {|aTabS033| If( aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotDev += aTabS033[11], Nil ) } )
				aEval(aTabS033, {|aTabS033| If( aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotExp += aTabS033[12], Nil ) } )
				//Entra na funcao do Financeiro para buscar os valores dos titulos de acordo
				//com a filial logada. A funcao nao permite passar a filial como parametro
				//entao a variavel cFilAnt sera alterada de acordo com a filial em processamento.
				//A funcao retorna o valor da receita total.						
				If nVerFatFin == 4
					cSvFilAnt := cFilAnt
					cFilAnt	  := aFilProc[nFilial, 1]
					nVlAux    := FTotF100( Val( SubStr( cRefAux, 5, 2 ) ), Val( SubStr( cRefAux, 1, 4 ) ) )
					nFatTot   += nVlAux
					nFatTotLiq+= nVlAux
					cFilAnt	  := cSvFilAnt
				EndIf
				//Se o total de faturamento da filial for maior do que os registros gravados
				//significa que ha faturamento de atividades que nao estao enquadradas na Lei
				//Esse registro deve ser gravado na tabela auxiliar com o tipo de receita 2
				If nFatTotLiq > nTotCLiq
					fGravaS033( aFilProc[nFilial, 1], cRefAux, Nil, "2", ( nFatTotLiq - nTotCLiq - ( nFatTotDev - nTotDev ) - ( nFatTotExp - nTotExp ) ), 0.00, 0.00, ( nFatTot - nTotCont ), ( nFatTotDev - nTotDev ), ( nFatTotExp - nTotExp ), aTabS033 )					
				EndIf
				(cAliasFat)->( dbCloseArea() )
			EndIf
		EndIf
	Next nFilial
	//Subtrai um mes da variaval que controla a competencia
	cRefAux := SubMesAno( cRefAux )		
End While

RestArea(aArea)
RestArea(aAreaSM0)

Return

/*


ͻ
Programa  fVerPerg  Autor  Allyson M			  Data   29/11/2012 
͹
Desc.     Funcao para validar atualizacao de perguntas p/ desoneracao 
͹
Uso        Gpem070                                                    
ͼ

*/
Static Function fVerPerg()

Local aArea  := GetArea()
Local cPerg  := "GPM070"
Local lAchou := .F.               

dbSelectArea( "SX1" )
SX1->( dbSetOrder(1) )
If dbSeek( cPerg + Space( 10 - Len(cPerg) ) + "15")
	lAchou := .T. 
EndIf

RestArea(aArea)

Return(lAchou)
